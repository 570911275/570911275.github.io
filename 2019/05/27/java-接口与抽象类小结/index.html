<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  

  
  <title>java_接口与抽象类小结 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="1.抽象类与具体类1.抽象类&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;a.有些类不该被初始化,则通过标记类为抽象类。&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;//抽象类仍可以作为引用类型。&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;//抽象类不可被初始化。&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;b.抽象类除了被继承过之外,是没">
<meta name="keywords" content="java_基础">
<meta property="og:type" content="article">
<meta property="og:title" content="java_接口与抽象类小结">
<meta property="og:url" content="https://github.com/570911275/570911275.github.io/2019/05/27/java-接口与抽象类小结/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="1.抽象类与具体类1.抽象类&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;a.有些类不该被初始化,则通过标记类为抽象类。&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;//抽象类仍可以作为引用类型。&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;//抽象类不可被初始化。&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;b.抽象类除了被继承过之外,是没">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2019-05-27T15:02:24.054Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="java_接口与抽象类小结">
<meta name="twitter:description" content="1.抽象类与具体类1.抽象类&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;a.有些类不该被初始化,则通过标记类为抽象类。&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;//抽象类仍可以作为引用类型。&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;//抽象类不可被初始化。&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;b.抽象类除了被继承过之外,是没">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://github.com/570911275/570911275.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-java-接口与抽象类小结" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/05/27/java-接口与抽象类小结/" class="article-date">
  <time datetime="2019-05-27T15:01:14.000Z" itemprop="datePublished">2019-05-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      java_接口与抽象类小结
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="1-抽象类与具体类"><a href="#1-抽象类与具体类" class="headerlink" title="1.抽象类与具体类"></a>1.抽象类与具体类</h2><p>1.<strong>抽象类</strong><br><br>&nbsp;&nbsp;&nbsp;&nbsp;a.有些类不该被<strong>初始化</strong>,则通过<strong>标记类为抽象类</strong>。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//抽象类仍可以作为<strong>引用类型</strong>。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//抽象类<strong>不可被初始化</strong>。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;b.抽象类<strong>除了被继承过</strong>之外,是<strong>没有用途</strong>、<strong>没有值</strong>、<strong>没有目的</strong>的。<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">abstract public class Canine extends Animal</span><br><span class="line">&#123;</span><br><span class="line">    //定义一个抽象类&quot;Canine&quot;;</span><br><span class="line">    public void roam();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class MakeCanine&#123;</span><br><span class="line">    public void go()&#123;</span><br><span class="line">        Canine c;</span><br><span class="line">        c = new Dog;</span><br><span class="line">        //此处是可以通过编译器的;</span><br><span class="line">        //因为可以赋值子类对象给父类的引用&quot;c&quot;。即使该父类&quot;Canine&quot;为抽象的。</span><br><span class="line">        c = new Canine();</span><br><span class="line">        //此处是不可以通过编译器的;</span><br><span class="line">        //因为这个类&quot;Canine&quot;已经被标记为抽象的了。不可以被初始化</span><br><span class="line">        c.roam();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>2.<strong>具体类</strong><br><br>不是抽象的类,就是<strong>具体类</strong><br></p>
<hr>

<h2 id="2-抽象的方法"><a href="#2-抽象的方法" class="headerlink" title="2.抽象的方法"></a>2.抽象的方法</h2><p>1.除了类之外,也可以将<strong>方法</strong>标记为”<strong>abstract</strong>“。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;a.<strong>抽象的类</strong>代表此类<strong>必须要被继承”extend”过</strong>。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;b.<strong>抽象的方法</strong>代表此方法<strong>必须要被覆盖过</strong>。<br><br><br>2.抽象的方法<strong>没有实体</strong><br><br>&nbsp;&nbsp;&nbsp;&nbsp;//因为抽象的方法<strong>必须要被覆盖</strong>,所以编写出抽象方法的代码<strong>没有意义</strong>(即不会含有方法在其中)。<br><br><br>3.抽象的方法<strong>所在的类</strong>必须为<strong>抽象</strong>的<br><br>&nbsp;&nbsp;&nbsp;&nbsp;//就算<strong>只有一个</strong>方法是抽象的,该类也必须为<strong>抽象类</strong>。<br><br>4.抽象方法的<strong>意义</strong><br><br>&nbsp;&nbsp;&nbsp;&nbsp;a.抽象的意义在于:就算无法实现出方法的的内容，但是还可以定义出一组<strong>子型共同的协议</strong><br><br>&nbsp;&nbsp;&nbsp;&nbsp;b.好处:利于多态。这样所有的子型都会有那些抽象的方法。<br><br><br>5.抽象方法的<strong>要求</strong><br><br>&nbsp;&nbsp;&nbsp;&nbsp;a.<strong><em>第一个具体类</em></strong>必须实现<strong>所有</strong>的<strong>抽象方法</strong>。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//必须实现所有的方法:表示必须<strong>写出内容</strong>,必须以<strong>相同的方法</strong>鉴名(<strong>名称</strong>和<strong>参数</strong>)和<strong>相容的返回类型</strong>创建出<strong>非抽象的方法</strong>。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;b.抽象类可以带有<strong>抽象</strong>的和<strong>非抽象</strong>的方法。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//这表示抽象类可以<strong>实现部分抽象方法</strong>,这样<strong>第一个具体类</strong>就可以<strong>不必去实现</strong>这一部分。<br></p>
<hr>

<h2 id="3-对象之母——Object"><a href="#3-对象之母——Object" class="headerlink" title="3.对象之母——Object"></a>3.对象之母——Object</h2><p>1.<strong>在java中所有的类都是从Object这个类继承出来的</strong>。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;a.<strong>Object</strong>是<strong>所有类的源头</strong>,他是<strong>所有类的父类</strong>。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;b.如果java中<strong>没有共同的父类</strong>,讲<strong>无法创建</strong>出可以处理<strong>自定义类型的类</strong>(即无法写出如同<strong>ArrayList</strong>这样可以<strong>处理各种类的类</strong>)。<br><br><br>2.<strong>没有继承</strong>过其他类的类会是<strong>隐含的继承对象</strong><br><br>&nbsp;&nbsp;&nbsp;&nbsp;//如同”Dog”这个类<strong>没有直接继承”extend”对象”Object”</strong>,但是还是会<strong>通过”Dog”的父类</strong>“Animal”来<strong>继承对象”Object”</strong>。<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">关于上述1——b的ArrayList</span><br><span class="line">ArrayList:</span><br><span class="line">boolean remove(Object elem)</span><br><span class="line">//根据索引参数移动对象,如果list中没有元素返回true。</span><br><span class="line"></span><br><span class="line">boolean contains(Object elem)</span><br><span class="line">//如果和对象的参数相匹配的话返回true</span><br><span class="line"></span><br><span class="line">int indexOf(Object elem)</span><br><span class="line">//返回对象参数的索引或-1</span><br><span class="line"></span><br><span class="line">由上述例子可知,许多的ArrayList的方法都用到了Object这个终极类型。</span><br><span class="line">因为每个类都是对象&quot;Object&quot;的子类,所以ArrayList可以处理任何类。</span><br></pre></td></tr></table></figure></p>
<p>3.<strong>Object中的方法</strong>(部分)<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">1.equals(Object o) 判断是否相等</span><br><span class="line">eg:</span><br><span class="line">Dog d = new Dog();</span><br><span class="line">Cat c = new Cat();</span><br><span class="line">if(d.equals(c))&#123;</span><br><span class="line">    System.out.println(&quot;true&quot;);</span><br><span class="line">&#125;else&#123;</span><br><span class="line">    System.out.println(&quot;false&quot;);</span><br><span class="line">&#125;</span><br><span class="line">//此处打印出&quot;flase&quot;</span><br><span class="line"></span><br><span class="line">2.getClass() 告知用户对象是从哪里被初始化的</span><br><span class="line">eg:</span><br><span class="line">Cat c = new Cat();</span><br><span class="line">Systrm.out.println(c.getClass())</span><br><span class="line">//此处打印出&quot;class Cat&quot;</span><br><span class="line"></span><br><span class="line">3.hashCode() 列出此对象的哈希代码(如同唯一的ID)</span><br><span class="line">eg:</span><br><span class="line">Cat c = new Cat();</span><br><span class="line">Systrm.out.println(c.hashCode())</span><br><span class="line">//此处打印出&quot;8202111&quot;</span><br><span class="line"></span><br><span class="line">4.toString() 列出类的名称和一串数字</span><br><span class="line">eg:</span><br><span class="line">Cat c = new Cat();</span><br><span class="line">Systrm.out.println(c.toString())</span><br><span class="line">//此处打印出&quot;Cat@7d277f&quot;</span><br></pre></td></tr></table></figure></p>
<p>4.使用<strong>Object类型的多态引用</strong>的后果<br><br>&nbsp;&nbsp;&nbsp;&nbsp;a.此处<strong>不涉及</strong>制作出<strong>Object类型的实例</strong>。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;b.任何<strong>被Object类型的引用变量</strong>所引用的对象,将被编译器认为为<strong>Object类型</strong>。<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">正常的:</span><br><span class="line">ArrayList&lt;Dog&gt; myDogArrayList = new ArrayList&lt;Dog&gt;();</span><br><span class="line">//保存Dog的Arraylist</span><br><span class="line">Dog aDog = new Dog();</span><br><span class="line">//新建一个Dog</span><br><span class="line">myDogArrayList.add(aDog);</span><br><span class="line">//将aDog放入ArrayList中</span><br><span class="line">Dog d = myDogArrayList.get(0);</span><br><span class="line">//讲Dog赋值给新的Dog引用变量</span><br><span class="line"></span><br><span class="line">Object类型的引用变量下:</span><br><span class="line">ArrayList&lt;Object&gt; myDogArrayList = new ArrayList&lt;Object&gt;();</span><br><span class="line">//保存Object的Arraylist</span><br><span class="line">Dog aDog = new Dog();</span><br><span class="line">//新建一个Dog</span><br><span class="line">myDogArrayList.add(aDog);</span><br><span class="line">//将aDog放入ArrayList中</span><br><span class="line">Dog d = myDogArrayList.get(0);</span><br><span class="line">//此处无法通过编译器</span><br><span class="line">//因为对ArrayList&lt;Object&gt;调用get()方法会返回Object类型</span><br><span class="line">//编译器无法确认它为Dog</span><br><span class="line">//即任何从ArrayList&lt;Object&gt;中取出的Object都会被当做是Object这个类的实例。</span><br></pre></td></tr></table></figure></p>
<hr>

<h2 id="4-引用类型"><a href="#4-引用类型" class="headerlink" title="4.引用类型"></a>4.引用类型</h2><p>1.从上述3——4——b中可以得知当<strong>引用类型改变</strong>时,编译器将<strong>无法识别原先的类型</strong>。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;//即引用仍为<strong>同一个引用</strong>,但是<strong>引用类型</strong>已经发生了<strong>改变</strong>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">3——4——b的修改方法:</span><br><span class="line">ArrayList&lt;Object&gt; myDogArrayList = new ArrayList&lt;Object&gt;();</span><br><span class="line">Dog aDog = new Dog();</span><br><span class="line">myDogArrayList.add(aDog);</span><br><span class="line">Object d = myDogArrayList.get(0);</span><br><span class="line">//这样则可以通过编译</span><br></pre></td></tr></table></figure></p>
<p>2.编译器是<strong>根据引用类型</strong>来<strong>判断</strong>有<strong>哪些方法”method”可以调用</strong>的,而<strong>不是根据</strong>Object<strong>确实的类型</strong>。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;//即便用户知道对象有这个功能,但是编译器只会把他当成<strong>一般的Object</strong>来看待。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;//即他只能调用<strong>Object内所含有的方法</strong>。编译器只管<strong>引用的类型</strong>,而<strong>不是对象的类型</strong>。<br></p>
<hr>

<h2 id="5-对象类型的装换"><a href="#5-对象类型的装换" class="headerlink" title="5.对象类型的装换"></a>5.对象类型的装换</h2><p>1.<strong>可以确认</strong>该变量为什么类型,并且<strong>希望调用该变量本身类型的方法</strong>。则可以将其<strong>声明</strong>为<strong>该变量本身类型</strong>。<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Object o = al.get(index);</span><br><span class="line">Dog d = (Dog) o ;</span><br><span class="line">//o本身类型为Dog的情况下</span><br><span class="line">//可以通过此方式进行类型转换</span><br><span class="line">d.roam();</span><br></pre></td></tr></table></figure></p>
<p>2.<strong>无法确认</strong>变量类型时,可以通过使用<strong>“instanceof”</strong>这个<strong>运算符</strong>来<strong>进行检查</strong>。如果类型转换错误,则在执行期将遇到<strong>“ClassCastException”异常</strong>并且<strong>终止</strong>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if(o instanceof Dog)&#123;</span><br><span class="line">    Dog d = (Dog) o ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>

<h2 id="6-接口"><a href="#6-接口" class="headerlink" title="6.接口"></a>6.接口</h2><p>1.接口的<strong>定义与实现</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">接口的定义:</span><br><span class="line">public interface Pet&#123;...&#125;</span><br><span class="line">//使用&quot;interface&quot;来代替&quot;class&quot;</span><br><span class="line"></span><br><span class="line">接口的实现:</span><br><span class="line">public class Dog extends Canine impements Pet&#123;...&#125;</span><br><span class="line">//使用&quot;implements&quot;这个关键词</span><br></pre></td></tr></table></figure></p>
<p>2.接口中的<strong>方法</strong><br><br>接口中<strong>全部的</strong>方法都是<strong>抽象的</strong>。<br><br>这样子类则必须实现此方法。可解决”致命方块”问题。<br><br>3.接口的<strong>意义</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;a.<strong>利于多态</strong>,接口具有<strong>无比的适用性</strong>。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//使用接口取代<strong>具体的子类</strong>或<strong>抽象的父类</strong>作为<strong>参数或返回类型</strong>。则可以<strong>传入任何</strong>有<strong>实现该接口</strong>的东西。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;b.继承<strong>超过一个以上</strong>的来源<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//使用接口的情况下,类有<strong>继承”extend”过某个父类</strong>并且<strong>实现其他的接口</strong>。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//同时<strong>其他的类</strong>也可以实现<strong>同一个接口</strong>。<br><br><br>4.<strong>不同继承树的类</strong>也可以实现<strong>相同的接口</strong><br><br>&nbsp;&nbsp;&nbsp;&nbsp;a.当把一个<strong>类</strong>作为<strong>多态类型</strong>运用时,<strong>相同的类型</strong>必定来自<strong>同一个继承树</strong>。并且为<strong>该多态类型的子类</strong>。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;b.当把<strong>接口</strong>作为<strong>多态类型</strong>运用时,对象就可以来自<strong>任何的地方</strong>了。<strong>唯一的条件是该对象必须是来自有实现此接口的类</strong>。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;c.类可以实现<strong>多个接口</strong><br><br><code>public class Dog extends Animal implements Pet, Saveable, paintable{...}</code><br><br><br>5.<strong>设计类</strong>、<strong>子类</strong>、<strong>抽象类</strong>、<strong>接口</strong>的判断<br><br>&nbsp;&nbsp;&nbsp;&nbsp;a.如果新的类无法对其他的类通过IS-A的测试时,就设计不继承其他类的类。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;b.只有在需要某类的特殊版本时,以覆盖或增加新的方法来继承现有的类。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;c.当你需要定义一群子类的模版,又不想让程序初始化此模版时,设计出抽象的类给。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;d.如果想要定义出类可以扮演的角色,使用接口。<br></p>
<hr>

<h2 id="7-调用父类的方法"><a href="#7-调用父类的方法" class="headerlink" title="7.调用父类的方法"></a>7.调用父类的方法</h2><p>当想要调用父类中的方法时,可以使用<strong>“super”</strong>这个关键词在<strong>子类中调用父类</strong>的方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">abstract class Report&#123;</span><br><span class="line">    void runReport()&#123;</span><br><span class="line">        //设置报告</span><br><span class="line">    &#125;</span><br><span class="line">    void printReport()&#123;</span><br><span class="line">        //输出</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class BuzzwordsReport extends Report&#123;</span><br><span class="line">    void runReport()&#123;</span><br><span class="line">        super.runReport();</span><br><span class="line">        //调用父类的方法</span><br><span class="line">        buzzwordCompliance();</span><br><span class="line">        printReport();</span><br><span class="line">    &#125;</span><br><span class="line">    void buzzwordCompliance()&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/570911275/570911275.github.io/2019/05/27/java-接口与抽象类小结/" data-id="cjycwilzv001z08tna2i8exkx" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java-基础/">java_基础</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2019/05/28/java-构造器与垃圾回收器之构造器小结/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          java_构造器与垃圾回收器之构造器小结
        
      </div>
    </a>
  
  
    <a href="/2019/05/26/java-继承与多态小结/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">java_继承与多态小结</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/javaEE-基础/">javaEE_基础</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java-基础/">java_基础</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/javaEE-基础/" style="font-size: 10px;">javaEE_基础</a> <a href="/tags/java-基础/" style="font-size: 20px;">java_基础</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">七月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">六月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">五月 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/07/18/JavaEE之JSP补充学习小结/">JavaEE之JSP补充学习小结</a>
          </li>
        
          <li>
            <a href="/2019/07/18/JavaEE之Session小结/">JavaEE之Session小结</a>
          </li>
        
          <li>
            <a href="/2019/07/18/JavaEE之JSP入门学习小结/">JavaEE之JSP入门学习小结</a>
          </li>
        
          <li>
            <a href="/2019/07/18/JavaEE之Cookie小结/">JavaEE之Cookie小结</a>
          </li>
        
          <li>
            <a href="/2019/07/18/JavaEE之会话技术概念小结/">JavaEE之会话技术概念小结</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>
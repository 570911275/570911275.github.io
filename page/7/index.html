<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="https://github.com/570911275/570911275.github.io/page/7/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://github.com/570911275/570911275.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-java-图形用户接口之中小结" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/06/03/java-图形用户接口之中小结/" class="article-date">
  <time datetime="2019-06-03T04:05:00.000Z" itemprop="datePublished">2019-06-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/06/03/java-图形用户接口之中小结/">java_图形用户接口之中小结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/570911275/570911275.github.io/2019/06/03/java-图形用户接口之中小结/" data-id="cjzdf8zl4002544tnc0iij0sw" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java-基础/">java_基础</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-java-图形用户接口之上小结" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/06/02/java-图形用户接口之上小结/" class="article-date">
  <time datetime="2019-06-02T14:05:01.000Z" itemprop="datePublished">2019-06-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/06/02/java-图形用户接口之上小结/">java_图形用户接口之上小结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/570911275/570911275.github.io/2019/06/02/java-图形用户接口之上小结/" data-id="cjzdf8zky002144tnw6qprnq6" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java-基础/">java_基础</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-java-异常处理小结" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/06/01/java-异常处理小结/" class="article-date">
  <time datetime="2019-06-01T15:02:12.000Z" itemprop="datePublished">2019-06-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/06/01/java-异常处理小结/">java_异常处理小结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="1-创建一个MIDI音乐播放器"><a href="#1-创建一个MIDI音乐播放器" class="headerlink" title="1.创建一个MIDI音乐播放器"></a>1.创建一个MIDI音乐播放器</h2><p>1.<strong>JavaSound</strong>包括<strong>MIDI</strong>和<strong>取样(sampled)</strong>。此处只讨论<strong>MIDI</strong>(Musical Instrument Digital Interface),也是<strong>不同电子发声装置共同的标准协议</strong>。<br><br><br>2.<strong>MIDI</strong>本身<strong>不带有声音</strong>，它是带有MIDI播放功能装置的<strong>指令</strong>。<strong>MIDI数据</strong>表示<strong>执行的动作</strong>(播放C调，以及音量的大小与长度等)，但是<strong>没有实际的声音</strong>。<br><br><br>3.Sequencer对象:会将<strong>所有的MIDI数据</strong>送到正确的<strong>装置</strong>上，由<strong>装置</strong>来产生<strong>音乐</strong>。(Sequencer扮演着<strong>搬运工</strong>的角色)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//Sequencer这个类位于&quot;javax.sound.midi&quot;这个包里面</span><br><span class="line">//获取Sequencer对象</span><br><span class="line"></span><br><span class="line">import javax.sound.midi.*;</span><br><span class="line">//调用包含Sequencer这个对象的包</span><br><span class="line"></span><br><span class="line">public class MusicTest1&#123;</span><br><span class="line">    </span><br><span class="line">    public void play()&#123;</span><br><span class="line">        Sequencer sequencer = MidiSystem.getSequencer();</span><br><span class="line">        //创建对象——将MIDI信息组合成乐曲</span><br><span class="line">        Systrm.out.println(&quot;We got a sequencer&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        MusicTest1 mt = new MusicTest1();</span><br><span class="line">        mt.play();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//此代码将无法通过编译</span><br><span class="line">//调用存在风险的方法(&quot;getSequencer()&quot;)编译器将报错</span><br></pre></td></tr></table></figure></p>
<hr>

<h2 id="2-有风险方法的确认与处理"><a href="#2-有风险方法的确认与处理" class="headerlink" title="2.有风险方法的确认与处理"></a>2.有风险方法的确认与处理</h2><p>1.有风险方法的确认<br><br>&nbsp;&nbsp;&nbsp;&nbsp;在API文件中查找该方法，查看该方法声明处是否有throws语句。若存在则为有风险方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//API中关于getSequencer()的声明</span><br><span class="line"></span><br><span class="line">public static sequencer getSequencer()</span><br><span class="line">                           throws MidiUnavailableException</span><br><span class="line">                           //此处说明getSequencer()可能会抛出MidiUnavailableException异常</span><br><span class="line">    Obtains the default sequencer.</span><br><span class="line">    </span><br><span class="line">    Returns:</span><br><span class="line">         the default sequencer</span><br><span class="line">    Throws:</span><br><span class="line">         MidiUnavailableException-if the sequencer is not available due to resource restrictions</span><br><span class="line">        //此处解释何时会遇到异常，在此情况下是因为资源受限，比如sequencer已经被占用了</span><br></pre></td></tr></table></figure></p>
<p>2.有风险方法的处理<br><br>&nbsp;&nbsp;&nbsp;&nbsp;a.<strong>try/catch块</strong>——处理一<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将<strong>有风险的方法</strong>包含在<strong>try/catch块</strong>中，编译器会知道用户了解所调用方法具有风险，并且已经准备好处理了它<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import javax.sound.midi.*;</span><br><span class="line"></span><br><span class="line">public class MusicTest1&#123;</span><br><span class="line">    </span><br><span class="line">    public void play()&#123;</span><br><span class="line">        try&#123;</span><br><span class="line">            Sequencer sequencer = MidiSystem.getSequencer();</span><br><span class="line">            Systrm.out.println(&quot;Successfully got a sequencer&quot;);</span><br><span class="line">        &#125;//将有风险的方法放入try块中</span><br><span class="line">        catch(MidiUnavailableException ex)&#123;</span><br><span class="line">            System.out.println(&quot;Bummer&quot;);</span><br><span class="line">        &#125;//catch块摆放异常状况的处理程序</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        MusicTest1 mt = new MusicTest1();</span><br><span class="line">        mt.play();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;b.<strong>catch</strong>内的异常<strong>参数</strong><br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>异常</strong>是一种<strong>Exception类型的对象</strong>,因为它是<strong>对象</strong>所以用户catch住的也是对象。在<strong>多态</strong>中,<strong>Exception类型的对象</strong>可以是<strong>任何它的子类</strong>的<strong>实例</strong>。<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">try&#123;</span><br><span class="line">    //正常的执行</span><br><span class="line">&#125;catch(Exception ex)&#123;</span><br><span class="line">    //此时catch的参数是Exception类型的ex引用变量</span><br><span class="line">    //就如同方法的参数声明一样</span><br><span class="line">    //尝试恢复(不同的异常有不同的恢复操作)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;c.<strong>throws</strong>抛出异常<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>方法</strong>可以<strong>抓住</strong>其他方法所<strong>抛出的异常</strong>。<strong>异常</strong>总是会<strong>丢回给调用方</strong>。会<strong>抛出异常的方法</strong>必须<strong>声明</strong>它有可能会这么做。<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">1.有风险的方法</span><br><span class="line">public void takeRisk() throws BadException&#123;</span><br><span class="line">//此处声明它会抛出BadException</span><br><span class="line">    if(abandonAllHope)&#123;</span><br><span class="line">        throw new BadException();</span><br><span class="line">        //创建出Exception对象并抛出</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">2.调用该方法的程序</span><br><span class="line">public void crossFingers()&#123;</span><br><span class="line">    try&#123;</span><br><span class="line">        anObject.takeRisk();</span><br><span class="line">    &#125;catch(BadException ex)&#123;</span><br><span class="line">        System.out.println(&quot;Aaargh!&quot;);</span><br><span class="line">        ex.printStackTrace();</span><br><span class="line">        //如果无法从异常中恢复</span><br><span class="line">        //至少要使用printStackTrace()来列出有用信息</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;d.<strong>声明(duckingi闪避掉)</strong>——处理二<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;除了try/catch块的处理方法，还可以将<strong>此方法duck掉以让调用此方法的程序来catch该异常</strong>。(只需表示会<strong>在throw此异常</strong>即可)<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;方法<strong>抛出异常</strong>时，<strong>方法</strong>会从<strong>栈</strong>上立刻<strong>被取出</strong>，而<strong>异常</strong>会<strong>再度丢给栈</strong>上的<strong>方法</strong>，如果<strong>调用方</strong>是个<strong>ducker</strong>，则此<strong>ducker</strong>也会被<strong>从栈上取出</strong>，<strong>异常</strong>再度<strong>抛给此时栈</strong>上的<strong>方法</strong>。<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public void foo() throws ReallyBadException&#123;</span><br><span class="line">//并没有try/catch块来处理有风险的方法，因此该方法本身就是有风险的。</span><br><span class="line">    //调用有风险的方法</span><br><span class="line">    laundry.foLaundry();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;e.一直ducking<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ducking只是在踢皮球，并<strong>没有解决处理</strong>实际问题。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当<strong>main()也duck掉异常</strong>，java虚拟机将<strong>死机</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class Washer&#123;</span><br><span class="line">    Laundry laundry = new Laundry();</span><br><span class="line">    </span><br><span class="line">    public void foo() throws ClsthingExcetion&#123;</span><br><span class="line">        laundry.doLaundry();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static void main(String[] args) throw ClothingException&#123;</span><br><span class="line">        Washer a = new Washer();</span><br><span class="line">        a.foo();</span><br><span class="line">        //此时应使用try/catch块将其包起来</span><br><span class="line">    &#125;</span><br><span class="line">    //main()都duck掉，此时java虚拟机将死机</span><br><span class="line">&#125;</span><br><span class="line">//在foo()以及main()中两者的躲避异常，因此没有人来处理。</span><br><span class="line">//但是有duck掉，所以可以通过编译</span><br></pre></td></tr></table></figure></p>
<hr>

<h2 id="3-受检查与不受检查的异常"><a href="#3-受检查与不受检查的异常" class="headerlink" title="3.受检查与不受检查的异常"></a>3.受检查与不受检查的异常</h2><p>1.编译器会核对每件事，除了<strong>RuntimeException</strong>之外，编译器需保证以下2点<br><br>&nbsp;&nbsp;&nbsp;&nbsp;a.如果用户有<strong>抛出异常</strong>，则<strong>一定</strong>要<strong>使用throw来声明</strong>这件事。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;b.如果用户<strong>调用会抛出异常的方法</strong>，则用户必须<strong>确认异常的可能性</strong>。1.讲<strong>调用</strong>包在<strong>try/catch</strong>块中。2.<strong>ducking</strong>掉该<strong>异常</strong><br><br>2.<strong>RuntimeException</strong>被称为<strong>不检查异常</strong>，大部分的的RuntimeException都是因为<strong>程序逻辑的问题</strong><br><br>&nbsp;&nbsp;&nbsp;&nbsp;a.任何<strong>继承过RuntimeException的类</strong>都<strong>不会受到编译器</strong>关于是否声明它会抛出RuntimeException的<strong>检查</strong></p>
<hr>

<h2 id="4-finally部分"><a href="#4-finally部分" class="headerlink" title="4.finally部分"></a>4.finally部分</h2><p>1.finally块是用来存放不管有没有异常的要执行的程序<br><br>&nbsp;&nbsp;&nbsp;&nbsp;a.<strong>finally块</strong>可以将所有<strong>重要的清理程序</strong>代码<strong>集中</strong>在一起，而不需要复制多份<br><br>&nbsp;&nbsp;&nbsp;&nbsp;b.如果<strong>try块失败</strong>了，抛出异常，流程会<strong>转移到catch块</strong>。当<strong>catch块完成</strong>时，会<strong>执行finally块</strong>。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;如果<strong>try块成功</strong>了，流程会<strong>跳过catch块</strong>并移动到finally块，<strong>执行finally块</strong>。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;如果try/catch块中有<strong>return指令</strong>，finally还是会执行，<strong>流程会跳到finally块</strong>，执行完finally块后<strong>再回到return指令</strong>。<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">try&#123;</span><br><span class="line">    turnOvenOn();</span><br><span class="line">    x.bake();</span><br><span class="line">&#125;catch(BakingException ex)&#123;</span><br><span class="line">    ex.printSackTrace();</span><br><span class="line">&#125;finally&#123;</span><br><span class="line">    turnOvenOff();</span><br><span class="line">    //finally必须被执行</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>

<h2 id="5-多重异常与多态的异常"><a href="#5-多重异常与多态的异常" class="headerlink" title="5.多重异常与多态的异常"></a>5.多重异常与多态的异常</h2><p>1.<strong>多重异常</strong><br><br>&nbsp;&nbsp;&nbsp;&nbsp;a.方法可以抛出<strong>多个异常</strong>，但该方法的声明必须要有含有<strong>全部的检查异常</strong>(若<strong>两个或两个以上的异常</strong>有<strong>共同的父类</strong>时，则可以<strong>只声明该父类</strong>)。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;b.编译器会检查用户是否处理<strong>所有可能的异常</strong>。将<strong>个别的catch块</strong>逐个放在try块下执行。(某些情况下catch的出现顺序具有影响)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">//声明所有可能的异常类型</span><br><span class="line">public class Laundry&#123;</span><br><span class="line">    public void doLaundry() throws PantsException, LingerieException&#123;</span><br><span class="line">        //有两个抛出异常的程序代码</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//两个catch跟在try块下</span><br><span class="line">public class Foo&#123;</span><br><span class="line">    public void go()&#123;</span><br><span class="line">        Laundry laundry = new Laundry();</span><br><span class="line">        </span><br><span class="line">        try&#123;</span><br><span class="line">            laundry.doLaundry();</span><br><span class="line">        &#125;catch(PantsException pex)&#123;</span><br><span class="line">            //抛出的是PantsException，则跳到此catch块</span><br><span class="line">            //恢复程序</span><br><span class="line">        &#125;catch(LingerieException lex)&#123;</span><br><span class="line">            //抛出的是LingerieException，则跳到此catch块</span><br><span class="line">            //恢复程序</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>2.<strong>多态的异常</strong><br><br>&nbsp;&nbsp;&nbsp;&nbsp;a.<strong>异常</strong>是<strong>对象</strong>，除了可以被抛出之外，并没有什么特别的。正如所有对象一样，<strong>异常也可以以多态的形式来引用</strong>。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;b.这样可以<strong>不必</strong>明确的声明<strong>每个可能抛出的异常</strong>，可以<strong>只声明父类</strong>即可。对于catch块来说，也可以不用对没个可能的异常来作处理，只要有一个或者少数几个catch就可以处理所有异常。<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">//以异常的父型来声明会抛出的异常</span><br><span class="line">public void doLaundry() throws ClothingException&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//以所抛出的异常父型来catch异常</span><br><span class="line">try&#123;</span><br><span class="line">    laundry.doLaundry();</span><br><span class="line">&#125;catch(ClothingException cex)&#123;</span><br><span class="line">    //可以catch任何ClothingException的子类</span><br><span class="line">    //解决方法</span><br><span class="line">&#125;</span><br><span class="line">try&#123;</span><br><span class="line">    laundry.doLaundry();</span><br><span class="line">&#125;catch(ShirtException sex)&#123;</span><br><span class="line">    //只能catch到ShirtException及其子类</span><br><span class="line">    //解决方法</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//可以用super来处理所有异常，并不代表这就应该这么做</span><br><span class="line">//假如将异常处理程序写成只有一个catch块以父型的Exception来捕获，可以抓到任何可能被抛出的异常(此时会无法分清是哪里出错)</span><br><span class="line">try&#123;</span><br><span class="line">    laundry.doLaundry();</span><br><span class="line">&#125;catch(Exception ex)&#123;</span><br><span class="line">    //解决方法</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//为每个需要单独处理的异常编写不同的catch块</span><br><span class="line">try&#123;</span><br><span class="line">    laundry.foLaundry();</span><br><span class="line">&#125;catch(TeeShirtException tex)&#123;</span><br><span class="line">    //恢复此问题</span><br><span class="line">    //该问题需特殊处理</span><br><span class="line">&#125;catch(LingerieException lex)&#123;</span><br><span class="line">    //恢复此问题</span><br><span class="line">    //此问题需特殊处理(同TeeShirtException不同)</span><br><span class="line">&#125;catch(ClothingException cex)&#123;</span><br><span class="line">    //恢复此问题</span><br><span class="line">    //同样的处理方法皆集中于此</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>

<h2 id="6-catch块的顺序"><a href="#6-catch块的顺序" class="headerlink" title="6.catch块的顺序"></a>6.catch块的顺序</h2><p>1.在继承树上<strong>层次越高</strong>，则它的<strong>范围就越广</strong>，<strong>从上往下</strong>沿着继承层次走，异常类的就会越来越有特定的取向，其<strong>catch的范围就越来越小</strong>。<br><br><br>2.当有<strong>多个catch块</strong>时，要从<strong>小范围排到大范围</strong><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//范围只有TeeShirtException</span><br><span class="line">catch(TeeShirtException tex)</span><br><span class="line"></span><br><span class="line">//范围只有ShirtException</span><br><span class="line">catch(ShirtException sex)</span><br><span class="line"></span><br><span class="line">//上述两者在继承层次上为同一层次，所以可以调换位置</span><br><span class="line"></span><br><span class="line">//范围最大，包含所有ClothingException</span><br><span class="line">catch(ClothingException ces)</span><br></pre></td></tr></table></figure></p>
<p>3.<strong>大范围的catch不可以</strong>放在<strong>小范围</strong>的上面<br>&nbsp;&nbsp;&nbsp;&nbsp;a.java虚拟机之后<strong>从头开始往下</strong>找第一个符合范围的异常处理块。如果<strong>第一个catch</strong>就是<strong>最大范围</strong>的，则编译器将知道，其余的都没有用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">try&#123;</span><br><span class="line">    laundry.doLaundry();</span><br><span class="line">&#125;catch(ClothingException ces)&#123;</span><br><span class="line">    //恢复此问题</span><br><span class="line">&#125;catch(ShirtException sex)&#123;</span><br><span class="line">    //恢复此问题</span><br><span class="line">&#125;catch(TeeShirtException tex)&#123;</span><br><span class="line">    //恢复此问题</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>

<h2 id="7-创建一个MIDI音乐播放器之续"><a href="#7-创建一个MIDI音乐播放器之续" class="headerlink" title="7.创建一个MIDI音乐播放器之续"></a>7.创建一个MIDI音乐播放器之续</h2><p>1.JavaSound的工作原理<br>&nbsp;&nbsp;&nbsp;&nbsp;a.<strong>4项</strong>必备的<strong>条件</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">1.发声的装置</span><br><span class="line">Sequencer(如同CD播放机)</span><br><span class="line">    |</span><br><span class="line">    |(plays)</span><br><span class="line">    V</span><br><span class="line">2.要演奏的乐曲</span><br><span class="line">Sequence(如同单曲CD)</span><br><span class="line">    |</span><br><span class="line">    |(has a)</span><br><span class="line">    V</span><br><span class="line">3.带有乐曲的信息记录</span><br><span class="line">Track(如同是单曲CD上唯一歌曲的信息)</span><br><span class="line">    |</span><br><span class="line">    |(holds)</span><br><span class="line">    V</span><br><span class="line">4.乐曲的音符等信息</span><br><span class="line">MidiEvent(如同是乐谱上某一个音符记号)</span><br></pre></td></tr></table></figure></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;b.<strong>5个步骤</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">1.取得Sequenccer并将它打开</span><br><span class="line">Sequencer player =MidiSystem.getSequencer();</span><br><span class="line">player.open();</span><br><span class="line"></span><br><span class="line">2.创建新的Sequence</span><br><span class="line">Sequence seq = new Sequence(timing,4);</span><br><span class="line"></span><br><span class="line">3.从Sequence中创建新的Track</span><br><span class="line">Track t = seq.createTrack();</span><br><span class="line"></span><br><span class="line">4.填入MidiEvent并让Sequencer播放</span><br><span class="line">t.add(myMidiEvent1);</span><br><span class="line">player.setSequence(seq);</span><br><span class="line"></span><br><span class="line">5.按下Play键</span><br><span class="line">player.start();</span><br></pre></td></tr></table></figure></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;c.制作<strong>MidiEvent</strong>(乐谱信息)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">1.创建Message</span><br><span class="line">ShortMessage a = new ShortMessage();</span><br><span class="line"></span><br><span class="line">2.置入指令</span><br><span class="line">a.setMessage(144,1,44,100);</span><br><span class="line">//这代表发出44音符</span><br><span class="line"></span><br><span class="line">3.用Message创建MidiEvent</span><br><span class="line">MidiEvent noteOn = new MidiEvent(a,1);</span><br><span class="line">//在第一拍启动a这个Message</span><br><span class="line"></span><br><span class="line">4.将MidiEvent加入Track中</span><br><span class="line">track.add(noteOn);</span><br><span class="line">//Track中带有全部的MidiEvent对象，Sequencer会根据实际实际组织它们，然后Sequencer会根据此顺序来播放</span><br></pre></td></tr></table></figure></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;d.第一个<strong>声音播放程序</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">import javax.sound.midi.*;</span><br><span class="line">//引入包</span><br><span class="line"></span><br><span class="line">public class MiniMiniMusicApp&#123;</span><br><span class="line">    </span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        MiniMiniMusicApp mini = new MiniMusicApp();</span><br><span class="line">        mini.play();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void play()&#123;</span><br><span class="line">        try&#123;</span><br><span class="line">            Sequencer player = MidiSystem.getSequencer();</span><br><span class="line">            //创建Sequencer对象</span><br><span class="line">            player.open();</span><br><span class="line">            //将Sequencer打开</span><br><span class="line">            </span><br><span class="line">            Sequence seq = new Sequence(Sequence.PPQ,4);</span><br><span class="line">            //暂时无需理会参数意义</span><br><span class="line">            </span><br><span class="line">            Track track = seq.createTrack();</span><br><span class="line">            //创建Track</span><br><span class="line">            </span><br><span class="line">            ShortMessage a = new ShortMessage();</span><br><span class="line">            a.setMessage(144,1,44,100);</span><br><span class="line">            MidiEvent noteOn = new MidiEvent(a,1);</span><br><span class="line">            teack.add(noteOn);</span><br><span class="line">            //对Track加入MidiEvent，此为开始的MidiEvent</span><br><span class="line">            </span><br><span class="line">            ShortMessage b = new ShortMessage();</span><br><span class="line">            a.setMessage(128,1,44,100);</span><br><span class="line">            MidiEvent noteOn = new MidiEvent(b,16);</span><br><span class="line">            teack.add(noteOff);</span><br><span class="line">            //对Track加入MidiEvent，此为结束的MidiEvent</span><br><span class="line">            </span><br><span class="line">            player.setSequence(seq);</span><br><span class="line">            //将Sequence送到Sequencer</span><br><span class="line">            </span><br><span class="line">            player.start();</span><br><span class="line">            //开始播放</span><br><span class="line">        &#125;catch(Exception ex)&#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>2.<strong>信息的格式</strong><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">第一个参数是信息类型，剩下的3个要看信息类型来定</span><br><span class="line">a.setMessage(144,1,44,100);</span><br><span class="line">//从左往右分别标号1-4</span><br><span class="line">1.信息类型：144代表打开；128代表关闭</span><br><span class="line"></span><br><span class="line">2.频道：每个频道代表不同的演奏则。例如1号频道是吉他，2号频道是Bass</span><br><span class="line"></span><br><span class="line">3.要发出的音符：0~127代表不同的音高</span><br><span class="line"></span><br><span class="line">4.音道：用多大的音道按下;0几乎听不到，100差不多</span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/570911275/570911275.github.io/2019/06/01/java-异常处理小结/" data-id="cjzdf8zng003q44tnc7lbqgj2" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java-基础/">java_基础</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-java-数字与静态之下小结" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/05/31/java-数字与静态之下小结/" class="article-date">
  <time datetime="2019-05-31T14:52:33.000Z" itemprop="datePublished">2019-05-31</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/05/31/java-数字与静态之下小结/">java_数字与静态之下小结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="1-静态方法"><a href="#1-静态方法" class="headerlink" title="1.静态方法"></a>1.静态方法</h2><p>4.静态<strong>final</strong>常数<br><br>&nbsp;&nbsp;&nbsp;&nbsp;a.<strong>静态</strong>的<strong>final变量</strong>是<strong>常数</strong><br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//被标记为final的变量代表它一旦<strong>被初始化之后就不会改动了</strong>。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//命名惯例:<strong>全部都是大写字母以下划线分隔</strong><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static final double PI = 3.1415923</span><br><span class="line">关键词:</span><br><span class="line">public: 可供各方读取</span><br><span class="line">static: 静态,不需要Math的实例</span><br><span class="line">final : 不变值,因为圆周率是不变的</span><br></pre></td></tr></table></figure></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;b.静态<strong>final</strong>变量的<strong>初始化</strong><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1.声明的时候</span><br><span class="line">public class Foo&#123;</span><br><span class="line">    public static final int FOO_X = 25;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">2.在静态初始化程序中</span><br><span class="line">public class Bar&#123;</span><br><span class="line">    public static final double BAR_SIGN;</span><br><span class="line">    </span><br><span class="line">    static&#123;</span><br><span class="line">        BAR_SIGN = (double) Math.random();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;c.final的<strong>方法与类</strong><br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//final的<strong>方法</strong>代表<strong>不能覆盖掉该方法</strong><br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//final的<strong>类</strong>代表<strong>不能继承该类(即创建他的子类)</strong><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1.final的方法</span><br><span class="line">class Poof&#123;</span><br><span class="line">    final void calcWhuffie()&#123;</span><br><span class="line">        //该方法无法被覆盖</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">2.final的类</span><br><span class="line">final class MyMostPerfectClass&#123;</span><br><span class="line">    //不能被继承</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>

<h2 id="3-包装类型的方法-autoboxing"><a href="#3-包装类型的方法-autoboxing" class="headerlink" title="3.包装类型的方法(autoboxing)"></a>3.包装类型的方法(autoboxing)<br></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;a.<strong>primitive主数据类型</strong>的<strong>包装</strong>用的类<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;注意<strong>包装的类的名字不是</strong>完全和<strong>primitive主数据类型</strong>的名称<strong>相同</strong>。<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Boolean 布尔        Character 字符</span><br><span class="line">Byte    字节        Short     短整形</span><br><span class="line">Integer 整形        Long      长整形</span><br><span class="line">Float   单精度浮点  Double    双精度浮点</span><br><span class="line"></span><br><span class="line">包装值</span><br><span class="line">int i = 288;</span><br><span class="line">Integer iWrap = new Integer(i);</span><br><span class="line"></span><br><span class="line">解开包装</span><br><span class="line">int unWrapped - iWrap.intValue();</span><br></pre></td></tr></table></figure></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;b.包装的<strong>作用</strong><br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>autoboxing</strong>功能能够<strong>自动</strong>地将<strong>primitive</strong>主数据类型<strong>转换成包装过的对象</strong><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public void doNumsNewWay()&#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; listOfNumbers = new ArrayList&lt;Integer&gt;();</span><br><span class="line">    //创建Integer类型的ArrayList</span><br><span class="line">    listOfNumbers.add(3);</span><br><span class="line">    //直接加3</span><br><span class="line">    //虽然ArrayList没有add(int)这样的方法,但是编译器会自动帮用户包装</span><br><span class="line">    int num = listOfNumbers.get(0);</span><br><span class="line">    //编译器会自动接口Integer对象的包装,因此可以直接赋值给&quot;num&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;c.包装的<strong>运用</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">1.方法的参数</span><br><span class="line">//发给参数是某种包装类型,则可以传入相对应的primitive主数据类型。</span><br><span class="line">void takeNumber(Integer i)&#123;</span><br><span class="line">    //Integer对象与int数据类型皆可以作为参数传入</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">2.返回值</span><br><span class="line">//如果method声明返回某种primitive主数据类型</span><br><span class="line">//也可以返回兼容的primitive主数据类型或者该primitive主数据类型的包装类型</span><br><span class="line">int fiveNumber()&#123;</span><br><span class="line">    ...</span><br><span class="line">    return x;</span><br><span class="line">    //Integer对象和int数据类型皆可以作为返回值返回</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">3.boolean表达式</span><br><span class="line">//任何预期boolean值的位置都可以用求出boolean的表达式来代替</span><br><span class="line">//例如Boolean包装类型的引用或者&quot;4&gt;2&quot;</span><br><span class="line">if(bool)&#123;</span><br><span class="line">    System.out.println(&quot;true&quot;);</span><br><span class="line">    //boolean对象与boolean数据皆可以传入</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">4.数值运算</span><br><span class="line">//可以在使用primitive主数据类型作为运算子的操作中用包装类型类替换</span><br><span class="line">//这意味着可以对Integer的对象作递增运算</span><br><span class="line">Integer i = new Integer(42);</span><br><span class="line">i++;</span><br><span class="line">或者</span><br><span class="line">Integer j = new Integer(25);</span><br><span class="line">Integer k = j+3;</span><br><span class="line"></span><br><span class="line">5.赋值</span><br><span class="line">//可以将包装类型或primitive主数据类型赋给声明给相对应的包装或primitive主数据类型</span><br><span class="line">Double d = x;</span><br><span class="line">//Integer对象和int数据皆可作为&quot;x&quot;赋值给&quot;d&quot;</span><br></pre></td></tr></table></figure></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;4.包装的静态方法<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a.将<strong>String</strong>转换成<strong>primitive</strong>主数据类型<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String s = &quot;2&quot;;</span><br><span class="line">int    x = Integer.parseInt(s);</span><br><span class="line">double d = Double.parseDouble(&quot;40.24&quot;);</span><br><span class="line">//boolean不一样，并没有BooleanparseBpplean()</span><br><span class="line">boolean b = new Boolean(&quot;true&quot;).booleanValue();</span><br><span class="line">//Boolean的构造函数可以取用String来创建对象</span><br></pre></td></tr></table></figure></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b.将<strong>primitive</strong>主数据类型转换成<strong>String</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.将数字接上现有的String</span><br><span class="line">double b = 42.5;</span><br><span class="line">String doubleString = &quot; &quot;+d;</span><br><span class="line">2.使用静态方法</span><br><span class="line">double b = 42.5;</span><br><span class="line">String doubleString = Doouble.toString(d);</span><br></pre></td></tr></table></figure></p>
<hr>

<h2 id="2-格式化"><a href="#2-格式化" class="headerlink" title="2.格式化"></a>2.格式化</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;1.<strong>格式化</strong>的说明<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;格式化说明最多会有<strong>5个部分</strong>(<strong>不包括”%”符号</strong>)，下面”<strong>[]</strong>“中的内容都是<strong>可选项目</strong>，因此<strong>只有%与type是必要</strong>的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">%[argument number] [flags] [width] [.precision] type</span><br><span class="line">argument number:如果格式化的参数超过一个以上，可以在此处指定是哪一个</span><br><span class="line">flags:特定类型的特定选项，例如数字要加逗号或正负号</span><br><span class="line">width:最小的字符数，(这不是总数)输出可以超过此宽度，若不足则主动补0</span><br><span class="line">.precision:精确度</span><br></pre></td></tr></table></figure></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;2.<strong>日期</strong>的格式<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;数值与日期时间格式化的区别在于<strong>日期格式的类型是用”t”开头</strong>的<strong>两个字符</strong>表示<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">完整的日期与时间:%tc</span><br><span class="line">String.format(&quot;%tc&quot;,new Date());</span><br><span class="line"></span><br><span class="line">只有时间:%tr</span><br><span class="line">String.format(&quot;%tr&quot;,new Date());</span><br><span class="line"></span><br><span class="line">周、月、日:%tA %tB %td</span><br><span class="line">Date today = new Date();</span><br><span class="line">String.format(&quot;tA,%tB %td&quot;,today,today,today);</span><br><span class="line">//此处的&quot;,&quot;为直接输出的</span><br><span class="line">//输出为 Sunday, November 28</span><br><span class="line">//此种输入需要将Date对象传入3次</span><br><span class="line"></span><br><span class="line">同上但是使用&quot;&lt;&quot;，此时无需重复传参</span><br><span class="line">Date today = new Date();</span><br><span class="line">String.format(&quot;tA,%&lt;tB %&lt;td&quot;,today);</span><br><span class="line">//&quot;&lt;&quot;这个符号是告知程序重复利用之前用过的参数</span><br></pre></td></tr></table></figure></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;3.操作日期<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在2中使用<strong>java.util.Date</strong>来<strong>查询日期</strong>，现在使用<strong>java.util.Calendar</strong>来<strong>操作日期</strong>。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因为<strong>Calendar</strong>是一个<strong>抽象的类</strong>，使用只能用到他的<strong>具体子类</strong>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">取得继承过Calendar的对象:</span><br><span class="line">1.Calendar cal = new Calendar();</span><br><span class="line">//无法通过编译</span><br><span class="line"></span><br><span class="line">2.Calendar cal = Calendar.getInstance();</span><br><span class="line">//通过调用静态方法</span><br></pre></td></tr></table></figure></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;运用<strong>Calendar对象</strong>的几个概念<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a.<strong>字段会保存状态</strong>——Calendar对象使用许多<strong>字段</strong>来表示<strong>日期和时间</strong>。(用户可以读取和设定他的year或month字段)<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b.<strong>日期和时间可以运算</strong>——Calendar的方法可以使得用户对<strong>不同的字段</strong>做<strong>加法或减法的运算</strong>。(用户可以对month字段加一个月或者对year字段减去3年)<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c.<strong>日期和时间可以用millisecond来表示</strong>——Calendar可以<strong>将日期</strong>转换成<strong>微秒</strong>的表示法，或将<strong>微秒</strong>转换成<strong>日期</strong>。(用户可以<strong>执行精确的相对时间计算</strong>)<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Calendar c = Calendar.getInstance();</span><br><span class="line"></span><br><span class="line">c.set(2004,1,7,15,40);</span><br><span class="line">//蛇精睡觉为2004年1月7日15:40</span><br><span class="line"></span><br><span class="line">long day1 = c.getTimeInMillis();</span><br><span class="line">//讲时间转换成用millisecond微秒来表示</span><br><span class="line"></span><br><span class="line">day1 += 1000*60*60;</span><br><span class="line">//将时间将上一个小时</span><br><span class="line"></span><br><span class="line">c.setTimeInMillis(day1);</span><br><span class="line">//将微秒转换成日期</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;new hour&quot; + c.get(c.HOUR_OF_DAY));</span><br><span class="line">//打印出时间</span><br><span class="line"></span><br><span class="line">c.add(c.DATE, 35);</span><br><span class="line">//加上35天，所以此时的月份变为了2月</span><br><span class="line"></span><br><span class="line">c.roll(c.DATE, 35);</span><br><span class="line">//滚动35天，此时只有日期改变，月份不改变</span><br><span class="line"></span><br><span class="line">c.set(c.DATE, 1);</span><br><span class="line">//直接设定DATE的值</span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/570911275/570911275.github.io/2019/05/31/java-数字与静态之下小结/" data-id="cjzdf8zla002944tnuezzr8li" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java-基础/">java_基础</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-java-数字与静态之上小结" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/05/30/java-数字与静态之上小结/" class="article-date">
  <time datetime="2019-05-30T14:45:41.000Z" itemprop="datePublished">2019-05-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/05/30/java-数字与静态之上小结/">java_数字与静态之上小结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="1-Math的方法"><a href="#1-Math的方法" class="headerlink" title="1.Math的方法"></a>1.Math的方法</h2><p>1.Math这个类中<strong>所有的方法</strong>都不需要实例变量值。因为这些方法都是<strong>静态</strong>的,所有<strong>无需Math的实例</strong>。只会用到他的<strong>类</strong>本身。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int x = Math.round(42.2);</span><br><span class="line">int y = Math.min(56,12);</span><br></pre></td></tr></table></figure></p>
<p>2.Math的方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Math.random()</span><br><span class="line">//返回介于0.0~1.0之间的双精度浮点数</span><br><span class="line">double r1 = Math.random();</span><br><span class="line">int r2 = (int) (Math.random() * 5);</span><br><span class="line"></span><br><span class="line">Math.abs()</span><br><span class="line">//返回双精度浮点类型参数的绝对值。</span><br><span class="line">//这个方法有覆盖的版本,传入整数会返回整数,传入双精度浮点数会返回双精度浮点数。</span><br><span class="line">int x = Math.abs(-24); //返回24</span><br><span class="line">double d = Math.abs(240.25); //返回240.25</span><br><span class="line"></span><br><span class="line">Math.min()</span><br><span class="line">//返回两个精度中较小的那一个</span><br><span class="line">//这个有int,long,float或double的覆盖版本</span><br><span class="line">int x = Math.min(24,240); //返回24</span><br><span class="line">double y = Math.min(982.25,654.32); //返回982.25</span><br><span class="line"></span><br><span class="line">Math.max()</span><br><span class="line">//返回两个精度中较大的一个</span><br><span class="line">//同Math.min()一致</span><br></pre></td></tr></table></figure></p>
<hr>

<h2 id="2-静态方法"><a href="#2-静态方法" class="headerlink" title="2.静态方法"></a>2.静态方法</h2><p>1.非静态方法与静态方法的差别<br><br>&nbsp;&nbsp;&nbsp;&nbsp;a.”<strong>static</strong>“这个关键词可以标记出<strong>不需类实例</strong>的方法。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;b.一个静态方法代表说<strong>一种不依靠实例变量</strong>也就<strong>不需要对象</strong>的行为。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//静态方法中<strong>绝对没有对象</strong>。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;c.区别:<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;静态方法:<strong>不依靠实例变量</strong><br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;非静态方法:<strong>实例变量</strong>的值会<strong>影响到方法</strong>的行为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">非静态方法:</span><br><span class="line">public class Song&#123;</span><br><span class="line">    String title;</span><br><span class="line">    //实例变量将影响方法的行为</span><br><span class="line">    public Song(String t)&#123;</span><br><span class="line">        title = t;</span><br><span class="line">    &#125;</span><br><span class="line">    public void play()&#123;</span><br><span class="line">        SoundPlayer player = new SoundPlayer();</span><br><span class="line">        player.playSound(title);</span><br><span class="line">        //&quot;title&quot;的值会决定&quot;play()&quot;的行为</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">静态方法:</span><br><span class="line">public static int min(int a,int b)&#123;</span><br><span class="line">    //返回a与b之间较小的值</span><br><span class="line">    //没有实例变量</span><br><span class="line">    //没有对象</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>2.静态方法的调用<br><br>&nbsp;&nbsp;&nbsp;&nbsp;a.以<strong>类的名称</strong>调用<strong>静态的方法</strong><br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Math.min(86,88);</code><br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//虽然可以用引用变量的名称调用静态方法但是<strong>不建议</strong>使用。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;b.以<strong>引用变量的名称</strong>调用<strong>非静态的方法</strong><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Song t2 = new Song();</span><br><span class="line">t2.play();</span><br></pre></td></tr></table></figure></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;c.静态方法<strong>不能调用</strong>非静态的变量:<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>静态方法</strong>是在<strong>无关特定特定类</strong>的实例情况下执行的。甚至<strong>不会有该类的实例</strong>出现。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因为<strong>静态方法是通过类的名称</strong>调用的,所以静态方法<strong>无法引用</strong>到该类的<strong>任何实例变量</strong>。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;所以静态方法<strong>无法识别</strong>可以使用哪一个实例变量。<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class Duck&#123;</span><br><span class="line">    private int size;</span><br><span class="line">    </span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        System.out.println(&quot;Size of duck is &quot; + size);</span><br><span class="line">        //此刻静态方法&quot;main()&quot;无法得知堆上是否有Duck</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void setSize(int s)&#123;</span><br><span class="line">        size = s;</span><br><span class="line">    &#125;</span><br><span class="line">    public int getSize()&#123;</span><br><span class="line">        return size;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;d.静态方法<strong>不能调用</strong>非静态方法<br><br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;非静态方法同上是<strong>以实例变量的状态</strong>来影响该<strong>方法</strong>的行为。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;同上方c同理<strong>静态方法无法识别</strong>是哪一个实例变量。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//即便非静态方法中<strong>无使用到实例变量</strong>也<strong>无法</strong>通过编译。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//因为<strong>无法确保</strong>之后是否会将非静态方法<strong>改为需要</strong>实例变量的。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//亦或者是无法保证不发生<strong>子类去覆盖</strong>这个方法成有用到实例变量的版本。<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class Duck&#123;</span><br><span class="line">    private int size;</span><br><span class="line">    </span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        System.out.println(&quot;Size of duck is &quot; + getSize());</span><br><span class="line">        //同c一样此刻静态方法&quot;main()&quot;无法识别需要的是哪一个实例变量</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void setSize(int s)&#123;</span><br><span class="line">        size = s;</span><br><span class="line">    &#125;</span><br><span class="line">    public int getSize()&#123;</span><br><span class="line">        return size;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>3.静态变量<br><br>静态变量对<strong>所有的实例</strong>来说都相同。<br><br>静态变量是<strong>共享的</strong>。<br><br><strong>同一个类</strong>所有的实例变量<strong>共享一份静态变量</strong>。<br><br>实例变量:每个<strong>实例</strong>一个。<br><br>静态变量:每个<strong>类</strong>一个。<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">在构造函数中增加静态变量</span><br><span class="line">class Duck&#123;</span><br><span class="line">    int duckCount = 0;</span><br><span class="line">    public Duck()&#123;</span><br><span class="line">        duckCount++;</span><br><span class="line">        //这无法在创建Duck对象的时候执行递增</span><br><span class="line">        //因为duckCount是一个实例变量</span><br><span class="line">        //所以每个Duck在初始化的时候duckCount的值都是0</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Duck&#123;</span><br><span class="line">    private int size; </span><br><span class="line">    private static int duckCount = 0;</span><br><span class="line">    //静态变量&quot;duckCount&quot;只有在类第一次载入的时候被初始化</span><br><span class="line">    </span><br><span class="line">    public Duck()&#123;</span><br><span class="line">        duckCount++;</span><br><span class="line">        //每当构造函数执行的时候</span><br><span class="line">        //这个值就会递增</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void setSize(int s)&#123;</span><br><span class="line">        size = s;</span><br><span class="line">    &#125;</span><br><span class="line">    public int getSize()&#123;</span><br><span class="line">        return size;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>静态变量会在该类的<strong>任何对象</strong>创建之前就完成初始化。<br>静态变量会在该类<strong>任何静态方法</strong>执行之前就初始化。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Player&#123;</span><br><span class="line">    static int palyerCount = 0;</span><br><span class="line">    private String name;</span><br><span class="line">    public Player(String n)&#123;</span><br><span class="line">        name = n;</span><br><span class="line">        playerCount++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public calss PlayerTestDrive&#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        System.out.println(Player.playerCount);</span><br><span class="line">        Player one = new Player(&quot;Tiger Woods&quot;);</span><br><span class="line">        Systrm.out.println(Player.playerCount);</span><br><span class="line">        //静态变量通过类的名称来存取</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出为:</span><br><span class="line">0    //实例创建之前</span><br><span class="line">1    //对象创建之后</span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/570911275/570911275.github.io/2019/05/30/java-数字与静态之上小结/" data-id="cjzdf8zl7002744tn1xryw9oy" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java-基础/">java_基础</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-java-构造器与垃圾回收器之垃圾回收器小结" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/05/29/java-构造器与垃圾回收器之垃圾回收器小结/" class="article-date">
  <time datetime="2019-05-29T15:34:46.000Z" itemprop="datePublished">2019-05-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/05/29/java-构造器与垃圾回收器之垃圾回收器小结/">java_构造器与垃圾回收器之垃圾回收器小结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h2><p>1.引用永久性的离开他的返回<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class StackRef&#123;</span><br><span class="line">    public void foof()&#123;</span><br><span class="line">    //foof()处于栈上,无声明变量</span><br><span class="line">        barf();</span><br><span class="line">    //barf()处于栈上</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void barf()&#123;</span><br><span class="line">        Duck d = new Duck();</span><br><span class="line">    //创建一个对象以及他的引用</span><br><span class="line">    //barf()执行完毕</span><br><span class="line">    //引用彻底的离开</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>2.引用被赋值到其他的对象上<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pubilc class ReRef&#123;</span><br><span class="line">    Duck d = new Duck();</span><br><span class="line">    //创建一个对象以及他的引用&quot;d&quot;</span><br><span class="line">    </span><br><span class="line">    public void go()&#123;</span><br><span class="line">        d = new Duck();</span><br><span class="line">    //引用&quot;d&quot;被赋值给新的Duck对象</span><br><span class="line">    //原先的Duck对象无引用所以死亡</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>3.直接将引用设定成null<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class ReRef&#123;</span><br><span class="line">    Duck d = new Duck();</span><br><span class="line">    //创建一个对象以及他的引用&quot;d&quot;</span><br><span class="line">    </span><br><span class="line">    public void go()&#123;</span><br><span class="line">        d = null;</span><br><span class="line">    //引用&quot;d&quot;被赋值为null</span><br><span class="line">    //原先的Duck对象无引用死亡</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/570911275/570911275.github.io/2019/05/29/java-构造器与垃圾回收器之垃圾回收器小结/" data-id="cjzdf8zlf002d44tn41z94rhn" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java-基础/">java_基础</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-java-构造器与垃圾回收器之构造器小结" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/05/28/java-构造器与垃圾回收器之构造器小结/" class="article-date">
  <time datetime="2019-05-28T15:32:38.000Z" itemprop="datePublished">2019-05-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/05/28/java-构造器与垃圾回收器之构造器小结/">java_构造器与垃圾回收器之构造器小结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="1-栈与堆-生存空间"><a href="#1-栈与堆-生存空间" class="headerlink" title="1.栈与堆:生存空间"></a>1.栈与堆:生存空间</h2><p>1.堆与栈的基本概念<br><br>堆:<strong>对象</strong>的生存空间堆<br><br>&nbsp;&nbsp;&nbsp;&nbsp;//<strong>实例变量</strong>是被<strong>声明在类</strong>而不是方法里面。它们代表的每个独立对象的”字段”。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;//<strong>实例变量</strong>存在于<strong>所属的对象</strong>中。<br><br>栈:<strong>方法调用</strong>及<strong>局部变量</strong>的生存空间<br><br>&nbsp;&nbsp;&nbsp;&nbsp;//<strong>局部变量</strong>和<strong>方法的参数</strong>是被<strong>声明在方法</strong>中。它们是<strong>暂时的</strong>。<br>&nbsp;&nbsp;&nbsp;&nbsp;//其<strong>生命周期</strong>只限于<strong>方法被放在栈上</strong>的这段时间。<br><br><br>2.栈上的<strong>对象引用</strong><br><br>非primitive的变量只是<strong>保存对象的引用</strong>。而不是对象的本身,<br><br>如果<strong>局部变量</strong>是个对该<strong>对象的引用</strong>,<strong>只有变量本身会被放在栈上，对象本身只会存在堆上。</strong><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class StackRef&#123;</span><br><span class="line">    public void foof()&#123;</span><br><span class="line">        barf();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void barf()&#123;</span><br><span class="line">        Duck d = new Duck();</span><br><span class="line">        //其中&quot;d&quot;这个局部变量是存在于栈上的。</span><br><span class="line">        //&quot;Duck&quot;这个对象是存在于堆上。</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>

<h2 id="2-构造函数"><a href="#2-构造函数" class="headerlink" title="2.构造函数"></a>2.构造函数</h2><p>1.对象的<strong>声明</strong>与<strong>赋值</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.声明引用变量</span><br><span class="line">&quot;Duck myDuck&quot; = new Duck();</span><br><span class="line">2.创建对象</span><br><span class="line">Duck myDuck = &quot;new Duck()&quot;;</span><br><span class="line">//构造函数就在这一步进行操作</span><br><span class="line">3.连接对象与引用</span><br><span class="line">Duck myDuck &quot;=&quot; new Duck();</span><br></pre></td></tr></table></figure></p>
<p>2.构造函数的<strong>调用</strong><br><br><code>Duck myDuck = &quot;new Duck()&quot;;</code><br><br>这一步调用了Duck的<strong>构造函数</strong>。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;a.在用户<strong>没有编写构造函数</strong>的情况下,编译器将会<strong>自动编写</strong>。<br>&nbsp;&nbsp;&nbsp;&nbsp;b.<strong>唯一</strong>能够在<strong>构造函数之外调用构造函数</strong>的方式为–新建一个类**。<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">在用户无编写构造函数的情况下,系统自行编写的构造函数</span><br><span class="line">public Duck()&#123;</span><br><span class="line">    //其中构造函数的名称必须与类的名称相同</span><br><span class="line">    //与方法区别的一点为:</span><br><span class="line">    //方法有返回类型,构造函数没有返回类型</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>3.构造函数的<strong>意义</strong><br><br>构造函数:会在对象能够<strong>被赋值给引用之前</strong>就执行。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;//这意味着用户有机会在对象<strong>被使用之前</strong>介入。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;//使得用户在构造过程的步骤中<strong>加入一些操作</strong>。<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Duck&#123;</span><br><span class="line">    public Duck()&#123;</span><br><span class="line">        System.out.println(&quot;Quack&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class UseADuck&#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        Duck d = new Duck();</span><br><span class="line">        //启动Duck的构造函数</span><br><span class="line">        //此处输出Quack</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>4.构造函数的<strong>参数</strong><br><br>&nbsp;&nbsp;&nbsp;&nbsp;a.使用构造函数来初始化对象的状态。(即设置和给对象的实例变量赋值)<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//讲构造函数设定成需要参数的。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;b.一定要有不需要参数的构造函数。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//使得用户在创建对象的时候有两个选择:<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//1.可以初始化对象的状态(通过构造函数的参数)<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//2.使用默认值无需初始化<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">构造函数含参数时:</span><br><span class="line">public class Duck&#123;</span><br><span class="line">    int size;</span><br><span class="line">    </span><br><span class="line">    public Duck(int duckSize)&#123;</span><br><span class="line">        System.out.println(&quot;Quack&quot;);</span><br><span class="line">        </span><br><span class="line">        size = duckSize;</span><br><span class="line">        </span><br><span class="line">        System.out.println(&quot;size is &quot; + size);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class UseADuck&#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        Duck d = new Duck(2);</span><br><span class="line">        //此处传值给构造函数</span><br><span class="line">        //此处输出</span><br><span class="line">        //       Quack </span><br><span class="line">        //       size is 2</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>5.构造函数的<strong>重载</strong><br><br>1.如果一个类有了<strong>一个以上</strong>的构造函数,则<strong>参数</strong>一定要<strong>不一样</strong>。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;a.包括了<strong>参数的顺序</strong>与<strong>类型</strong>。只要<strong>不一样</strong>即可。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;b.编译器查看的是<strong>参数的类型</strong>和<strong>顺序</strong>而不是参数的名字。<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public clas Mushroom&#123;</span><br><span class="line">    public Mushroom(int size) &#123;&#125;</span><br><span class="line">    //只含有一个参数</span><br><span class="line">    </span><br><span class="line">    public Mushroom() &#123;&#125;</span><br><span class="line">    //无参数类型</span><br><span class="line">    </span><br><span class="line">    public Mushroom(boolean isMagic) &#123;&#125;</span><br><span class="line">    //只含有一个参数(参数类型发生改变)</span><br><span class="line">    </span><br><span class="line">    public Mushroom(boolean isMagic, int size) &#123;&#125;</span><br><span class="line">    public Mushroom(int size, boolean isMagic) &#123;&#125;</span><br><span class="line">    //顺序不同通过编译</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>6.调用<strong>父类</strong>的构造函数<br><br>唯一调用父类构造函数的方法是调用super()<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Duck extends Animal&#123;</span><br><span class="line">    int size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Duck(int newSize)&#123;</span><br><span class="line">    super();</span><br><span class="line">    size = newSize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/570911275/570911275.github.io/2019/05/28/java-构造器与垃圾回收器之构造器小结/" data-id="cjzdf8zli002f44tnwxwu00ph" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java-基础/">java_基础</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-java-接口与抽象类小结" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/05/27/java-接口与抽象类小结/" class="article-date">
  <time datetime="2019-05-27T15:01:14.000Z" itemprop="datePublished">2019-05-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/05/27/java-接口与抽象类小结/">java_接口与抽象类小结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="1-抽象类与具体类"><a href="#1-抽象类与具体类" class="headerlink" title="1.抽象类与具体类"></a>1.抽象类与具体类</h2><p>1.<strong>抽象类</strong><br><br>&nbsp;&nbsp;&nbsp;&nbsp;a.有些类不该被<strong>初始化</strong>,则通过<strong>标记类为抽象类</strong>。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//抽象类仍可以作为<strong>引用类型</strong>。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//抽象类<strong>不可被初始化</strong>。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;b.抽象类<strong>除了被继承过</strong>之外,是<strong>没有用途</strong>、<strong>没有值</strong>、<strong>没有目的</strong>的。<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">abstract public class Canine extends Animal</span><br><span class="line">&#123;</span><br><span class="line">    //定义一个抽象类&quot;Canine&quot;;</span><br><span class="line">    public void roam();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class MakeCanine&#123;</span><br><span class="line">    public void go()&#123;</span><br><span class="line">        Canine c;</span><br><span class="line">        c = new Dog;</span><br><span class="line">        //此处是可以通过编译器的;</span><br><span class="line">        //因为可以赋值子类对象给父类的引用&quot;c&quot;。即使该父类&quot;Canine&quot;为抽象的。</span><br><span class="line">        c = new Canine();</span><br><span class="line">        //此处是不可以通过编译器的;</span><br><span class="line">        //因为这个类&quot;Canine&quot;已经被标记为抽象的了。不可以被初始化</span><br><span class="line">        c.roam();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>2.<strong>具体类</strong><br><br>不是抽象的类,就是<strong>具体类</strong><br></p>
<hr>

<h2 id="2-抽象的方法"><a href="#2-抽象的方法" class="headerlink" title="2.抽象的方法"></a>2.抽象的方法</h2><p>1.除了类之外,也可以将<strong>方法</strong>标记为”<strong>abstract</strong>“。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;a.<strong>抽象的类</strong>代表此类<strong>必须要被继承”extend”过</strong>。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;b.<strong>抽象的方法</strong>代表此方法<strong>必须要被覆盖过</strong>。<br><br><br>2.抽象的方法<strong>没有实体</strong><br><br>&nbsp;&nbsp;&nbsp;&nbsp;//因为抽象的方法<strong>必须要被覆盖</strong>,所以编写出抽象方法的代码<strong>没有意义</strong>(即不会含有方法在其中)。<br><br><br>3.抽象的方法<strong>所在的类</strong>必须为<strong>抽象</strong>的<br><br>&nbsp;&nbsp;&nbsp;&nbsp;//就算<strong>只有一个</strong>方法是抽象的,该类也必须为<strong>抽象类</strong>。<br><br>4.抽象方法的<strong>意义</strong><br><br>&nbsp;&nbsp;&nbsp;&nbsp;a.抽象的意义在于:就算无法实现出方法的的内容，但是还可以定义出一组<strong>子型共同的协议</strong><br><br>&nbsp;&nbsp;&nbsp;&nbsp;b.好处:利于多态。这样所有的子型都会有那些抽象的方法。<br><br><br>5.抽象方法的<strong>要求</strong><br><br>&nbsp;&nbsp;&nbsp;&nbsp;a.<strong><em>第一个具体类</em></strong>必须实现<strong>所有</strong>的<strong>抽象方法</strong>。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//必须实现所有的方法:表示必须<strong>写出内容</strong>,必须以<strong>相同的方法</strong>鉴名(<strong>名称</strong>和<strong>参数</strong>)和<strong>相容的返回类型</strong>创建出<strong>非抽象的方法</strong>。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;b.抽象类可以带有<strong>抽象</strong>的和<strong>非抽象</strong>的方法。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//这表示抽象类可以<strong>实现部分抽象方法</strong>,这样<strong>第一个具体类</strong>就可以<strong>不必去实现</strong>这一部分。<br></p>
<hr>

<h2 id="3-对象之母——Object"><a href="#3-对象之母——Object" class="headerlink" title="3.对象之母——Object"></a>3.对象之母——Object</h2><p>1.<strong>在java中所有的类都是从Object这个类继承出来的</strong>。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;a.<strong>Object</strong>是<strong>所有类的源头</strong>,他是<strong>所有类的父类</strong>。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;b.如果java中<strong>没有共同的父类</strong>,讲<strong>无法创建</strong>出可以处理<strong>自定义类型的类</strong>(即无法写出如同<strong>ArrayList</strong>这样可以<strong>处理各种类的类</strong>)。<br><br><br>2.<strong>没有继承</strong>过其他类的类会是<strong>隐含的继承对象</strong><br><br>&nbsp;&nbsp;&nbsp;&nbsp;//如同”Dog”这个类<strong>没有直接继承”extend”对象”Object”</strong>,但是还是会<strong>通过”Dog”的父类</strong>“Animal”来<strong>继承对象”Object”</strong>。<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">关于上述1——b的ArrayList</span><br><span class="line">ArrayList:</span><br><span class="line">boolean remove(Object elem)</span><br><span class="line">//根据索引参数移动对象,如果list中没有元素返回true。</span><br><span class="line"></span><br><span class="line">boolean contains(Object elem)</span><br><span class="line">//如果和对象的参数相匹配的话返回true</span><br><span class="line"></span><br><span class="line">int indexOf(Object elem)</span><br><span class="line">//返回对象参数的索引或-1</span><br><span class="line"></span><br><span class="line">由上述例子可知,许多的ArrayList的方法都用到了Object这个终极类型。</span><br><span class="line">因为每个类都是对象&quot;Object&quot;的子类,所以ArrayList可以处理任何类。</span><br></pre></td></tr></table></figure></p>
<p>3.<strong>Object中的方法</strong>(部分)<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">1.equals(Object o) 判断是否相等</span><br><span class="line">eg:</span><br><span class="line">Dog d = new Dog();</span><br><span class="line">Cat c = new Cat();</span><br><span class="line">if(d.equals(c))&#123;</span><br><span class="line">    System.out.println(&quot;true&quot;);</span><br><span class="line">&#125;else&#123;</span><br><span class="line">    System.out.println(&quot;false&quot;);</span><br><span class="line">&#125;</span><br><span class="line">//此处打印出&quot;flase&quot;</span><br><span class="line"></span><br><span class="line">2.getClass() 告知用户对象是从哪里被初始化的</span><br><span class="line">eg:</span><br><span class="line">Cat c = new Cat();</span><br><span class="line">Systrm.out.println(c.getClass())</span><br><span class="line">//此处打印出&quot;class Cat&quot;</span><br><span class="line"></span><br><span class="line">3.hashCode() 列出此对象的哈希代码(如同唯一的ID)</span><br><span class="line">eg:</span><br><span class="line">Cat c = new Cat();</span><br><span class="line">Systrm.out.println(c.hashCode())</span><br><span class="line">//此处打印出&quot;8202111&quot;</span><br><span class="line"></span><br><span class="line">4.toString() 列出类的名称和一串数字</span><br><span class="line">eg:</span><br><span class="line">Cat c = new Cat();</span><br><span class="line">Systrm.out.println(c.toString())</span><br><span class="line">//此处打印出&quot;Cat@7d277f&quot;</span><br></pre></td></tr></table></figure></p>
<p>4.使用<strong>Object类型的多态引用</strong>的后果<br><br>&nbsp;&nbsp;&nbsp;&nbsp;a.此处<strong>不涉及</strong>制作出<strong>Object类型的实例</strong>。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;b.任何<strong>被Object类型的引用变量</strong>所引用的对象,将被编译器认为为<strong>Object类型</strong>。<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">正常的:</span><br><span class="line">ArrayList&lt;Dog&gt; myDogArrayList = new ArrayList&lt;Dog&gt;();</span><br><span class="line">//保存Dog的Arraylist</span><br><span class="line">Dog aDog = new Dog();</span><br><span class="line">//新建一个Dog</span><br><span class="line">myDogArrayList.add(aDog);</span><br><span class="line">//将aDog放入ArrayList中</span><br><span class="line">Dog d = myDogArrayList.get(0);</span><br><span class="line">//讲Dog赋值给新的Dog引用变量</span><br><span class="line"></span><br><span class="line">Object类型的引用变量下:</span><br><span class="line">ArrayList&lt;Object&gt; myDogArrayList = new ArrayList&lt;Object&gt;();</span><br><span class="line">//保存Object的Arraylist</span><br><span class="line">Dog aDog = new Dog();</span><br><span class="line">//新建一个Dog</span><br><span class="line">myDogArrayList.add(aDog);</span><br><span class="line">//将aDog放入ArrayList中</span><br><span class="line">Dog d = myDogArrayList.get(0);</span><br><span class="line">//此处无法通过编译器</span><br><span class="line">//因为对ArrayList&lt;Object&gt;调用get()方法会返回Object类型</span><br><span class="line">//编译器无法确认它为Dog</span><br><span class="line">//即任何从ArrayList&lt;Object&gt;中取出的Object都会被当做是Object这个类的实例。</span><br></pre></td></tr></table></figure></p>
<hr>

<h2 id="4-引用类型"><a href="#4-引用类型" class="headerlink" title="4.引用类型"></a>4.引用类型</h2><p>1.从上述3——4——b中可以得知当<strong>引用类型改变</strong>时,编译器将<strong>无法识别原先的类型</strong>。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;//即引用仍为<strong>同一个引用</strong>,但是<strong>引用类型</strong>已经发生了<strong>改变</strong>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">3——4——b的修改方法:</span><br><span class="line">ArrayList&lt;Object&gt; myDogArrayList = new ArrayList&lt;Object&gt;();</span><br><span class="line">Dog aDog = new Dog();</span><br><span class="line">myDogArrayList.add(aDog);</span><br><span class="line">Object d = myDogArrayList.get(0);</span><br><span class="line">//这样则可以通过编译</span><br></pre></td></tr></table></figure></p>
<p>2.编译器是<strong>根据引用类型</strong>来<strong>判断</strong>有<strong>哪些方法”method”可以调用</strong>的,而<strong>不是根据</strong>Object<strong>确实的类型</strong>。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;//即便用户知道对象有这个功能,但是编译器只会把他当成<strong>一般的Object</strong>来看待。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;//即他只能调用<strong>Object内所含有的方法</strong>。编译器只管<strong>引用的类型</strong>,而<strong>不是对象的类型</strong>。<br></p>
<hr>

<h2 id="5-对象类型的装换"><a href="#5-对象类型的装换" class="headerlink" title="5.对象类型的装换"></a>5.对象类型的装换</h2><p>1.<strong>可以确认</strong>该变量为什么类型,并且<strong>希望调用该变量本身类型的方法</strong>。则可以将其<strong>声明</strong>为<strong>该变量本身类型</strong>。<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Object o = al.get(index);</span><br><span class="line">Dog d = (Dog) o ;</span><br><span class="line">//o本身类型为Dog的情况下</span><br><span class="line">//可以通过此方式进行类型转换</span><br><span class="line">d.roam();</span><br></pre></td></tr></table></figure></p>
<p>2.<strong>无法确认</strong>变量类型时,可以通过使用<strong>“instanceof”</strong>这个<strong>运算符</strong>来<strong>进行检查</strong>。如果类型转换错误,则在执行期将遇到<strong>“ClassCastException”异常</strong>并且<strong>终止</strong>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if(o instanceof Dog)&#123;</span><br><span class="line">    Dog d = (Dog) o ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>

<h2 id="6-接口"><a href="#6-接口" class="headerlink" title="6.接口"></a>6.接口</h2><p>1.接口的<strong>定义与实现</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">接口的定义:</span><br><span class="line">public interface Pet&#123;...&#125;</span><br><span class="line">//使用&quot;interface&quot;来代替&quot;class&quot;</span><br><span class="line"></span><br><span class="line">接口的实现:</span><br><span class="line">public class Dog extends Canine impements Pet&#123;...&#125;</span><br><span class="line">//使用&quot;implements&quot;这个关键词</span><br></pre></td></tr></table></figure></p>
<p>2.接口中的<strong>方法</strong><br><br>接口中<strong>全部的</strong>方法都是<strong>抽象的</strong>。<br><br>这样子类则必须实现此方法。可解决”致命方块”问题。<br><br>3.接口的<strong>意义</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;a.<strong>利于多态</strong>,接口具有<strong>无比的适用性</strong>。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//使用接口取代<strong>具体的子类</strong>或<strong>抽象的父类</strong>作为<strong>参数或返回类型</strong>。则可以<strong>传入任何</strong>有<strong>实现该接口</strong>的东西。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;b.继承<strong>超过一个以上</strong>的来源<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//使用接口的情况下,类有<strong>继承”extend”过某个父类</strong>并且<strong>实现其他的接口</strong>。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//同时<strong>其他的类</strong>也可以实现<strong>同一个接口</strong>。<br><br><br>4.<strong>不同继承树的类</strong>也可以实现<strong>相同的接口</strong><br><br>&nbsp;&nbsp;&nbsp;&nbsp;a.当把一个<strong>类</strong>作为<strong>多态类型</strong>运用时,<strong>相同的类型</strong>必定来自<strong>同一个继承树</strong>。并且为<strong>该多态类型的子类</strong>。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;b.当把<strong>接口</strong>作为<strong>多态类型</strong>运用时,对象就可以来自<strong>任何的地方</strong>了。<strong>唯一的条件是该对象必须是来自有实现此接口的类</strong>。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;c.类可以实现<strong>多个接口</strong><br><br><code>public class Dog extends Animal implements Pet, Saveable, paintable{...}</code><br><br><br>5.<strong>设计类</strong>、<strong>子类</strong>、<strong>抽象类</strong>、<strong>接口</strong>的判断<br><br>&nbsp;&nbsp;&nbsp;&nbsp;a.如果新的类无法对其他的类通过IS-A的测试时,就设计不继承其他类的类。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;b.只有在需要某类的特殊版本时,以覆盖或增加新的方法来继承现有的类。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;c.当你需要定义一群子类的模版,又不想让程序初始化此模版时,设计出抽象的类给。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;d.如果想要定义出类可以扮演的角色,使用接口。<br></p>
<hr>

<h2 id="7-调用父类的方法"><a href="#7-调用父类的方法" class="headerlink" title="7.调用父类的方法"></a>7.调用父类的方法</h2><p>当想要调用父类中的方法时,可以使用<strong>“super”</strong>这个关键词在<strong>子类中调用父类</strong>的方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">abstract class Report&#123;</span><br><span class="line">    void runReport()&#123;</span><br><span class="line">        //设置报告</span><br><span class="line">    &#125;</span><br><span class="line">    void printReport()&#123;</span><br><span class="line">        //输出</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class BuzzwordsReport extends Report&#123;</span><br><span class="line">    void runReport()&#123;</span><br><span class="line">        super.runReport();</span><br><span class="line">        //调用父类的方法</span><br><span class="line">        buzzwordCompliance();</span><br><span class="line">        printReport();</span><br><span class="line">    &#125;</span><br><span class="line">    void buzzwordCompliance()&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/570911275/570911275.github.io/2019/05/27/java-接口与抽象类小结/" data-id="cjzdf8znh003r44tnagr07kkb" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java-基础/">java_基础</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-java-继承与多态小结" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/05/26/java-继承与多态小结/" class="article-date">
  <time datetime="2019-05-26T11:00:07.000Z" itemprop="datePublished">2019-05-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/05/26/java-继承与多态小结/">java_继承与多态小结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="1-继承的设计"><a href="#1-继承的设计" class="headerlink" title="1.继承的设计"></a>1.继承的设计</h2><p>1.找出Class中<strong>共有的部分</strong><br><br>2.提取出<strong>共有部分</strong>,并设计代表共同状态与行为的新的类<br><br>3.将原先的类以称为<strong>继承</strong>的关系连接到新的类上<br><br>//此时原先的类称为”<strong>子类</strong>“，新的类称为”<strong>父类</strong>“。<br><br>//子类会<strong>自动</strong>获得父类的<strong>功能</strong><br><br>4.决定子类是否需要让<strong>某些行为</strong>(也就是<strong>方法的实现</strong>)有特定的<strong>不同的</strong>运作方式<br><br>5.当子类与父类同一方法有所改变时，可进行<strong>覆盖</strong>。<strong>覆盖</strong>:由子类<strong>重新定义</strong>继承下来的方法以<strong>改变或延伸此方法的行为</strong>。<br><br>//此时<strong>调用对象引用的方法</strong>时,会调用到该对象类型<strong>最接近</strong>的方法<br><br>//(也就是先看本人有没有该方法，没有则找父亲有没有，再没有寻找他爷爷，逐级升高)</p>
<hr>

<h2 id="2-继承的运行方式"><a href="#2-继承的运行方式" class="headerlink" title="2.继承的运行方式"></a>2.继承的运行方式</h2><p>1.类的成员:实例变和方法<br><br>2.继承的关系意味着子类继承了父类的<strong>方法</strong><br><br>&nbsp;&nbsp;&nbsp;a.子类可以加入自己的<strong>实例变量和方法</strong>也可以覆盖掉来自父类的方法。<br><br>&nbsp;&nbsp;&nbsp;b.实例变量无法被覆盖的原因为:不需要。它们并没有定义特殊的行为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">父类:</span><br><span class="line">public class Doctor&#123;</span><br><span class="line">    boolean worksAtHospital;</span><br><span class="line">    void treatPatient()&#123;</span><br><span class="line">        //检查</span><br><span class="line">    &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">子类一:</span><br><span class="line">public class FamilyDoctor extends Doctor&#123;</span><br><span class="line">    boolean makesHouseCalls;</span><br><span class="line">    void giveAdvice();</span><br><span class="line">    //增加新的方法</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">子类二:</span><br><span class="line">public class Surgeon extends Doctor&#123;</span><br><span class="line">    void treatPaient() &#123;</span><br><span class="line">        //手术</span><br><span class="line">    &#125;;</span><br><span class="line">    //覆盖父类方法</span><br><span class="line">    </span><br><span class="line">    void makeIncision() &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>

<h2 id="3-继承设计的判断"><a href="#3-继承设计的判断" class="headerlink" title="3.继承设计的判断"></a>3.继承设计的判断</h2><p>1.IS-A:通过IS-A来判断某物是否一个继承另一物<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">三角形是一个多边形    T</span><br><span class="line">黄丫丫是一个人类      T</span><br><span class="line">苹果是香蕉            F</span><br><span class="line">水是水杯              F</span><br></pre></td></tr></table></figure></p>
<p>2.如果类X是继承类Y的,且类Y是继承类Z的,则X可以通过IS-A Z的测试。<br><br>//即继承具有传递性<br>3.<strong>继承概念下的IS-A是一个单向的概念</strong><br><br>&nbsp;&nbsp;&nbsp;&nbsp;三角形是一个多边形这个是符合的<br><br>&nbsp;&nbsp;&nbsp;&nbsp;多边形是一个三角形这个是不符合的<br></p>
<hr>

<h2 id="4-继承的权限限制"><a href="#4-继承的权限限制" class="headerlink" title="4.继承的权限限制"></a>4.继承的权限限制</h2><p>父类可以通过存取权限觉得子类是否能够继承某些特定的成员<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">以下4种权限:</span><br><span class="line">最限制  ————————&gt;  最公开</span><br><span class="line">private default protected public</span><br></pre></td></tr></table></figure></p>
<p>其中<strong>public</strong> 类型的成员会被继承<br><br><strong>private</strong> 类型的成员不会被继承<br></p>
<hr>

<h2 id="5-继承的意义"><a href="#5-继承的意义" class="headerlink" title="5.继承的意义"></a>5.继承的意义</h2><p>1.避免了<strong>重复的程序代码</strong><br><br>2.定义了<strong>共同的协议</strong><br><br>&nbsp;&nbsp;&nbsp;&nbsp;//共同协议:在父类中定义方法是,他们会被子类继承。这是在什么说所有继承的类都可以<br>执行这些方法，这里面也包括了<strong>方法的参数和返回类型</strong>。<br></p>
<hr>

<h2 id="6-多态与一般对象的区别"><a href="#6-多态与一般对象的区别" class="headerlink" title="6.多态与一般对象的区别"></a>6.多态与一般对象的区别</h2><p>1.一般的声明引用和创建对象的方法<br><br><code>Dog myDog = new Dog();</code><br><br>其中<strong>引用类型和对象类型必须相符</strong>,例子中两者都是Dog<br><br>2.多态下的声明引用和创建对象的方法<br><br><code>Animal myDog = new Dog();</code><br><br>其中<strong>多态下引用类型和对象类型可以不相符</strong>,例子中引用类型为Animal,对象类型为Dog。<br></p>
<hr>

<h2 id="7-多态的运用范围"><a href="#7-多态的运用范围" class="headerlink" title="7.多态的运用范围"></a>7.多态的运用范围</h2><p>1.运用多态时,引用类型可以是<strong>实际对象类的父类</strong>(即继承树上方的类可以引用下方的子类)<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Animal[] animals = new Animal[2];</span><br><span class="line"></span><br><span class="line">animals [0] = new Dog();</span><br><span class="line">animals [1] = new Cat();</span><br><span class="line">//可以用animal 引用任何Animal的子类对象</span><br><span class="line"></span><br><span class="line">for(int i=0; i&lt;animals.length; i++)&#123;</span><br><span class="line">    animals[i].eat();</span><br><span class="line">    //当i为0是会调用Dog的eat();</span><br><span class="line">    //当i为1是会调用Cat的eat();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>2.<strong>返回类型</strong>和<strong>参数</strong>也可以多态<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Vet&#123;</span><br><span class="line">    public void giveShot(Animal a)&#123;</span><br><span class="line">    //参数可以是任何一种Animal下面的子类的类型对象</span><br><span class="line">        a.makeNoise();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class PetOwner&#123;</span><br><span class="line">    public void start()&#123;</span><br><span class="line">        Vet v = new Vet();</span><br><span class="line">        Dog d = new Dog();</span><br><span class="line">        Hippo h = new Hippo();</span><br><span class="line">        v.giveShot(d);</span><br><span class="line">        //执行Dog的makeNoise方法</span><br><span class="line">        v.giveShot(h);</span><br><span class="line">        //执行Hippo的makeNoise方法</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>

<h2 id="8-覆盖的规则与方法的重载"><a href="#8-覆盖的规则与方法的重载" class="headerlink" title="8.覆盖的规则与方法的重载"></a>8.覆盖的规则与方法的重载</h2><p>1.覆盖的规则<br><br>&nbsp;&nbsp;&nbsp;&nbsp;a.<strong>参数</strong>必须<strong>一样</strong>，且<strong>返回类型必须兼容</strong>。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;父类中的方法使用了哪种参数,覆盖此方法的子类也一定要<strong>使用相同的参数</strong>。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;而无论父类中的方法声明的返回类型是什么,子类必须声明返回<strong>一样的类型</strong>或者<strong>该类型的子类</strong>。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;b.<strong>不能降低</strong>方法的<strong>存取权限</strong>(即权限必须相同,或者更加公开)<br><br><br><br>2.方法的重载<br><br>&nbsp;&nbsp;&nbsp;&nbsp;a.重载与多态毫无关系。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;重载可以有<strong>同一方法</strong>的<strong>多个不同参数版本</strong>以方便调用。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;重载只是刚好有<strong>相同名字的方法</strong>,它与多态和继承没有关系。<strong>重载的方法和覆盖的方法不一样</strong>。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;b.重载的返回类型可以不同<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以任意的<strong>改变</strong>重载方法的<strong>返回类型</strong>,只要所有的<strong>覆盖</strong>使用<strong>不同的参数</strong>即可。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;c.重载不能只改变返回类型<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果<strong>只有返回类型不同</strong>,<strong>参数是一样的</strong>。这样是无法通过编译的。重载的条件是<strong>使用不同的参数</strong>。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;d.重载可以<strong>更改存取权限</strong></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/570911275/570911275.github.io/2019/05/26/java-继承与多态小结/" data-id="cjzdf8zlk002h44tnx4is2yw2" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java-基础/">java_基础</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-java-认识java的API之使用java函数库小结" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/05/25/java-认识java的API之使用java函数库小结/" class="article-date">
  <time datetime="2019-05-25T14:39:01.000Z" itemprop="datePublished">2019-05-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/05/25/java-认识java的API之使用java函数库小结/">java_认识java的API之使用java函数库小结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="1-游戏bug修复方法"><a href="#1-游戏bug修复方法" class="headerlink" title="1.游戏bug修复方法"></a>1.游戏bug修复方法</h2><p>1.使用<strong>第二个数组</strong><br><br>&nbsp;&nbsp;&nbsp;每当玩家猜中某一格子时,就把相对的那一个设定为<strong>true</strong>,之后每次猜中都要在<strong>第二个数组</strong>中检查该格子之前是否已经猜中。<br>2.只改动<strong>原来的数组</strong><br><br>&nbsp;&nbsp;&nbsp;通过只改动原来的数组，任何被猜中的格子改为<strong>-1</strong>;这样则只需要维护一个数组。<br></p>
<hr>

<h2 id="2-ArrayList——数组不够用时"><a href="#2-ArrayList——数组不够用时" class="headerlink" title="2.ArrayList——数组不够用时"></a>2.ArrayList——数组不够用时</h2><p>1.ArrayList的用法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">add(Object elem)</span><br><span class="line">//向list中加入对象参数</span><br><span class="line"></span><br><span class="line">remove(int index)</span><br><span class="line">//在索引参数中移除对象</span><br><span class="line"></span><br><span class="line">remove(Object elem)</span><br><span class="line">//移除该对象</span><br><span class="line"></span><br><span class="line">contains(Object elem)</span><br><span class="line">//如果和对象参数匹配返回&quot;true&quot;</span><br><span class="line"></span><br><span class="line">isEmpty()</span><br><span class="line">//如果list中没有元素返回&quot;true&quot;</span><br><span class="line"></span><br><span class="line">indexOf(Object elem)</span><br><span class="line">//返回对象参数的索引或-1</span><br><span class="line"></span><br><span class="line">size()</span><br><span class="line">//返回list中元素的一个数</span><br><span class="line"></span><br><span class="line">get(int index)</span><br><span class="line">//返回当前索引参数的对象</span><br></pre></td></tr></table></figure></p>
<p>2.ArrayList与一般数组的对比<br><br>&nbsp;&nbsp;&nbsp;&nbsp;a.一般数组在创建时必须确认大小<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于ArrayList来说，只需要创建出此类型的对象就可以了。会<strong>动态的在加入和删除元素时调整大小</strong><br><br>&nbsp;&nbsp;&nbsp;&nbsp;b.一般数组在存放对象时必须指定位置<br><code>如: myList[1]=b;</code><br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于ArrayList可以用<strong>add(Int, Object)</strong>或者<strong>add(Object)</strong>来进行<strong>自行管理大小</strong><br><code>myList.add(b);</code><br><br>&nbsp;&nbsp;&nbsp;&nbsp;c.一般数组使用特殊的语法<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于ArrayList来说，ArrayList是个<strong>普通对象</strong>,所以不会有特殊的语法<br><code>myList[1]; 其中&quot;[ ]&quot;方括号为只使用在数组上面的特殊语法</code><br><br>&nbsp;&nbsp;&nbsp;&nbsp;d.在java5.0中的ArrayList是参数化的<br><code>ArrayList&lt;String&gt; 其中&lt;String&gt;是类型参数。这代表String的集合。如同ArrayList&lt;Dog&gt;代表Dog的集合</code><br></p>
<hr>

<h2 id="3-使用ArrayList改编游戏"><a href="#3-使用ArrayList改编游戏" class="headerlink" title="3.使用ArrayList改编游戏"></a>3.使用ArrayList改编游戏</h2><p>1.改编内容<br><br>&nbsp;&nbsp;&nbsp;&nbsp;a.<strong>DotCom</strong>类<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;增加名称变量，用来保存DotCom的名字。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;b.<strong>DotComBust</strong>类(the game)<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;创建出3个DotCom<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;指定DotCom的名称<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将DotCom放在方阵上<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>每次猜测都检查3个DotCom</strong><br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>击沉3个DotCom后才可以结束游戏</strong><br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;脱离main()<br></p>
<p><strong>2.代码区</strong><br><br>&nbsp;&nbsp;&nbsp;&nbsp;a.<strong>DotCom</strong><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line"></span><br><span class="line">public class DotCom&#123;</span><br><span class="line">    private ArrayList&lt;String&gt; locationCells;</span><br><span class="line">    private String name;</span><br><span class="line">    </span><br><span class="line">    public void setLocationCells(ArrayList&lt;String&gt; loc)&#123;</span><br><span class="line">        locationCells = loc;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void setName(String n)&#123;</span><br><span class="line">        name = n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public String checkYourself(String userInput)&#123;</span><br><span class="line">    String result = &quot;miss&quot;;</span><br><span class="line">    int index = locationCells.indexOf(userInput);</span><br><span class="line">    if (index &gt;= 0)&#123;</span><br><span class="line">        locationCells.remove(index);</span><br><span class="line">        </span><br><span class="line">        if(locationCells.isEmpty())&#123;</span><br><span class="line">            result = &quot;kill&quot;;</span><br><span class="line">            System.out.println(&quot;Ouch! You sunk &quot;+ name +&quot; : (&quot; ) ;&#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            result = &quot;hit&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;b.<strong>DotComBust</strong><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line">public class DotComBust&#123;</span><br><span class="line">    private GameHelper helper = new GameHelper();</span><br><span class="line">    private ArrayList&lt;DotCom&gt; dotComsList = new ArrayList&lt;DotCom&gt;();</span><br><span class="line">    private int numOfGuesses = 0;</span><br><span class="line">    </span><br><span class="line">    private void setUpGame()&#123;</span><br><span class="line">        Dotcom one = new DotCom();</span><br><span class="line">        one.setName(&quot;pets.com&quot;);</span><br><span class="line">        Dotcom two = new DotCom();</span><br><span class="line">        two.setName(&quot;eYoys.com&quot;);</span><br><span class="line">        Dotcom three = new DotCom();</span><br><span class="line">        three.setName(&quot;Go2.com&quot;);</span><br><span class="line">        //创建3个DotCom对象并赋值名称</span><br><span class="line">        dotComList.add(one);</span><br><span class="line">        dotComList.add(two);</span><br><span class="line">        dotComList.add(three);</span><br><span class="line">        //将其名称置入ArrayList中</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    System.out.println(&quot;Your goal is to sink three dot coms&quot;);</span><br><span class="line">    System.out.println(&quot;Petx.com,eToys.com,Go2.com&quot;);</span><br><span class="line">    System.out.println(&quot;Try to sink them all in the fewest number of guesses&quot;);</span><br><span class="line">    //此处做出简短的提示，告知玩家网站名称，并且输入位置进行击中网站</span><br><span class="line">    </span><br><span class="line">    for(DotCom dotComToSet : DotComsList)&#123;</span><br><span class="line">    //该for循环在&quot;java_编写程序之超强力方法小结&quot;中曾记录。</span><br><span class="line">    //对list中所有的DotCom重复赋值给dotComToSet中。</span><br><span class="line">        ArrayList&lt;string&gt; newLocation = helper.placeDotCom(3);</span><br><span class="line">        //要求DotCom的位置</span><br><span class="line">        </span><br><span class="line">        dotComToSet.setLocationCells(newLocation);</span><br><span class="line">        //调用set方法来指派刚刚取得的位置</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private void startPlaying()&#123;</span><br><span class="line">        while(!dotComsList.isEmpty())&#123;</span><br><span class="line">        //判断DotCom的list是否为空，若为空则表示全部击沉</span><br><span class="line">            String userGuess = helper.getUserInput(&quot;Enter a guess&quot;);</span><br><span class="line">            //获取玩家输入值</span><br><span class="line">            checkUserGuess(userGuess);</span><br><span class="line">            //调用checkUserGuess方法，检查是否命中</span><br><span class="line">        &#125;</span><br><span class="line">        finishGame();</span><br><span class="line">        //调用finishGame方法，此时已经结束游戏，列出玩家最后成绩</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private void checkUserGuess(String userGuess)&#123;</span><br><span class="line">        numOfGuesses++;</span><br><span class="line">        //递增玩家猜测次数的计数</span><br><span class="line">        </span><br><span class="line">        String result = &quot;miss&quot;;</span><br><span class="line">        //先设定命中状态为未命中</span><br><span class="line">        </span><br><span class="line">        for(DotCom dotComToTest : dotComsList)&#123;</span><br><span class="line">        //此处对list中所有的DotCom重复</span><br><span class="line">            result = dotComTest.checkYourself(userGuess);</span><br><span class="line">            //检查是否击沉或者击中</span><br><span class="line">            if(result.equals(&quot;hit&quot;))&#123;</span><br><span class="line">                break;</span><br><span class="line">                //在击中后跳出循环</span><br><span class="line">            &#125;</span><br><span class="line">            if(result.equals(&quot;kill&quot;))&#123;</span><br><span class="line">                dotComsList.remove(dotComToTest);</span><br><span class="line">                break;</span><br><span class="line">                //在击沉后跳出循环</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.oyut.println(result);</span><br><span class="line">        //列出结果</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private void finishGame()&#123;</span><br><span class="line">        System.out.println(&quot;All Dot Coms are dead! Your stock is now worthless.&quot;);</span><br><span class="line">        if(numOfGuesses &lt;= 18)&#123;</span><br><span class="line">            System.out.println(&quot;It only took you &quot;+ numOfGuesses +&quot; guesses.&quot;);</span><br><span class="line">            Ststem.out.println(&quot;You got out before your options sank.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            System.out.println(&quot;Took you long enough.&quot;+ numOfGuesses +&quot; giesses.&quot;);</span><br><span class="line">            System.out.println(&quot;Fish are dancing with hyour options&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        DotComBust game = new DotComBust();</span><br><span class="line">        game.setUpGame();</span><br><span class="line">        game.startPlaying();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;c.<strong>GameHelper</strong><br><br>//该代码块不好理解<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">import java.io.;</span><br><span class="line">import java.util.;</span><br><span class="line"></span><br><span class="line">public class GameHelper&#123;</span><br><span class="line">    private static final String alphabet = &quot;abcdefg&quot;;</span><br><span class="line">    private int gridLength = 7;</span><br><span class="line">    private int gridSize   = 49;</span><br><span class="line">    private int [] grid    = new int[gridSize];</span><br><span class="line">    private int comCount = 0;</span><br><span class="line">    </span><br><span class="line">    public String getUserInput(String prompet)&#123;</span><br><span class="line">        String inputLine = null;</span><br><span class="line">        System.out.print(prompt + &quot; &quot;);</span><br><span class="line">        try&#123;</span><br><span class="line">            BufferedReader is = new BufferedReader(</span><br><span class="line">            new InputStreamReader(System.in);</span><br><span class="line">            InputLine = is.readLine();</span><br><span class="line">            if(inputLine.length() == 0) return null;)</span><br><span class="line">        &#125;</span><br><span class="line">        catch(IOException e)&#123;</span><br><span class="line">            System.out.println(&quot;IOException:&quot; + e);</span><br><span class="line">        &#125;</span><br><span class="line">        return inputLine.toLowerCase();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    publish ArrayList&lt;String&gt; placeDotCom(int comSize)&#123;</span><br><span class="line">        ArrayList&lt;Strubg&gt; alphaCells = new ArrayList&lt;String&gt;();</span><br><span class="line">        String [] alphacoords = new String [comSize];</span><br><span class="line">        String temp = null;</span><br><span class="line">        int [] coords = new int[comSize];</span><br><span class="line">        int attempts = 0;</span><br><span class="line">        boolean success = flase;</span><br><span class="line">        int location = 0;</span><br><span class="line">        </span><br><span class="line">        comCount++;</span><br><span class="line">        int incr = 1;</span><br><span class="line">        if((comCount %2) == 1)&#123;</span><br><span class="line">            incr = gridLength;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        while(!syccess &amp; attempts++ &lt; 200)&#123;</span><br><span class="line">            location = (int) (Math.random() * gridSize);</span><br><span class="line">            int x = 0;</span><br><span class="line">            success = true;</span><br><span class="line">            while(success &amp;&amp; x &lt;comSize)&#123;</span><br><span class="line">                if(grid[location] == 0)&#123;</span><br><span class="line">                    coords[x++] = location;</span><br><span class="line">                    location += incr;</span><br><span class="line">                    if(location &gt;= gridSize)&#123;</span><br><span class="line">                        success = flase;</span><br><span class="line">                    &#125;</span><br><span class="line">                    if(x&gt;0 &amp;&amp; (location % gridLength == 0))&#123;</span><br><span class="line">                        success = false;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                else &#123;</span><br><span class="line">                    syccess = flase;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        int x      = 0;</span><br><span class="line">        int row    = 0;</span><br><span class="line">        int column = 0;</span><br><span class="line">        </span><br><span class="line">        while(x &lt; comSize)&#123;</span><br><span class="line">            grid[coords[x]] == 1;</span><br><span class="line">            row = (int) (coords[x] / gridLength);</span><br><span class="line">            column = coords[x] % gridLength;</span><br><span class="line">            temp = String.valueOf(alphabet.charAt(column));</span><br><span class="line">            </span><br><span class="line">            alphaCells.add(temp.concat(Integer.toString(row)));</span><br><span class="line">            x++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return alphaCells;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>

<h2 id="4-API的包"><a href="#4-API的包" class="headerlink" title="4.API的包"></a>4.API的包</h2><p>1.在java的API中，类是被包装在包里的。<br><br>2.<strong>使用API中的类，必须知道它被放在哪一个包里面。</strong><br><br>3.必须指明类的完整名称——两种方法指定<br><br>&nbsp;&nbsp;&nbsp;&nbsp;a.<strong>IMPORT</strong><br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;放一个import述句在源文件的最前面<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import java.util.ArrayList;</span><br><span class="line">public class Myclass&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;b.<strong>TYPE</strong><br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在程序代码中打出全名<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">声明的时候</span><br><span class="line">java.util.ArrayList&lt;Dog&gt; list = new java.util.ArrayList&lt;Dog&gt;;</span><br><span class="line"></span><br><span class="line">用在参数的时候</span><br><span class="line">publish void go(java.util.ArrayList&lt;Dog&gt; list)&#123;&#125;;</span><br><span class="line"></span><br><span class="line">作为返回类型的时候</span><br><span class="line">java.util.ArrayList&lt;Dog&gt; foo() &#123;...&#125;</span><br></pre></td></tr></table></figure></p>
<hr>

<h2 id="5-查询API的方法"><a href="#5-查询API的方法" class="headerlink" title="5.查询API的方法"></a>5.查询API的方法</h2><p>1.查阅参考书<br>2.查阅<strong>HTML APL</strong>文档<br>&nbsp;&nbsp;&nbsp;&nbsp;登录java.sun.com进行查找</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/570911275/570911275.github.io/2019/05/25/java-认识java的API之使用java函数库小结/" data-id="cjzdf8znk003t44tnfo6emlkt" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java-基础/">java_基础</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/6/">&laquo; 上一页</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><span class="page-number current">7</span><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/8/">下一页 &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/javaEE-基础/">javaEE_基础</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/javaSSM-基础/">javaSSM_基础</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java-基础/">java_基础</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/javaEE-基础/" style="font-size: 20px;">javaEE_基础</a> <a href="/tags/javaSSM-基础/" style="font-size: 10px;">javaSSM_基础</a> <a href="/tags/java-基础/" style="font-size: 15px;">java_基础</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">八月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">七月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">六月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">五月 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/08/16/SQL总结/">(no title)</a>
          </li>
        
          <li>
            <a href="/2019/08/12/新文档123/">(no title)</a>
          </li>
        
          <li>
            <a href="/2019/08/03/新文档8080/">javaSSM之SpringMVC快速入门之中小结</a>
          </li>
        
          <li>
            <a href="/2019/08/03/javaSSM之SpringMVC快速入门之上小结/">javaSSM之SpringMVC快速入门之上小结</a>
          </li>
        
          <li>
            <a href="/2019/08/02/javaSSM之SpringMVC之Restful小结/">javaSSM之SpringMVC之Restful小结</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>
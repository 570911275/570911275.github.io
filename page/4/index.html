<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="https://github.com/570911275/570911275.github.io/page/4/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://github.com/570911275/570911275.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-java-数字与静态之下小结" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/05/31/java-数字与静态之下小结/" class="article-date">
  <time datetime="2019-05-31T14:52:33.000Z" itemprop="datePublished">2019-05-31</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/05/31/java-数字与静态之下小结/">java_数字与静态之下小结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="1-静态方法"><a href="#1-静态方法" class="headerlink" title="1.静态方法"></a>1.静态方法</h2><p>4.静态<strong>final</strong>常数<br><br>&nbsp;&nbsp;&nbsp;&nbsp;a.<strong>静态</strong>的<strong>final变量</strong>是<strong>常数</strong><br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//被标记为final的变量代表它一旦<strong>被初始化之后就不会改动了</strong>。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//命名惯例:<strong>全部都是大写字母以下划线分隔</strong><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static final double PI = 3.1415923</span><br><span class="line">关键词:</span><br><span class="line">public: 可供各方读取</span><br><span class="line">static: 静态,不需要Math的实例</span><br><span class="line">final : 不变值,因为圆周率是不变的</span><br></pre></td></tr></table></figure></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;b.静态<strong>final</strong>变量的<strong>初始化</strong><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1.声明的时候</span><br><span class="line">public class Foo&#123;</span><br><span class="line">    public static final int FOO_X = 25;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">2.在静态初始化程序中</span><br><span class="line">public class Bar&#123;</span><br><span class="line">    public static final double BAR_SIGN;</span><br><span class="line">    </span><br><span class="line">    static&#123;</span><br><span class="line">        BAR_SIGN = (double) Math.random();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;c.final的<strong>方法与类</strong><br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//final的<strong>方法</strong>代表<strong>不能覆盖掉该方法</strong><br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//final的<strong>类</strong>代表<strong>不能继承该类(即创建他的子类)</strong><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1.final的方法</span><br><span class="line">class Poof&#123;</span><br><span class="line">    final void calcWhuffie()&#123;</span><br><span class="line">        //该方法无法被覆盖</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">2.final的类</span><br><span class="line">final class MyMostPerfectClass&#123;</span><br><span class="line">    //不能被继承</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>

<h2 id="3-包装类型的方法-autoboxing"><a href="#3-包装类型的方法-autoboxing" class="headerlink" title="3.包装类型的方法(autoboxing)"></a>3.包装类型的方法(autoboxing)<br></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;a.<strong>primitive主数据类型</strong>的<strong>包装</strong>用的类<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;注意<strong>包装的类的名字不是</strong>完全和<strong>primitive主数据类型</strong>的名称<strong>相同</strong>。<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Boolean 布尔        Character 字符</span><br><span class="line">Byte    字节        Short     短整形</span><br><span class="line">Integer 整形        Long      长整形</span><br><span class="line">Float   单精度浮点  Double    双精度浮点</span><br><span class="line"></span><br><span class="line">包装值</span><br><span class="line">int i = 288;</span><br><span class="line">Integer iWrap = new Integer(i);</span><br><span class="line"></span><br><span class="line">解开包装</span><br><span class="line">int unWrapped - iWrap.intValue();</span><br></pre></td></tr></table></figure></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;b.包装的<strong>作用</strong><br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>autoboxing</strong>功能能够<strong>自动</strong>地将<strong>primitive</strong>主数据类型<strong>转换成包装过的对象</strong><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public void doNumsNewWay()&#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; listOfNumbers = new ArrayList&lt;Integer&gt;();</span><br><span class="line">    //创建Integer类型的ArrayList</span><br><span class="line">    listOfNumbers.add(3);</span><br><span class="line">    //直接加3</span><br><span class="line">    //虽然ArrayList没有add(int)这样的方法,但是编译器会自动帮用户包装</span><br><span class="line">    int num = listOfNumbers.get(0);</span><br><span class="line">    //编译器会自动接口Integer对象的包装,因此可以直接赋值给&quot;num&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;c.包装的<strong>运用</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">1.方法的参数</span><br><span class="line">//发给参数是某种包装类型,则可以传入相对应的primitive主数据类型。</span><br><span class="line">void takeNumber(Integer i)&#123;</span><br><span class="line">    //Integer对象与int数据类型皆可以作为参数传入</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">2.返回值</span><br><span class="line">//如果method声明返回某种primitive主数据类型</span><br><span class="line">//也可以返回兼容的primitive主数据类型或者该primitive主数据类型的包装类型</span><br><span class="line">int fiveNumber()&#123;</span><br><span class="line">    ...</span><br><span class="line">    return x;</span><br><span class="line">    //Integer对象和int数据类型皆可以作为返回值返回</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">3.boolean表达式</span><br><span class="line">//任何预期boolean值的位置都可以用求出boolean的表达式来代替</span><br><span class="line">//例如Boolean包装类型的引用或者&quot;4&gt;2&quot;</span><br><span class="line">if(bool)&#123;</span><br><span class="line">    System.out.println(&quot;true&quot;);</span><br><span class="line">    //boolean对象与boolean数据皆可以传入</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">4.数值运算</span><br><span class="line">//可以在使用primitive主数据类型作为运算子的操作中用包装类型类替换</span><br><span class="line">//这意味着可以对Integer的对象作递增运算</span><br><span class="line">Integer i = new Integer(42);</span><br><span class="line">i++;</span><br><span class="line">或者</span><br><span class="line">Integer j = new Integer(25);</span><br><span class="line">Integer k = j+3;</span><br><span class="line"></span><br><span class="line">5.赋值</span><br><span class="line">//可以将包装类型或primitive主数据类型赋给声明给相对应的包装或primitive主数据类型</span><br><span class="line">Double d = x;</span><br><span class="line">//Integer对象和int数据皆可作为&quot;x&quot;赋值给&quot;d&quot;</span><br></pre></td></tr></table></figure></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;4.包装的静态方法<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a.将<strong>String</strong>转换成<strong>primitive</strong>主数据类型<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String s = &quot;2&quot;;</span><br><span class="line">int    x = Integer.parseInt(s);</span><br><span class="line">double d = Double.parseDouble(&quot;40.24&quot;);</span><br><span class="line">//boolean不一样，并没有BooleanparseBpplean()</span><br><span class="line">boolean b = new Boolean(&quot;true&quot;).booleanValue();</span><br><span class="line">//Boolean的构造函数可以取用String来创建对象</span><br></pre></td></tr></table></figure></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b.将<strong>primitive</strong>主数据类型转换成<strong>String</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.将数字接上现有的String</span><br><span class="line">double b = 42.5;</span><br><span class="line">String doubleString = &quot; &quot;+d;</span><br><span class="line">2.使用静态方法</span><br><span class="line">double b = 42.5;</span><br><span class="line">String doubleString = Doouble.toString(d);</span><br></pre></td></tr></table></figure></p>
<hr>

<h2 id="2-格式化"><a href="#2-格式化" class="headerlink" title="2.格式化"></a>2.格式化</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;1.<strong>格式化</strong>的说明<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;格式化说明最多会有<strong>5个部分</strong>(<strong>不包括”%”符号</strong>)，下面”<strong>[]</strong>“中的内容都是<strong>可选项目</strong>，因此<strong>只有%与type是必要</strong>的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">%[argument number] [flags] [width] [.precision] type</span><br><span class="line">argument number:如果格式化的参数超过一个以上，可以在此处指定是哪一个</span><br><span class="line">flags:特定类型的特定选项，例如数字要加逗号或正负号</span><br><span class="line">width:最小的字符数，(这不是总数)输出可以超过此宽度，若不足则主动补0</span><br><span class="line">.precision:精确度</span><br></pre></td></tr></table></figure></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;2.<strong>日期</strong>的格式<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;数值与日期时间格式化的区别在于<strong>日期格式的类型是用”t”开头</strong>的<strong>两个字符</strong>表示<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">完整的日期与时间:%tc</span><br><span class="line">String.format(&quot;%tc&quot;,new Date());</span><br><span class="line"></span><br><span class="line">只有时间:%tr</span><br><span class="line">String.format(&quot;%tr&quot;,new Date());</span><br><span class="line"></span><br><span class="line">周、月、日:%tA %tB %td</span><br><span class="line">Date today = new Date();</span><br><span class="line">String.format(&quot;tA,%tB %td&quot;,today,today,today);</span><br><span class="line">//此处的&quot;,&quot;为直接输出的</span><br><span class="line">//输出为 Sunday, November 28</span><br><span class="line">//此种输入需要将Date对象传入3次</span><br><span class="line"></span><br><span class="line">同上但是使用&quot;&lt;&quot;，此时无需重复传参</span><br><span class="line">Date today = new Date();</span><br><span class="line">String.format(&quot;tA,%&lt;tB %&lt;td&quot;,today);</span><br><span class="line">//&quot;&lt;&quot;这个符号是告知程序重复利用之前用过的参数</span><br></pre></td></tr></table></figure></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;3.操作日期<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在2中使用<strong>java.util.Date</strong>来<strong>查询日期</strong>，现在使用<strong>java.util.Calendar</strong>来<strong>操作日期</strong>。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因为<strong>Calendar</strong>是一个<strong>抽象的类</strong>，使用只能用到他的<strong>具体子类</strong>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">取得继承过Calendar的对象:</span><br><span class="line">1.Calendar cal = new Calendar();</span><br><span class="line">//无法通过编译</span><br><span class="line"></span><br><span class="line">2.Calendar cal = Calendar.getInstance();</span><br><span class="line">//通过调用静态方法</span><br></pre></td></tr></table></figure></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;运用<strong>Calendar对象</strong>的几个概念<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a.<strong>字段会保存状态</strong>——Calendar对象使用许多<strong>字段</strong>来表示<strong>日期和时间</strong>。(用户可以读取和设定他的year或month字段)<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b.<strong>日期和时间可以运算</strong>——Calendar的方法可以使得用户对<strong>不同的字段</strong>做<strong>加法或减法的运算</strong>。(用户可以对month字段加一个月或者对year字段减去3年)<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c.<strong>日期和时间可以用millisecond来表示</strong>——Calendar可以<strong>将日期</strong>转换成<strong>微秒</strong>的表示法，或将<strong>微秒</strong>转换成<strong>日期</strong>。(用户可以<strong>执行精确的相对时间计算</strong>)<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Calendar c = Calendar.getInstance();</span><br><span class="line"></span><br><span class="line">c.set(2004,1,7,15,40);</span><br><span class="line">//蛇精睡觉为2004年1月7日15:40</span><br><span class="line"></span><br><span class="line">long day1 = c.getTimeInMillis();</span><br><span class="line">//讲时间转换成用millisecond微秒来表示</span><br><span class="line"></span><br><span class="line">day1 += 1000*60*60;</span><br><span class="line">//将时间将上一个小时</span><br><span class="line"></span><br><span class="line">c.setTimeInMillis(day1);</span><br><span class="line">//将微秒转换成日期</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;new hour&quot; + c.get(c.HOUR_OF_DAY));</span><br><span class="line">//打印出时间</span><br><span class="line"></span><br><span class="line">c.add(c.DATE, 35);</span><br><span class="line">//加上35天，所以此时的月份变为了2月</span><br><span class="line"></span><br><span class="line">c.roll(c.DATE, 35);</span><br><span class="line">//滚动35天，此时只有日期改变，月份不改变</span><br><span class="line"></span><br><span class="line">c.set(c.DATE, 1);</span><br><span class="line">//直接设定DATE的值</span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/570911275/570911275.github.io/2019/05/31/java-数字与静态之下小结/" data-id="cjye872ks001g1otnycanszzt" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java-基础/">java_基础</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-java-数字与静态之上小结" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/05/30/java-数字与静态之上小结/" class="article-date">
  <time datetime="2019-05-30T14:45:41.000Z" itemprop="datePublished">2019-05-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/05/30/java-数字与静态之上小结/">java_数字与静态之上小结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="1-Math的方法"><a href="#1-Math的方法" class="headerlink" title="1.Math的方法"></a>1.Math的方法</h2><p>1.Math这个类中<strong>所有的方法</strong>都不需要实例变量值。因为这些方法都是<strong>静态</strong>的,所有<strong>无需Math的实例</strong>。只会用到他的<strong>类</strong>本身。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int x = Math.round(42.2);</span><br><span class="line">int y = Math.min(56,12);</span><br></pre></td></tr></table></figure></p>
<p>2.Math的方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Math.random()</span><br><span class="line">//返回介于0.0~1.0之间的双精度浮点数</span><br><span class="line">double r1 = Math.random();</span><br><span class="line">int r2 = (int) (Math.random() * 5);</span><br><span class="line"></span><br><span class="line">Math.abs()</span><br><span class="line">//返回双精度浮点类型参数的绝对值。</span><br><span class="line">//这个方法有覆盖的版本,传入整数会返回整数,传入双精度浮点数会返回双精度浮点数。</span><br><span class="line">int x = Math.abs(-24); //返回24</span><br><span class="line">double d = Math.abs(240.25); //返回240.25</span><br><span class="line"></span><br><span class="line">Math.min()</span><br><span class="line">//返回两个精度中较小的那一个</span><br><span class="line">//这个有int,long,float或double的覆盖版本</span><br><span class="line">int x = Math.min(24,240); //返回24</span><br><span class="line">double y = Math.min(982.25,654.32); //返回982.25</span><br><span class="line"></span><br><span class="line">Math.max()</span><br><span class="line">//返回两个精度中较大的一个</span><br><span class="line">//同Math.min()一致</span><br></pre></td></tr></table></figure></p>
<hr>

<h2 id="2-静态方法"><a href="#2-静态方法" class="headerlink" title="2.静态方法"></a>2.静态方法</h2><p>1.非静态方法与静态方法的差别<br><br>&nbsp;&nbsp;&nbsp;&nbsp;a.”<strong>static</strong>“这个关键词可以标记出<strong>不需类实例</strong>的方法。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;b.一个静态方法代表说<strong>一种不依靠实例变量</strong>也就<strong>不需要对象</strong>的行为。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//静态方法中<strong>绝对没有对象</strong>。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;c.区别:<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;静态方法:<strong>不依靠实例变量</strong><br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;非静态方法:<strong>实例变量</strong>的值会<strong>影响到方法</strong>的行为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">非静态方法:</span><br><span class="line">public class Song&#123;</span><br><span class="line">    String title;</span><br><span class="line">    //实例变量将影响方法的行为</span><br><span class="line">    public Song(String t)&#123;</span><br><span class="line">        title = t;</span><br><span class="line">    &#125;</span><br><span class="line">    public void play()&#123;</span><br><span class="line">        SoundPlayer player = new SoundPlayer();</span><br><span class="line">        player.playSound(title);</span><br><span class="line">        //&quot;title&quot;的值会决定&quot;play()&quot;的行为</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">静态方法:</span><br><span class="line">public static int min(int a,int b)&#123;</span><br><span class="line">    //返回a与b之间较小的值</span><br><span class="line">    //没有实例变量</span><br><span class="line">    //没有对象</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>2.静态方法的调用<br><br>&nbsp;&nbsp;&nbsp;&nbsp;a.以<strong>类的名称</strong>调用<strong>静态的方法</strong><br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Math.min(86,88);</code><br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//虽然可以用引用变量的名称调用静态方法但是<strong>不建议</strong>使用。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;b.以<strong>引用变量的名称</strong>调用<strong>非静态的方法</strong><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Song t2 = new Song();</span><br><span class="line">t2.play();</span><br></pre></td></tr></table></figure></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;c.静态方法<strong>不能调用</strong>非静态的变量:<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>静态方法</strong>是在<strong>无关特定特定类</strong>的实例情况下执行的。甚至<strong>不会有该类的实例</strong>出现。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因为<strong>静态方法是通过类的名称</strong>调用的,所以静态方法<strong>无法引用</strong>到该类的<strong>任何实例变量</strong>。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;所以静态方法<strong>无法识别</strong>可以使用哪一个实例变量。<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class Duck&#123;</span><br><span class="line">    private int size;</span><br><span class="line">    </span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        System.out.println(&quot;Size of duck is &quot; + size);</span><br><span class="line">        //此刻静态方法&quot;main()&quot;无法得知堆上是否有Duck</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void setSize(int s)&#123;</span><br><span class="line">        size = s;</span><br><span class="line">    &#125;</span><br><span class="line">    public int getSize()&#123;</span><br><span class="line">        return size;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;d.静态方法<strong>不能调用</strong>非静态方法<br><br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;非静态方法同上是<strong>以实例变量的状态</strong>来影响该<strong>方法</strong>的行为。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;同上方c同理<strong>静态方法无法识别</strong>是哪一个实例变量。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//即便非静态方法中<strong>无使用到实例变量</strong>也<strong>无法</strong>通过编译。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//因为<strong>无法确保</strong>之后是否会将非静态方法<strong>改为需要</strong>实例变量的。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//亦或者是无法保证不发生<strong>子类去覆盖</strong>这个方法成有用到实例变量的版本。<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class Duck&#123;</span><br><span class="line">    private int size;</span><br><span class="line">    </span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        System.out.println(&quot;Size of duck is &quot; + getSize());</span><br><span class="line">        //同c一样此刻静态方法&quot;main()&quot;无法识别需要的是哪一个实例变量</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void setSize(int s)&#123;</span><br><span class="line">        size = s;</span><br><span class="line">    &#125;</span><br><span class="line">    public int getSize()&#123;</span><br><span class="line">        return size;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>3.静态变量<br><br>静态变量对<strong>所有的实例</strong>来说都相同。<br><br>静态变量是<strong>共享的</strong>。<br><br><strong>同一个类</strong>所有的实例变量<strong>共享一份静态变量</strong>。<br><br>实例变量:每个<strong>实例</strong>一个。<br><br>静态变量:每个<strong>类</strong>一个。<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">在构造函数中增加静态变量</span><br><span class="line">class Duck&#123;</span><br><span class="line">    int duckCount = 0;</span><br><span class="line">    public Duck()&#123;</span><br><span class="line">        duckCount++;</span><br><span class="line">        //这无法在创建Duck对象的时候执行递增</span><br><span class="line">        //因为duckCount是一个实例变量</span><br><span class="line">        //所以每个Duck在初始化的时候duckCount的值都是0</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Duck&#123;</span><br><span class="line">    private int size; </span><br><span class="line">    private static int duckCount = 0;</span><br><span class="line">    //静态变量&quot;duckCount&quot;只有在类第一次载入的时候被初始化</span><br><span class="line">    </span><br><span class="line">    public Duck()&#123;</span><br><span class="line">        duckCount++;</span><br><span class="line">        //每当构造函数执行的时候</span><br><span class="line">        //这个值就会递增</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void setSize(int s)&#123;</span><br><span class="line">        size = s;</span><br><span class="line">    &#125;</span><br><span class="line">    public int getSize()&#123;</span><br><span class="line">        return size;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>静态变量会在该类的<strong>任何对象</strong>创建之前就完成初始化。<br>静态变量会在该类<strong>任何静态方法</strong>执行之前就初始化。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Player&#123;</span><br><span class="line">    static int palyerCount = 0;</span><br><span class="line">    private String name;</span><br><span class="line">    public Player(String n)&#123;</span><br><span class="line">        name = n;</span><br><span class="line">        playerCount++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public calss PlayerTestDrive&#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        System.out.println(Player.playerCount);</span><br><span class="line">        Player one = new Player(&quot;Tiger Woods&quot;);</span><br><span class="line">        Systrm.out.println(Player.playerCount);</span><br><span class="line">        //静态变量通过类的名称来存取</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出为:</span><br><span class="line">0    //实例创建之前</span><br><span class="line">1    //对象创建之后</span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/570911275/570911275.github.io/2019/05/30/java-数字与静态之上小结/" data-id="cjye872kw001i1otnneesga81" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java-基础/">java_基础</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-java-构造器与垃圾回收器之垃圾回收器小结" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/05/29/java-构造器与垃圾回收器之垃圾回收器小结/" class="article-date">
  <time datetime="2019-05-29T15:34:46.000Z" itemprop="datePublished">2019-05-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/05/29/java-构造器与垃圾回收器之垃圾回收器小结/">java_构造器与垃圾回收器之垃圾回收器小结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h2><p>1.引用永久性的离开他的返回<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class StackRef&#123;</span><br><span class="line">    public void foof()&#123;</span><br><span class="line">    //foof()处于栈上,无声明变量</span><br><span class="line">        barf();</span><br><span class="line">    //barf()处于栈上</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void barf()&#123;</span><br><span class="line">        Duck d = new Duck();</span><br><span class="line">    //创建一个对象以及他的引用</span><br><span class="line">    //barf()执行完毕</span><br><span class="line">    //引用彻底的离开</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>2.引用被赋值到其他的对象上<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pubilc class ReRef&#123;</span><br><span class="line">    Duck d = new Duck();</span><br><span class="line">    //创建一个对象以及他的引用&quot;d&quot;</span><br><span class="line">    </span><br><span class="line">    public void go()&#123;</span><br><span class="line">        d = new Duck();</span><br><span class="line">    //引用&quot;d&quot;被赋值给新的Duck对象</span><br><span class="line">    //原先的Duck对象无引用所以死亡</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>3.直接将引用设定成null<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class ReRef&#123;</span><br><span class="line">    Duck d = new Duck();</span><br><span class="line">    //创建一个对象以及他的引用&quot;d&quot;</span><br><span class="line">    </span><br><span class="line">    public void go()&#123;</span><br><span class="line">        d = null;</span><br><span class="line">    //引用&quot;d&quot;被赋值为null</span><br><span class="line">    //原先的Duck对象无引用死亡</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/570911275/570911275.github.io/2019/05/29/java-构造器与垃圾回收器之垃圾回收器小结/" data-id="cjye872le001m1otn1wq25efq" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java-基础/">java_基础</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-java-构造器与垃圾回收器之构造器小结" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/05/28/java-构造器与垃圾回收器之构造器小结/" class="article-date">
  <time datetime="2019-05-28T15:32:38.000Z" itemprop="datePublished">2019-05-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/05/28/java-构造器与垃圾回收器之构造器小结/">java_构造器与垃圾回收器之构造器小结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="1-栈与堆-生存空间"><a href="#1-栈与堆-生存空间" class="headerlink" title="1.栈与堆:生存空间"></a>1.栈与堆:生存空间</h2><p>1.堆与栈的基本概念<br><br>堆:<strong>对象</strong>的生存空间堆<br><br>&nbsp;&nbsp;&nbsp;&nbsp;//<strong>实例变量</strong>是被<strong>声明在类</strong>而不是方法里面。它们代表的每个独立对象的”字段”。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;//<strong>实例变量</strong>存在于<strong>所属的对象</strong>中。<br><br>栈:<strong>方法调用</strong>及<strong>局部变量</strong>的生存空间<br><br>&nbsp;&nbsp;&nbsp;&nbsp;//<strong>局部变量</strong>和<strong>方法的参数</strong>是被<strong>声明在方法</strong>中。它们是<strong>暂时的</strong>。<br>&nbsp;&nbsp;&nbsp;&nbsp;//其<strong>生命周期</strong>只限于<strong>方法被放在栈上</strong>的这段时间。<br><br><br>2.栈上的<strong>对象引用</strong><br><br>非primitive的变量只是<strong>保存对象的引用</strong>。而不是对象的本身,<br><br>如果<strong>局部变量</strong>是个对该<strong>对象的引用</strong>,<strong>只有变量本身会被放在栈上，对象本身只会存在堆上。</strong><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class StackRef&#123;</span><br><span class="line">    public void foof()&#123;</span><br><span class="line">        barf();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void barf()&#123;</span><br><span class="line">        Duck d = new Duck();</span><br><span class="line">        //其中&quot;d&quot;这个局部变量是存在于栈上的。</span><br><span class="line">        //&quot;Duck&quot;这个对象是存在于堆上。</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>

<h2 id="2-构造函数"><a href="#2-构造函数" class="headerlink" title="2.构造函数"></a>2.构造函数</h2><p>1.对象的<strong>声明</strong>与<strong>赋值</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.声明引用变量</span><br><span class="line">&quot;Duck myDuck&quot; = new Duck();</span><br><span class="line">2.创建对象</span><br><span class="line">Duck myDuck = &quot;new Duck()&quot;;</span><br><span class="line">//构造函数就在这一步进行操作</span><br><span class="line">3.连接对象与引用</span><br><span class="line">Duck myDuck &quot;=&quot; new Duck();</span><br></pre></td></tr></table></figure></p>
<p>2.构造函数的<strong>调用</strong><br><br><code>Duck myDuck = &quot;new Duck()&quot;;</code><br><br>这一步调用了Duck的<strong>构造函数</strong>。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;a.在用户<strong>没有编写构造函数</strong>的情况下,编译器将会<strong>自动编写</strong>。<br>&nbsp;&nbsp;&nbsp;&nbsp;b.<strong>唯一</strong>能够在<strong>构造函数之外调用构造函数</strong>的方式为–新建一个类**。<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">在用户无编写构造函数的情况下,系统自行编写的构造函数</span><br><span class="line">public Duck()&#123;</span><br><span class="line">    //其中构造函数的名称必须与类的名称相同</span><br><span class="line">    //与方法区别的一点为:</span><br><span class="line">    //方法有返回类型,构造函数没有返回类型</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>3.构造函数的<strong>意义</strong><br><br>构造函数:会在对象能够<strong>被赋值给引用之前</strong>就执行。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;//这意味着用户有机会在对象<strong>被使用之前</strong>介入。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;//使得用户在构造过程的步骤中<strong>加入一些操作</strong>。<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Duck&#123;</span><br><span class="line">    public Duck()&#123;</span><br><span class="line">        System.out.println(&quot;Quack&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class UseADuck&#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        Duck d = new Duck();</span><br><span class="line">        //启动Duck的构造函数</span><br><span class="line">        //此处输出Quack</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>4.构造函数的<strong>参数</strong><br><br>&nbsp;&nbsp;&nbsp;&nbsp;a.使用构造函数来初始化对象的状态。(即设置和给对象的实例变量赋值)<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//讲构造函数设定成需要参数的。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;b.一定要有不需要参数的构造函数。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//使得用户在创建对象的时候有两个选择:<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//1.可以初始化对象的状态(通过构造函数的参数)<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//2.使用默认值无需初始化<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">构造函数含参数时:</span><br><span class="line">public class Duck&#123;</span><br><span class="line">    int size;</span><br><span class="line">    </span><br><span class="line">    public Duck(int duckSize)&#123;</span><br><span class="line">        System.out.println(&quot;Quack&quot;);</span><br><span class="line">        </span><br><span class="line">        size = duckSize;</span><br><span class="line">        </span><br><span class="line">        System.out.println(&quot;size is &quot; + size);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class UseADuck&#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        Duck d = new Duck(2);</span><br><span class="line">        //此处传值给构造函数</span><br><span class="line">        //此处输出</span><br><span class="line">        //       Quack </span><br><span class="line">        //       size is 2</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>5.构造函数的<strong>重载</strong><br><br>1.如果一个类有了<strong>一个以上</strong>的构造函数,则<strong>参数</strong>一定要<strong>不一样</strong>。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;a.包括了<strong>参数的顺序</strong>与<strong>类型</strong>。只要<strong>不一样</strong>即可。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;b.编译器查看的是<strong>参数的类型</strong>和<strong>顺序</strong>而不是参数的名字。<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public clas Mushroom&#123;</span><br><span class="line">    public Mushroom(int size) &#123;&#125;</span><br><span class="line">    //只含有一个参数</span><br><span class="line">    </span><br><span class="line">    public Mushroom() &#123;&#125;</span><br><span class="line">    //无参数类型</span><br><span class="line">    </span><br><span class="line">    public Mushroom(boolean isMagic) &#123;&#125;</span><br><span class="line">    //只含有一个参数(参数类型发生改变)</span><br><span class="line">    </span><br><span class="line">    public Mushroom(boolean isMagic, int size) &#123;&#125;</span><br><span class="line">    public Mushroom(int size, boolean isMagic) &#123;&#125;</span><br><span class="line">    //顺序不同通过编译</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>6.调用<strong>父类</strong>的构造函数<br><br>唯一调用父类构造函数的方法是调用super()<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Duck extends Animal&#123;</span><br><span class="line">    int size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Duck(int newSize)&#123;</span><br><span class="line">    super();</span><br><span class="line">    size = newSize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/570911275/570911275.github.io/2019/05/28/java-构造器与垃圾回收器之构造器小结/" data-id="cjye872lk001o1otnebmsmxbo" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java-基础/">java_基础</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-java-接口与抽象类小结" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/05/27/java-接口与抽象类小结/" class="article-date">
  <time datetime="2019-05-27T15:01:14.000Z" itemprop="datePublished">2019-05-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/05/27/java-接口与抽象类小结/">java_接口与抽象类小结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="1-抽象类与具体类"><a href="#1-抽象类与具体类" class="headerlink" title="1.抽象类与具体类"></a>1.抽象类与具体类</h2><p>1.<strong>抽象类</strong><br><br>&nbsp;&nbsp;&nbsp;&nbsp;a.有些类不该被<strong>初始化</strong>,则通过<strong>标记类为抽象类</strong>。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//抽象类仍可以作为<strong>引用类型</strong>。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//抽象类<strong>不可被初始化</strong>。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;b.抽象类<strong>除了被继承过</strong>之外,是<strong>没有用途</strong>、<strong>没有值</strong>、<strong>没有目的</strong>的。<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">abstract public class Canine extends Animal</span><br><span class="line">&#123;</span><br><span class="line">    //定义一个抽象类&quot;Canine&quot;;</span><br><span class="line">    public void roam();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class MakeCanine&#123;</span><br><span class="line">    public void go()&#123;</span><br><span class="line">        Canine c;</span><br><span class="line">        c = new Dog;</span><br><span class="line">        //此处是可以通过编译器的;</span><br><span class="line">        //因为可以赋值子类对象给父类的引用&quot;c&quot;。即使该父类&quot;Canine&quot;为抽象的。</span><br><span class="line">        c = new Canine();</span><br><span class="line">        //此处是不可以通过编译器的;</span><br><span class="line">        //因为这个类&quot;Canine&quot;已经被标记为抽象的了。不可以被初始化</span><br><span class="line">        c.roam();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>2.<strong>具体类</strong><br><br>不是抽象的类,就是<strong>具体类</strong><br></p>
<hr>

<h2 id="2-抽象的方法"><a href="#2-抽象的方法" class="headerlink" title="2.抽象的方法"></a>2.抽象的方法</h2><p>1.除了类之外,也可以将<strong>方法</strong>标记为”<strong>abstract</strong>“。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;a.<strong>抽象的类</strong>代表此类<strong>必须要被继承”extend”过</strong>。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;b.<strong>抽象的方法</strong>代表此方法<strong>必须要被覆盖过</strong>。<br><br><br>2.抽象的方法<strong>没有实体</strong><br><br>&nbsp;&nbsp;&nbsp;&nbsp;//因为抽象的方法<strong>必须要被覆盖</strong>,所以编写出抽象方法的代码<strong>没有意义</strong>(即不会含有方法在其中)。<br><br><br>3.抽象的方法<strong>所在的类</strong>必须为<strong>抽象</strong>的<br><br>&nbsp;&nbsp;&nbsp;&nbsp;//就算<strong>只有一个</strong>方法是抽象的,该类也必须为<strong>抽象类</strong>。<br><br>4.抽象方法的<strong>意义</strong><br><br>&nbsp;&nbsp;&nbsp;&nbsp;a.抽象的意义在于:就算无法实现出方法的的内容，但是还可以定义出一组<strong>子型共同的协议</strong><br><br>&nbsp;&nbsp;&nbsp;&nbsp;b.好处:利于多态。这样所有的子型都会有那些抽象的方法。<br><br><br>5.抽象方法的<strong>要求</strong><br><br>&nbsp;&nbsp;&nbsp;&nbsp;a.<strong><em>第一个具体类</em></strong>必须实现<strong>所有</strong>的<strong>抽象方法</strong>。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//必须实现所有的方法:表示必须<strong>写出内容</strong>,必须以<strong>相同的方法</strong>鉴名(<strong>名称</strong>和<strong>参数</strong>)和<strong>相容的返回类型</strong>创建出<strong>非抽象的方法</strong>。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;b.抽象类可以带有<strong>抽象</strong>的和<strong>非抽象</strong>的方法。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//这表示抽象类可以<strong>实现部分抽象方法</strong>,这样<strong>第一个具体类</strong>就可以<strong>不必去实现</strong>这一部分。<br></p>
<hr>

<h2 id="3-对象之母——Object"><a href="#3-对象之母——Object" class="headerlink" title="3.对象之母——Object"></a>3.对象之母——Object</h2><p>1.<strong>在java中所有的类都是从Object这个类继承出来的</strong>。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;a.<strong>Object</strong>是<strong>所有类的源头</strong>,他是<strong>所有类的父类</strong>。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;b.如果java中<strong>没有共同的父类</strong>,讲<strong>无法创建</strong>出可以处理<strong>自定义类型的类</strong>(即无法写出如同<strong>ArrayList</strong>这样可以<strong>处理各种类的类</strong>)。<br><br><br>2.<strong>没有继承</strong>过其他类的类会是<strong>隐含的继承对象</strong><br><br>&nbsp;&nbsp;&nbsp;&nbsp;//如同”Dog”这个类<strong>没有直接继承”extend”对象”Object”</strong>,但是还是会<strong>通过”Dog”的父类</strong>“Animal”来<strong>继承对象”Object”</strong>。<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">关于上述1——b的ArrayList</span><br><span class="line">ArrayList:</span><br><span class="line">boolean remove(Object elem)</span><br><span class="line">//根据索引参数移动对象,如果list中没有元素返回true。</span><br><span class="line"></span><br><span class="line">boolean contains(Object elem)</span><br><span class="line">//如果和对象的参数相匹配的话返回true</span><br><span class="line"></span><br><span class="line">int indexOf(Object elem)</span><br><span class="line">//返回对象参数的索引或-1</span><br><span class="line"></span><br><span class="line">由上述例子可知,许多的ArrayList的方法都用到了Object这个终极类型。</span><br><span class="line">因为每个类都是对象&quot;Object&quot;的子类,所以ArrayList可以处理任何类。</span><br></pre></td></tr></table></figure></p>
<p>3.<strong>Object中的方法</strong>(部分)<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">1.equals(Object o) 判断是否相等</span><br><span class="line">eg:</span><br><span class="line">Dog d = new Dog();</span><br><span class="line">Cat c = new Cat();</span><br><span class="line">if(d.equals(c))&#123;</span><br><span class="line">    System.out.println(&quot;true&quot;);</span><br><span class="line">&#125;else&#123;</span><br><span class="line">    System.out.println(&quot;false&quot;);</span><br><span class="line">&#125;</span><br><span class="line">//此处打印出&quot;flase&quot;</span><br><span class="line"></span><br><span class="line">2.getClass() 告知用户对象是从哪里被初始化的</span><br><span class="line">eg:</span><br><span class="line">Cat c = new Cat();</span><br><span class="line">Systrm.out.println(c.getClass())</span><br><span class="line">//此处打印出&quot;class Cat&quot;</span><br><span class="line"></span><br><span class="line">3.hashCode() 列出此对象的哈希代码(如同唯一的ID)</span><br><span class="line">eg:</span><br><span class="line">Cat c = new Cat();</span><br><span class="line">Systrm.out.println(c.hashCode())</span><br><span class="line">//此处打印出&quot;8202111&quot;</span><br><span class="line"></span><br><span class="line">4.toString() 列出类的名称和一串数字</span><br><span class="line">eg:</span><br><span class="line">Cat c = new Cat();</span><br><span class="line">Systrm.out.println(c.toString())</span><br><span class="line">//此处打印出&quot;Cat@7d277f&quot;</span><br></pre></td></tr></table></figure></p>
<p>4.使用<strong>Object类型的多态引用</strong>的后果<br><br>&nbsp;&nbsp;&nbsp;&nbsp;a.此处<strong>不涉及</strong>制作出<strong>Object类型的实例</strong>。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;b.任何<strong>被Object类型的引用变量</strong>所引用的对象,将被编译器认为为<strong>Object类型</strong>。<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">正常的:</span><br><span class="line">ArrayList&lt;Dog&gt; myDogArrayList = new ArrayList&lt;Dog&gt;();</span><br><span class="line">//保存Dog的Arraylist</span><br><span class="line">Dog aDog = new Dog();</span><br><span class="line">//新建一个Dog</span><br><span class="line">myDogArrayList.add(aDog);</span><br><span class="line">//将aDog放入ArrayList中</span><br><span class="line">Dog d = myDogArrayList.get(0);</span><br><span class="line">//讲Dog赋值给新的Dog引用变量</span><br><span class="line"></span><br><span class="line">Object类型的引用变量下:</span><br><span class="line">ArrayList&lt;Object&gt; myDogArrayList = new ArrayList&lt;Object&gt;();</span><br><span class="line">//保存Object的Arraylist</span><br><span class="line">Dog aDog = new Dog();</span><br><span class="line">//新建一个Dog</span><br><span class="line">myDogArrayList.add(aDog);</span><br><span class="line">//将aDog放入ArrayList中</span><br><span class="line">Dog d = myDogArrayList.get(0);</span><br><span class="line">//此处无法通过编译器</span><br><span class="line">//因为对ArrayList&lt;Object&gt;调用get()方法会返回Object类型</span><br><span class="line">//编译器无法确认它为Dog</span><br><span class="line">//即任何从ArrayList&lt;Object&gt;中取出的Object都会被当做是Object这个类的实例。</span><br></pre></td></tr></table></figure></p>
<hr>

<h2 id="4-引用类型"><a href="#4-引用类型" class="headerlink" title="4.引用类型"></a>4.引用类型</h2><p>1.从上述3——4——b中可以得知当<strong>引用类型改变</strong>时,编译器将<strong>无法识别原先的类型</strong>。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;//即引用仍为<strong>同一个引用</strong>,但是<strong>引用类型</strong>已经发生了<strong>改变</strong>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">3——4——b的修改方法:</span><br><span class="line">ArrayList&lt;Object&gt; myDogArrayList = new ArrayList&lt;Object&gt;();</span><br><span class="line">Dog aDog = new Dog();</span><br><span class="line">myDogArrayList.add(aDog);</span><br><span class="line">Object d = myDogArrayList.get(0);</span><br><span class="line">//这样则可以通过编译</span><br></pre></td></tr></table></figure></p>
<p>2.编译器是<strong>根据引用类型</strong>来<strong>判断</strong>有<strong>哪些方法”method”可以调用</strong>的,而<strong>不是根据</strong>Object<strong>确实的类型</strong>。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;//即便用户知道对象有这个功能,但是编译器只会把他当成<strong>一般的Object</strong>来看待。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;//即他只能调用<strong>Object内所含有的方法</strong>。编译器只管<strong>引用的类型</strong>,而<strong>不是对象的类型</strong>。<br></p>
<hr>

<h2 id="5-对象类型的装换"><a href="#5-对象类型的装换" class="headerlink" title="5.对象类型的装换"></a>5.对象类型的装换</h2><p>1.<strong>可以确认</strong>该变量为什么类型,并且<strong>希望调用该变量本身类型的方法</strong>。则可以将其<strong>声明</strong>为<strong>该变量本身类型</strong>。<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Object o = al.get(index);</span><br><span class="line">Dog d = (Dog) o ;</span><br><span class="line">//o本身类型为Dog的情况下</span><br><span class="line">//可以通过此方式进行类型转换</span><br><span class="line">d.roam();</span><br></pre></td></tr></table></figure></p>
<p>2.<strong>无法确认</strong>变量类型时,可以通过使用<strong>“instanceof”</strong>这个<strong>运算符</strong>来<strong>进行检查</strong>。如果类型转换错误,则在执行期将遇到<strong>“ClassCastException”异常</strong>并且<strong>终止</strong>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if(o instanceof Dog)&#123;</span><br><span class="line">    Dog d = (Dog) o ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>

<h2 id="6-接口"><a href="#6-接口" class="headerlink" title="6.接口"></a>6.接口</h2><p>1.接口的<strong>定义与实现</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">接口的定义:</span><br><span class="line">public interface Pet&#123;...&#125;</span><br><span class="line">//使用&quot;interface&quot;来代替&quot;class&quot;</span><br><span class="line"></span><br><span class="line">接口的实现:</span><br><span class="line">public class Dog extends Canine impements Pet&#123;...&#125;</span><br><span class="line">//使用&quot;implements&quot;这个关键词</span><br></pre></td></tr></table></figure></p>
<p>2.接口中的<strong>方法</strong><br><br>接口中<strong>全部的</strong>方法都是<strong>抽象的</strong>。<br><br>这样子类则必须实现此方法。可解决”致命方块”问题。<br><br>3.接口的<strong>意义</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;a.<strong>利于多态</strong>,接口具有<strong>无比的适用性</strong>。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//使用接口取代<strong>具体的子类</strong>或<strong>抽象的父类</strong>作为<strong>参数或返回类型</strong>。则可以<strong>传入任何</strong>有<strong>实现该接口</strong>的东西。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;b.继承<strong>超过一个以上</strong>的来源<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//使用接口的情况下,类有<strong>继承”extend”过某个父类</strong>并且<strong>实现其他的接口</strong>。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//同时<strong>其他的类</strong>也可以实现<strong>同一个接口</strong>。<br><br><br>4.<strong>不同继承树的类</strong>也可以实现<strong>相同的接口</strong><br><br>&nbsp;&nbsp;&nbsp;&nbsp;a.当把一个<strong>类</strong>作为<strong>多态类型</strong>运用时,<strong>相同的类型</strong>必定来自<strong>同一个继承树</strong>。并且为<strong>该多态类型的子类</strong>。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;b.当把<strong>接口</strong>作为<strong>多态类型</strong>运用时,对象就可以来自<strong>任何的地方</strong>了。<strong>唯一的条件是该对象必须是来自有实现此接口的类</strong>。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;c.类可以实现<strong>多个接口</strong><br><br><code>public class Dog extends Animal implements Pet, Saveable, paintable{...}</code><br><br><br>5.<strong>设计类</strong>、<strong>子类</strong>、<strong>抽象类</strong>、<strong>接口</strong>的判断<br><br>&nbsp;&nbsp;&nbsp;&nbsp;a.如果新的类无法对其他的类通过IS-A的测试时,就设计不继承其他类的类。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;b.只有在需要某类的特殊版本时,以覆盖或增加新的方法来继承现有的类。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;c.当你需要定义一群子类的模版,又不想让程序初始化此模版时,设计出抽象的类给。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;d.如果想要定义出类可以扮演的角色,使用接口。<br></p>
<hr>

<h2 id="7-调用父类的方法"><a href="#7-调用父类的方法" class="headerlink" title="7.调用父类的方法"></a>7.调用父类的方法</h2><p>当想要调用父类中的方法时,可以使用<strong>“super”</strong>这个关键词在<strong>子类中调用父类</strong>的方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">abstract class Report&#123;</span><br><span class="line">    void runReport()&#123;</span><br><span class="line">        //设置报告</span><br><span class="line">    &#125;</span><br><span class="line">    void printReport()&#123;</span><br><span class="line">        //输出</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class BuzzwordsReport extends Report&#123;</span><br><span class="line">    void runReport()&#123;</span><br><span class="line">        super.runReport();</span><br><span class="line">        //调用父类的方法</span><br><span class="line">        buzzwordCompliance();</span><br><span class="line">        printReport();</span><br><span class="line">    &#125;</span><br><span class="line">    void buzzwordCompliance()&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/570911275/570911275.github.io/2019/05/27/java-接口与抽象类小结/" data-id="cjye872o2002d1otn0mh1bcwu" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java-基础/">java_基础</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-java-继承与多态小结" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/05/26/java-继承与多态小结/" class="article-date">
  <time datetime="2019-05-26T11:00:07.000Z" itemprop="datePublished">2019-05-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/05/26/java-继承与多态小结/">java_继承与多态小结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="1-继承的设计"><a href="#1-继承的设计" class="headerlink" title="1.继承的设计"></a>1.继承的设计</h2><p>1.找出Class中<strong>共有的部分</strong><br><br>2.提取出<strong>共有部分</strong>,并设计代表共同状态与行为的新的类<br><br>3.将原先的类以称为<strong>继承</strong>的关系连接到新的类上<br><br>//此时原先的类称为”<strong>子类</strong>“，新的类称为”<strong>父类</strong>“。<br><br>//子类会<strong>自动</strong>获得父类的<strong>功能</strong><br><br>4.决定子类是否需要让<strong>某些行为</strong>(也就是<strong>方法的实现</strong>)有特定的<strong>不同的</strong>运作方式<br><br>5.当子类与父类同一方法有所改变时，可进行<strong>覆盖</strong>。<strong>覆盖</strong>:由子类<strong>重新定义</strong>继承下来的方法以<strong>改变或延伸此方法的行为</strong>。<br><br>//此时<strong>调用对象引用的方法</strong>时,会调用到该对象类型<strong>最接近</strong>的方法<br><br>//(也就是先看本人有没有该方法，没有则找父亲有没有，再没有寻找他爷爷，逐级升高)</p>
<hr>

<h2 id="2-继承的运行方式"><a href="#2-继承的运行方式" class="headerlink" title="2.继承的运行方式"></a>2.继承的运行方式</h2><p>1.类的成员:实例变和方法<br><br>2.继承的关系意味着子类继承了父类的<strong>方法</strong><br><br>&nbsp;&nbsp;&nbsp;a.子类可以加入自己的<strong>实例变量和方法</strong>也可以覆盖掉来自父类的方法。<br><br>&nbsp;&nbsp;&nbsp;b.实例变量无法被覆盖的原因为:不需要。它们并没有定义特殊的行为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">父类:</span><br><span class="line">public class Doctor&#123;</span><br><span class="line">    boolean worksAtHospital;</span><br><span class="line">    void treatPatient()&#123;</span><br><span class="line">        //检查</span><br><span class="line">    &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">子类一:</span><br><span class="line">public class FamilyDoctor extends Doctor&#123;</span><br><span class="line">    boolean makesHouseCalls;</span><br><span class="line">    void giveAdvice();</span><br><span class="line">    //增加新的方法</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">子类二:</span><br><span class="line">public class Surgeon extends Doctor&#123;</span><br><span class="line">    void treatPaient() &#123;</span><br><span class="line">        //手术</span><br><span class="line">    &#125;;</span><br><span class="line">    //覆盖父类方法</span><br><span class="line">    </span><br><span class="line">    void makeIncision() &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>

<h2 id="3-继承设计的判断"><a href="#3-继承设计的判断" class="headerlink" title="3.继承设计的判断"></a>3.继承设计的判断</h2><p>1.IS-A:通过IS-A来判断某物是否一个继承另一物<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">三角形是一个多边形    T</span><br><span class="line">黄丫丫是一个人类      T</span><br><span class="line">苹果是香蕉            F</span><br><span class="line">水是水杯              F</span><br></pre></td></tr></table></figure></p>
<p>2.如果类X是继承类Y的,且类Y是继承类Z的,则X可以通过IS-A Z的测试。<br><br>//即继承具有传递性<br>3.<strong>继承概念下的IS-A是一个单向的概念</strong><br><br>&nbsp;&nbsp;&nbsp;&nbsp;三角形是一个多边形这个是符合的<br><br>&nbsp;&nbsp;&nbsp;&nbsp;多边形是一个三角形这个是不符合的<br></p>
<hr>

<h2 id="4-继承的权限限制"><a href="#4-继承的权限限制" class="headerlink" title="4.继承的权限限制"></a>4.继承的权限限制</h2><p>父类可以通过存取权限觉得子类是否能够继承某些特定的成员<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">以下4种权限:</span><br><span class="line">最限制  ————————&gt;  最公开</span><br><span class="line">private default protected public</span><br></pre></td></tr></table></figure></p>
<p>其中<strong>public</strong> 类型的成员会被继承<br><br><strong>private</strong> 类型的成员不会被继承<br></p>
<hr>

<h2 id="5-继承的意义"><a href="#5-继承的意义" class="headerlink" title="5.继承的意义"></a>5.继承的意义</h2><p>1.避免了<strong>重复的程序代码</strong><br><br>2.定义了<strong>共同的协议</strong><br><br>&nbsp;&nbsp;&nbsp;&nbsp;//共同协议:在父类中定义方法是,他们会被子类继承。这是在什么说所有继承的类都可以<br>执行这些方法，这里面也包括了<strong>方法的参数和返回类型</strong>。<br></p>
<hr>

<h2 id="6-多态与一般对象的区别"><a href="#6-多态与一般对象的区别" class="headerlink" title="6.多态与一般对象的区别"></a>6.多态与一般对象的区别</h2><p>1.一般的声明引用和创建对象的方法<br><br><code>Dog myDog = new Dog();</code><br><br>其中<strong>引用类型和对象类型必须相符</strong>,例子中两者都是Dog<br><br>2.多态下的声明引用和创建对象的方法<br><br><code>Animal myDog = new Dog();</code><br><br>其中<strong>多态下引用类型和对象类型可以不相符</strong>,例子中引用类型为Animal,对象类型为Dog。<br></p>
<hr>

<h2 id="7-多态的运用范围"><a href="#7-多态的运用范围" class="headerlink" title="7.多态的运用范围"></a>7.多态的运用范围</h2><p>1.运用多态时,引用类型可以是<strong>实际对象类的父类</strong>(即继承树上方的类可以引用下方的子类)<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Animal[] animals = new Animal[2];</span><br><span class="line"></span><br><span class="line">animals [0] = new Dog();</span><br><span class="line">animals [1] = new Cat();</span><br><span class="line">//可以用animal 引用任何Animal的子类对象</span><br><span class="line"></span><br><span class="line">for(int i=0; i&lt;animals.length; i++)&#123;</span><br><span class="line">    animals[i].eat();</span><br><span class="line">    //当i为0是会调用Dog的eat();</span><br><span class="line">    //当i为1是会调用Cat的eat();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>2.<strong>返回类型</strong>和<strong>参数</strong>也可以多态<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Vet&#123;</span><br><span class="line">    public void giveShot(Animal a)&#123;</span><br><span class="line">    //参数可以是任何一种Animal下面的子类的类型对象</span><br><span class="line">        a.makeNoise();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class PetOwner&#123;</span><br><span class="line">    public void start()&#123;</span><br><span class="line">        Vet v = new Vet();</span><br><span class="line">        Dog d = new Dog();</span><br><span class="line">        Hippo h = new Hippo();</span><br><span class="line">        v.giveShot(d);</span><br><span class="line">        //执行Dog的makeNoise方法</span><br><span class="line">        v.giveShot(h);</span><br><span class="line">        //执行Hippo的makeNoise方法</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>

<h2 id="8-覆盖的规则与方法的重载"><a href="#8-覆盖的规则与方法的重载" class="headerlink" title="8.覆盖的规则与方法的重载"></a>8.覆盖的规则与方法的重载</h2><p>1.覆盖的规则<br><br>&nbsp;&nbsp;&nbsp;&nbsp;a.<strong>参数</strong>必须<strong>一样</strong>，且<strong>返回类型必须兼容</strong>。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;父类中的方法使用了哪种参数,覆盖此方法的子类也一定要<strong>使用相同的参数</strong>。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;而无论父类中的方法声明的返回类型是什么,子类必须声明返回<strong>一样的类型</strong>或者<strong>该类型的子类</strong>。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;b.<strong>不能降低</strong>方法的<strong>存取权限</strong>(即权限必须相同,或者更加公开)<br><br><br><br>2.方法的重载<br><br>&nbsp;&nbsp;&nbsp;&nbsp;a.重载与多态毫无关系。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;重载可以有<strong>同一方法</strong>的<strong>多个不同参数版本</strong>以方便调用。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;重载只是刚好有<strong>相同名字的方法</strong>,它与多态和继承没有关系。<strong>重载的方法和覆盖的方法不一样</strong>。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;b.重载的返回类型可以不同<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以任意的<strong>改变</strong>重载方法的<strong>返回类型</strong>,只要所有的<strong>覆盖</strong>使用<strong>不同的参数</strong>即可。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;c.重载不能只改变返回类型<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果<strong>只有返回类型不同</strong>,<strong>参数是一样的</strong>。这样是无法通过编译的。重载的条件是<strong>使用不同的参数</strong>。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;d.重载可以<strong>更改存取权限</strong></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/570911275/570911275.github.io/2019/05/26/java-继承与多态小结/" data-id="cjye872lp001q1otnmm1rkhpq" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java-基础/">java_基础</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-java-认识java的API之使用java函数库小结" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/05/25/java-认识java的API之使用java函数库小结/" class="article-date">
  <time datetime="2019-05-25T14:39:01.000Z" itemprop="datePublished">2019-05-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/05/25/java-认识java的API之使用java函数库小结/">java_认识java的API之使用java函数库小结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="1-游戏bug修复方法"><a href="#1-游戏bug修复方法" class="headerlink" title="1.游戏bug修复方法"></a>1.游戏bug修复方法</h2><p>1.使用<strong>第二个数组</strong><br><br>&nbsp;&nbsp;&nbsp;每当玩家猜中某一格子时,就把相对的那一个设定为<strong>true</strong>,之后每次猜中都要在<strong>第二个数组</strong>中检查该格子之前是否已经猜中。<br>2.只改动<strong>原来的数组</strong><br><br>&nbsp;&nbsp;&nbsp;通过只改动原来的数组，任何被猜中的格子改为<strong>-1</strong>;这样则只需要维护一个数组。<br></p>
<hr>

<h2 id="2-ArrayList——数组不够用时"><a href="#2-ArrayList——数组不够用时" class="headerlink" title="2.ArrayList——数组不够用时"></a>2.ArrayList——数组不够用时</h2><p>1.ArrayList的用法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">add(Object elem)</span><br><span class="line">//向list中加入对象参数</span><br><span class="line"></span><br><span class="line">remove(int index)</span><br><span class="line">//在索引参数中移除对象</span><br><span class="line"></span><br><span class="line">remove(Object elem)</span><br><span class="line">//移除该对象</span><br><span class="line"></span><br><span class="line">contains(Object elem)</span><br><span class="line">//如果和对象参数匹配返回&quot;true&quot;</span><br><span class="line"></span><br><span class="line">isEmpty()</span><br><span class="line">//如果list中没有元素返回&quot;true&quot;</span><br><span class="line"></span><br><span class="line">indexOf(Object elem)</span><br><span class="line">//返回对象参数的索引或-1</span><br><span class="line"></span><br><span class="line">size()</span><br><span class="line">//返回list中元素的一个数</span><br><span class="line"></span><br><span class="line">get(int index)</span><br><span class="line">//返回当前索引参数的对象</span><br></pre></td></tr></table></figure></p>
<p>2.ArrayList与一般数组的对比<br><br>&nbsp;&nbsp;&nbsp;&nbsp;a.一般数组在创建时必须确认大小<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于ArrayList来说，只需要创建出此类型的对象就可以了。会<strong>动态的在加入和删除元素时调整大小</strong><br><br>&nbsp;&nbsp;&nbsp;&nbsp;b.一般数组在存放对象时必须指定位置<br><code>如: myList[1]=b;</code><br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于ArrayList可以用<strong>add(Int, Object)</strong>或者<strong>add(Object)</strong>来进行<strong>自行管理大小</strong><br><code>myList.add(b);</code><br><br>&nbsp;&nbsp;&nbsp;&nbsp;c.一般数组使用特殊的语法<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于ArrayList来说，ArrayList是个<strong>普通对象</strong>,所以不会有特殊的语法<br><code>myList[1]; 其中&quot;[ ]&quot;方括号为只使用在数组上面的特殊语法</code><br><br>&nbsp;&nbsp;&nbsp;&nbsp;d.在java5.0中的ArrayList是参数化的<br><code>ArrayList&lt;String&gt; 其中&lt;String&gt;是类型参数。这代表String的集合。如同ArrayList&lt;Dog&gt;代表Dog的集合</code><br></p>
<hr>

<h2 id="3-使用ArrayList改编游戏"><a href="#3-使用ArrayList改编游戏" class="headerlink" title="3.使用ArrayList改编游戏"></a>3.使用ArrayList改编游戏</h2><p>1.改编内容<br><br>&nbsp;&nbsp;&nbsp;&nbsp;a.<strong>DotCom</strong>类<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;增加名称变量，用来保存DotCom的名字。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;b.<strong>DotComBust</strong>类(the game)<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;创建出3个DotCom<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;指定DotCom的名称<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;将DotCom放在方阵上<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>每次猜测都检查3个DotCom</strong><br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>击沉3个DotCom后才可以结束游戏</strong><br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;脱离main()<br></p>
<p><strong>2.代码区</strong><br><br>&nbsp;&nbsp;&nbsp;&nbsp;a.<strong>DotCom</strong><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line"></span><br><span class="line">public class DotCom&#123;</span><br><span class="line">    private ArrayList&lt;String&gt; locationCells;</span><br><span class="line">    private String name;</span><br><span class="line">    </span><br><span class="line">    public void setLocationCells(ArrayList&lt;String&gt; loc)&#123;</span><br><span class="line">        locationCells = loc;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void setName(String n)&#123;</span><br><span class="line">        name = n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public String checkYourself(String userInput)&#123;</span><br><span class="line">    String result = &quot;miss&quot;;</span><br><span class="line">    int index = locationCells.indexOf(userInput);</span><br><span class="line">    if (index &gt;= 0)&#123;</span><br><span class="line">        locationCells.remove(index);</span><br><span class="line">        </span><br><span class="line">        if(locationCells.isEmpty())&#123;</span><br><span class="line">            result = &quot;kill&quot;;</span><br><span class="line">            System.out.println(&quot;Ouch! You sunk &quot;+ name +&quot; : (&quot; ) ;&#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            result = &quot;hit&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;b.<strong>DotComBust</strong><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line">public class DotComBust&#123;</span><br><span class="line">    private GameHelper helper = new GameHelper();</span><br><span class="line">    private ArrayList&lt;DotCom&gt; dotComsList = new ArrayList&lt;DotCom&gt;();</span><br><span class="line">    private int numOfGuesses = 0;</span><br><span class="line">    </span><br><span class="line">    private void setUpGame()&#123;</span><br><span class="line">        Dotcom one = new DotCom();</span><br><span class="line">        one.setName(&quot;pets.com&quot;);</span><br><span class="line">        Dotcom two = new DotCom();</span><br><span class="line">        two.setName(&quot;eYoys.com&quot;);</span><br><span class="line">        Dotcom three = new DotCom();</span><br><span class="line">        three.setName(&quot;Go2.com&quot;);</span><br><span class="line">        //创建3个DotCom对象并赋值名称</span><br><span class="line">        dotComList.add(one);</span><br><span class="line">        dotComList.add(two);</span><br><span class="line">        dotComList.add(three);</span><br><span class="line">        //将其名称置入ArrayList中</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    System.out.println(&quot;Your goal is to sink three dot coms&quot;);</span><br><span class="line">    System.out.println(&quot;Petx.com,eToys.com,Go2.com&quot;);</span><br><span class="line">    System.out.println(&quot;Try to sink them all in the fewest number of guesses&quot;);</span><br><span class="line">    //此处做出简短的提示，告知玩家网站名称，并且输入位置进行击中网站</span><br><span class="line">    </span><br><span class="line">    for(DotCom dotComToSet : DotComsList)&#123;</span><br><span class="line">    //该for循环在&quot;java_编写程序之超强力方法小结&quot;中曾记录。</span><br><span class="line">    //对list中所有的DotCom重复赋值给dotComToSet中。</span><br><span class="line">        ArrayList&lt;string&gt; newLocation = helper.placeDotCom(3);</span><br><span class="line">        //要求DotCom的位置</span><br><span class="line">        </span><br><span class="line">        dotComToSet.setLocationCells(newLocation);</span><br><span class="line">        //调用set方法来指派刚刚取得的位置</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private void startPlaying()&#123;</span><br><span class="line">        while(!dotComsList.isEmpty())&#123;</span><br><span class="line">        //判断DotCom的list是否为空，若为空则表示全部击沉</span><br><span class="line">            String userGuess = helper.getUserInput(&quot;Enter a guess&quot;);</span><br><span class="line">            //获取玩家输入值</span><br><span class="line">            checkUserGuess(userGuess);</span><br><span class="line">            //调用checkUserGuess方法，检查是否命中</span><br><span class="line">        &#125;</span><br><span class="line">        finishGame();</span><br><span class="line">        //调用finishGame方法，此时已经结束游戏，列出玩家最后成绩</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private void checkUserGuess(String userGuess)&#123;</span><br><span class="line">        numOfGuesses++;</span><br><span class="line">        //递增玩家猜测次数的计数</span><br><span class="line">        </span><br><span class="line">        String result = &quot;miss&quot;;</span><br><span class="line">        //先设定命中状态为未命中</span><br><span class="line">        </span><br><span class="line">        for(DotCom dotComToTest : dotComsList)&#123;</span><br><span class="line">        //此处对list中所有的DotCom重复</span><br><span class="line">            result = dotComTest.checkYourself(userGuess);</span><br><span class="line">            //检查是否击沉或者击中</span><br><span class="line">            if(result.equals(&quot;hit&quot;))&#123;</span><br><span class="line">                break;</span><br><span class="line">                //在击中后跳出循环</span><br><span class="line">            &#125;</span><br><span class="line">            if(result.equals(&quot;kill&quot;))&#123;</span><br><span class="line">                dotComsList.remove(dotComToTest);</span><br><span class="line">                break;</span><br><span class="line">                //在击沉后跳出循环</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.oyut.println(result);</span><br><span class="line">        //列出结果</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private void finishGame()&#123;</span><br><span class="line">        System.out.println(&quot;All Dot Coms are dead! Your stock is now worthless.&quot;);</span><br><span class="line">        if(numOfGuesses &lt;= 18)&#123;</span><br><span class="line">            System.out.println(&quot;It only took you &quot;+ numOfGuesses +&quot; guesses.&quot;);</span><br><span class="line">            Ststem.out.println(&quot;You got out before your options sank.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            System.out.println(&quot;Took you long enough.&quot;+ numOfGuesses +&quot; giesses.&quot;);</span><br><span class="line">            System.out.println(&quot;Fish are dancing with hyour options&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        DotComBust game = new DotComBust();</span><br><span class="line">        game.setUpGame();</span><br><span class="line">        game.startPlaying();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;c.<strong>GameHelper</strong><br><br>//该代码块不好理解<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">import java.io.;</span><br><span class="line">import java.util.;</span><br><span class="line"></span><br><span class="line">public class GameHelper&#123;</span><br><span class="line">    private static final String alphabet = &quot;abcdefg&quot;;</span><br><span class="line">    private int gridLength = 7;</span><br><span class="line">    private int gridSize   = 49;</span><br><span class="line">    private int [] grid    = new int[gridSize];</span><br><span class="line">    private int comCount = 0;</span><br><span class="line">    </span><br><span class="line">    public String getUserInput(String prompet)&#123;</span><br><span class="line">        String inputLine = null;</span><br><span class="line">        System.out.print(prompt + &quot; &quot;);</span><br><span class="line">        try&#123;</span><br><span class="line">            BufferedReader is = new BufferedReader(</span><br><span class="line">            new InputStreamReader(System.in);</span><br><span class="line">            InputLine = is.readLine();</span><br><span class="line">            if(inputLine.length() == 0) return null;)</span><br><span class="line">        &#125;</span><br><span class="line">        catch(IOException e)&#123;</span><br><span class="line">            System.out.println(&quot;IOException:&quot; + e);</span><br><span class="line">        &#125;</span><br><span class="line">        return inputLine.toLowerCase();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    publish ArrayList&lt;String&gt; placeDotCom(int comSize)&#123;</span><br><span class="line">        ArrayList&lt;Strubg&gt; alphaCells = new ArrayList&lt;String&gt;();</span><br><span class="line">        String [] alphacoords = new String [comSize];</span><br><span class="line">        String temp = null;</span><br><span class="line">        int [] coords = new int[comSize];</span><br><span class="line">        int attempts = 0;</span><br><span class="line">        boolean success = flase;</span><br><span class="line">        int location = 0;</span><br><span class="line">        </span><br><span class="line">        comCount++;</span><br><span class="line">        int incr = 1;</span><br><span class="line">        if((comCount %2) == 1)&#123;</span><br><span class="line">            incr = gridLength;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        while(!syccess &amp; attempts++ &lt; 200)&#123;</span><br><span class="line">            location = (int) (Math.random() * gridSize);</span><br><span class="line">            int x = 0;</span><br><span class="line">            success = true;</span><br><span class="line">            while(success &amp;&amp; x &lt;comSize)&#123;</span><br><span class="line">                if(grid[location] == 0)&#123;</span><br><span class="line">                    coords[x++] = location;</span><br><span class="line">                    location += incr;</span><br><span class="line">                    if(location &gt;= gridSize)&#123;</span><br><span class="line">                        success = flase;</span><br><span class="line">                    &#125;</span><br><span class="line">                    if(x&gt;0 &amp;&amp; (location % gridLength == 0))&#123;</span><br><span class="line">                        success = false;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                else &#123;</span><br><span class="line">                    syccess = flase;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        int x      = 0;</span><br><span class="line">        int row    = 0;</span><br><span class="line">        int column = 0;</span><br><span class="line">        </span><br><span class="line">        while(x &lt; comSize)&#123;</span><br><span class="line">            grid[coords[x]] == 1;</span><br><span class="line">            row = (int) (coords[x] / gridLength);</span><br><span class="line">            column = coords[x] % gridLength;</span><br><span class="line">            temp = String.valueOf(alphabet.charAt(column));</span><br><span class="line">            </span><br><span class="line">            alphaCells.add(temp.concat(Integer.toString(row)));</span><br><span class="line">            x++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return alphaCells;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>

<h2 id="4-API的包"><a href="#4-API的包" class="headerlink" title="4.API的包"></a>4.API的包</h2><p>1.在java的API中，类是被包装在包里的。<br><br>2.<strong>使用API中的类，必须知道它被放在哪一个包里面。</strong><br><br>3.必须指明类的完整名称——两种方法指定<br><br>&nbsp;&nbsp;&nbsp;&nbsp;a.<strong>IMPORT</strong><br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;放一个import述句在源文件的最前面<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import java.util.ArrayList;</span><br><span class="line">public class Myclass&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;b.<strong>TYPE</strong><br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在程序代码中打出全名<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">声明的时候</span><br><span class="line">java.util.ArrayList&lt;Dog&gt; list = new java.util.ArrayList&lt;Dog&gt;;</span><br><span class="line"></span><br><span class="line">用在参数的时候</span><br><span class="line">publish void go(java.util.ArrayList&lt;Dog&gt; list)&#123;&#125;;</span><br><span class="line"></span><br><span class="line">作为返回类型的时候</span><br><span class="line">java.util.ArrayList&lt;Dog&gt; foo() &#123;...&#125;</span><br></pre></td></tr></table></figure></p>
<hr>

<h2 id="5-查询API的方法"><a href="#5-查询API的方法" class="headerlink" title="5.查询API的方法"></a>5.查询API的方法</h2><p>1.查阅参考书<br>2.查阅<strong>HTML APL</strong>文档<br>&nbsp;&nbsp;&nbsp;&nbsp;登录java.sun.com进行查找</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/570911275/570911275.github.io/2019/05/25/java-认识java的API之使用java函数库小结/" data-id="cjye872o5002f1otnq1nd5c2f" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java-基础/">java_基础</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-java-编写程序之超强力方法小结" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/05/24/java-编写程序之超强力方法小结/" class="article-date">
  <time datetime="2019-05-24T10:14:11.000Z" itemprop="datePublished">2019-05-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/05/24/java-编写程序之超强力方法小结/">java_编写程序之超强力方法小结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="1-编写真正的游戏"><a href="#1-编写真正的游戏" class="headerlink" title="1.编写真正的游戏"></a>1.编写真正的游戏</h2><p>1.高层设计:<br><br>　一:玩家启动游戏<br><br>　　a.计算机创建３个网站。<br><br>　　b.将此3个网站停在虚拟战场上。<br><br>　二:游戏开始<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;重复下面的操作指导所有的网站被歼灭。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a.提示玩家输入坐标。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b.检查是否击中。<br><br>&nbsp;&nbsp;&nbsp;三:游戏结束<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;根据玩家猜测数，给出结果。<br></p>
<hr>

<h2 id="2-游戏的简单版"><a href="#2-游戏的简单版" class="headerlink" title="2.游戏的简单版"></a>2.游戏的简单版</h2><p>1.简单的开始<br><br>&nbsp;&nbsp;游戏至少需要两个类:<strong>Game</strong>类和<strong>DotCom</strong>类<br><br>2.开发类<br><br>&nbsp;&nbsp;&nbsp;&nbsp;a.找出类应该做的事情<br><br>&nbsp;&nbsp;&nbsp;&nbsp;b.列出实例变量和方法<br><br>&nbsp;&nbsp;&nbsp;&nbsp;c.编写方法的伪码<br><br>&nbsp;&nbsp;&nbsp;&nbsp;d.编写方法的测试用程序<br><br>&nbsp;&nbsp;&nbsp;&nbsp;e.实现类<br><br>&nbsp;&nbsp;&nbsp;&nbsp;f.测试方法<br><br>&nbsp;&nbsp;&nbsp;&nbsp;g.除错或重新设计<br></p>
<hr>

<h2 id="3-代码区"><a href="#3-代码区" class="headerlink" title="3.代码区"></a>3.代码区</h2><p>1.<strong>SimpleDotCom</strong><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public class SimpleDotCom&#123;</span><br><span class="line">    int[] locationCells;</span><br><span class="line">    int numOfHits = 0;</span><br><span class="line">    public void setLocationCells(int[] locs)&#123;</span><br><span class="line">        locationCells = locs;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public String checkYourself(String stringGuess)&#123;</span><br><span class="line">        int guess = Integer.parseInt(stringGuess);</span><br><span class="line">        //此处将字符串转换为int</span><br><span class="line">        //其中Integer为java的一个内建类;parseInt为Integer的一个方法</span><br><span class="line">        String result = &quot;miss&quot;;</span><br><span class="line">        for(int cell : locationCells)&#123;</span><br><span class="line">        //此处为新的for循环表示方法</span><br><span class="line">        //将locationCells这个数组中的元素逐个赋值给cell中。</span><br><span class="line">            if(guess == cell)&#123;</span><br><span class="line">                result = &quot;hit&quot;;</span><br><span class="line">                numOfHits++;</span><br><span class="line">                breal;</span><br><span class="line">                //此处判断击中状态存在bug。无法判断是否重复击中同一格子。</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        if(numOfHits == locationCells.length)&#123;</span><br><span class="line">        //击中数量与数组长度相比较，若在不考虑上方bug情况下，二者相等则为击沉状态</span><br><span class="line">            result = &quot;kill&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(result);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>2.<strong>main</strong><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args)&#123;</span><br><span class="line">    int numOfGuesses = 0;</span><br><span class="line">    GameHelper helper = new GameHelper();</span><br><span class="line">    //使用这个类来获取玩家的输入</span><br><span class="line">    </span><br><span class="line">    SimpleDotCom theDotCom = new SimpleDotCom();</span><br><span class="line">    int randomNum = (int) (Math.random()*5);</span><br><span class="line">    //产生随机数</span><br><span class="line">    //Math是java的内建的一个类;random是Math中内含的一个方法</span><br><span class="line">    //Math.random会产生一个0&lt;=x&lt;1的数</span><br><span class="line">    //在*5之后，随机数的范围扩大为0&lt;=x&lt;5</span><br><span class="line">    </span><br><span class="line">    int[] locations = &#123;randomNum,randomNum+1,randomNum+2&#125;;</span><br><span class="line">    theDotCom.setLocationCells(locations);</span><br><span class="line">    boolean isAlive = true;</span><br><span class="line">    </span><br><span class="line">    while(isAlive == true)&#123;</span><br><span class="line">        String guess = helper.getUserInput(&quot;enter a number&quot;);</span><br><span class="line">        //获取玩家的输入，并且用&quot;guess&quot;这个变量来承载玩家的输入值</span><br><span class="line">        String result = theDotCom.checkYourself(guess);</span><br><span class="line">        </span><br><span class="line">        numOfGuesses++;</span><br><span class="line">        if(result.equals(&quot;kill&quot;))&#123;</span><br><span class="line">            isAlive = false;</span><br><span class="line">            System.out.println(&quot;You took&quot;+ numOfGuesses+&quot;guesses&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>3.<strong>GameHelper</strong><br><br>//该代码区较难理解<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import java.io.*;</span><br><span class="line">public class GameHelper&#123;</span><br><span class="line">    public String getUserInput(String prompt)&#123;</span><br><span class="line">        String inputLine = null;</span><br><span class="line">        System.out.print(prppt+&quot; &quot;);</span><br><span class="line">        try&#123;</span><br><span class="line">            BufferedReader is = new BufferedReader(new InputStreamReader(System.in));</span><br><span class="line">            inputLine = is.readLine();</span><br><span class="line">            if(inputLine.length() == 0) return null;</span><br><span class="line">        &#125;</span><br><span class="line">        catch(IOException e)&#123;</span><br><span class="line">            System.out.println(&quot;IOException:&quot; +e);</span><br><span class="line">        &#125;</span><br><span class="line">        return inputLine;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>

<h2 id="4-加强版for循环"><a href="#4-加强版for循环" class="headerlink" title="4.加强版for循环"></a>4.加强版for循环</h2><p><strong>for(String name : nameArray){}</strong><br><br>1.创建名称为”name”的String变量<br><br>2.将nameArray的第一个元素赋值给name<br><br>3.执行重复内容<br><br>4.赋值下一元素给name<br><br>5.重复执行至所有元素被运行完<br><br><br><br>补充；<br><br>1.”:”表示in;在其他语言中这种循环又被叫做”for in”或者“foreach”循环<br>2.name如同一个容器，每次循环装载来自nameArray的元素<br>3.nameArray如同一个具有多杯饮料的杯框。每次循环，将nameArray中一杯饮料取出，倒入name这个容器中。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/570911275/570911275.github.io/2019/05/24/java-编写程序之超强力方法小结/" data-id="cjye872ls001s1otnqp5r9vbp" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java-基础/">java_基础</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-java-方法操作实例变量小结" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/05/23/java-方法操作实例变量小结/" class="article-date">
  <time datetime="2019-05-23T11:54:48.000Z" itemprop="datePublished">2019-05-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/05/23/java-方法操作实例变量小结/">java_方法操作实例变量小结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="1-对象有状态和行为"><a href="#1-对象有状态和行为" class="headerlink" title="1.对象有状态和行为"></a>1.对象有状态和行为</h2><p>1.同一类型的每个对象能够有不同的方法行为<br><br><strong>方法根据实例变量的值来表现不同的行为</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void play()&#123;</span><br><span class="line">    soundPlayer.playSound(title);</span><br><span class="line">&#125;</span><br><span class="line">Song t2 = new Song();</span><br><span class="line">t2.setArtist(&quot;Travis&quot;);</span><br><span class="line">t2.setTitle(&quot;Sing&quot;);</span><br><span class="line">t2.play();</span><br><span class="line">\\调用t2的play()会播放Sing;</span><br><span class="line">t2.setArtist(&quot;Sex Pistols&quot;);</span><br><span class="line">t2.setTitle(&quot;My Way&quot;);</span><br><span class="line">t2.play();</span><br><span class="line">\\调用t2的play()会播放My Way;</span><br></pre></td></tr></table></figure></p>
<hr>

<h2 id="2-方法的参数"><a href="#2-方法的参数" class="headerlink" title="2.方法的参数"></a>2.方法的参数</h2><p>1.传值给方法<br><br><strong>方法会运用形参,调用的一方会传入实参</strong><br><br><strong>形参改变,不影响实参</strong><br><br>实参:是传给方法的值。<br><br>形参:从实参传入的参数,进入方法后就成了形参。<br><br>参数和局部变量是一样的,它有类型和名称<br><br><strong>如果某个方法需要参数，一定得传参数给它，并且该参数得是适当类型的值</strong><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Dog d = new Dog();</span><br><span class="line">d.bark(3);//此处传入&quot;3&quot;这个参数，&quot;3&quot;为实参。</span><br><span class="line">void bark(int numOfBarks)&#123;//&quot;3&quot;这个实参传入bark这个方法中，&quot;numOfBarks&quot;为形参。</span><br><span class="line">    while(numOfBarks &gt; 0)&#123;</span><br><span class="line">        System.out.println(&quot;ruff&quot;);</span><br><span class="line">        numOfBarks = numOfBarks-1;//此处&quot;numOfBarks&quot;这个形参的大小发生改变不影响&quot;3&quot;这个实参的大小。</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>2.从方法中取得返回值<br><br>a.void类型的方法,表示这个方法没有返回任何东西<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void give()&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>b.若需返回值,可将方法声明为有返回值类型。但此时必须返回所声明类型的值。<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int giveSecret()&#123;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>c.调用具有返回值的变量，该变量的类型需要和方法返回值类型相同</strong><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int theSecret = life.giveSecret();</span><br><span class="line">//变量类型为int</span><br><span class="line">int giveSecret()&#123;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">//方法返回值类型为int</span><br></pre></td></tr></table></figure></p>
<hr>

<h2 id="3-多个参数"><a href="#3-多个参数" class="headerlink" title="3.多个参数"></a>3.多个参数</h2><p>1.方法可有多个参数，在声明的时候用<strong>逗号</strong>隔开，同时传入的时候也是用<strong>逗号</strong>隔开。<br><br><strong>以正确数量、类型和顺序来传递参数</strong><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void go()&#123;</span><br><span class="line">    int foo = 7;</span><br><span class="line">    int bar = 3;</span><br><span class="line">    t.takeTwo(foo,bar);</span><br><span class="line">&#125;</span><br><span class="line">void takeTwo(num1,num2)&#123;</span><br><span class="line">    int num = num1+num2;</span><br><span class="line">    System.out.println(&quot;Total is &quot;+num);</span><br><span class="line">    //此处会打印出Total is 10。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>

<h2 id="4-封装"><a href="#4-封装" class="headerlink" title="4.封装"></a>4.封装</h2><p>1.数据隐藏:使用公用(public)和私有(private)这两个存取修饰符，可以对数据进行隐藏<br><br>2.封装的基本原则:实例变量标记为私有的(private);并提供公有(public)的<strong>getter</strong>与<strong>setter</strong>进行控制存取动作。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class GoodGog&#123;</span><br><span class="line">    private int size;</span><br><span class="line">    public  int getSize()&#123;</span><br><span class="line">        return size;</span><br><span class="line">    &#125;</span><br><span class="line">    //获取Size的值</span><br><span class="line">    public  int setSize(int s)&#123;</span><br><span class="line">        size = s;</span><br><span class="line">    &#125;</span><br><span class="line">    //赋值给Size</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class GoodDogTestDrive&#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        GoodDog one = new GoodDog();</span><br><span class="line">        one.SetSize(10);</span><br><span class="line">        //赋值给one的Size为10。</span><br><span class="line">        GoodDog two = new GoodDog();</span><br><span class="line">        two.SetSize(100);</span><br><span class="line">        //赋值给two的Size为100。</span><br><span class="line">        System.out.println(&quot;Dog one: &quot;+one.getSize());</span><br><span class="line">        //此处输出Dog one 10。</span><br><span class="line">        System.out.println(&quot;Dog two: &quot;+two.getSize());</span><br><span class="line">        //此处输出Dog two 100。</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/570911275/570911275.github.io/2019/05/23/java-方法操作实例变量小结/" data-id="cjye872l4001k1otnnyrswqci" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java-基础/">java_基础</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Java-primitive主数据类型和引用小结" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/05/22/Java-primitive主数据类型和引用小结/" class="article-date">
  <time datetime="2019-05-22T12:22:38.000Z" itemprop="datePublished">2019-05-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/05/22/Java-primitive主数据类型和引用小结/">Java_primitive主数据类型和引用小结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="声明变量"><a href="#声明变量" class="headerlink" title="声明变量"></a>声明变量</h2><p><strong><em> 1.</em></strong> java中。primitive主数据类型用来保存基本的基本类型的值，包括整数、布尔、浮点数等。对象引用保存的是对象的引用<br><br><strong><em> 2.</em></strong> java注重类型，无法出现将浮点数类型变量放进整数类型的变量的情况。除非跟编译器确认可以损失掉精确度(例如说舍去所有的小数值)<br><br><strong><em> 3.primitive主数据类型:</em></strong> <br><br>类型|位数|值域<br>—|:–:|—:<br>boolean|null|true或false<br>char|16 bits|0~65535<br>byte|8 bits|-128~127<br>short|16 bits|-32768~32767<br>int|32 bits|-2147483648~2147483647<br>long|64 bits|-很大~很大<br>float|32 bits|范围规模可变<br>double|64 bits|范围规模可变<br></p>
<p><strong>注意：float变量声明与赋值声明与其他不同<br>其他变量：boolean isPunkRock;<br>isPunkRock = false;<br>先声明类型再赋值声明。<br>float变量：<br>float f = 32.5f;<br>该处”f”，若不加上f则java当做double处理<br></strong><br><br><br><strong>*<em>4.注意溢值以及避开关键字</em></strong>   <br><br>  a.溢位:无法用小的primitive类型装大的primitive类型如:<br><br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int  x = 24;&lt;br/&gt;</span><br><span class="line">byte y = x;&lt;br/&gt;</span><br><span class="line">因为int大于byte所以编译器无法通过&lt;br/&gt;</span><br></pre></td></tr></table></figure></p>
<p> <br><br>  b.避开关键字：名称必须以字母、下划线或者$开头，不能使用数字开头。<br><br><strong><em>5.对象引用</em></strong>  <br><br>prmitive主数据类型变量是以字节来代替实际的变量值<br><br>对象引用变量是以字节来表示取得对象的方法<br><br>既当我们使用圆点运算符(.)来对引用变量来表示:取得”.”前面的对象，然后求出”.”后面的事物。eg:myDog。bark();<br><br><strong><em>6.数组</em></strong><br><strong>1.数组是一个对象:</strong><br><br>数组对象可以有primitive主数据类型的元素，但是数组本身不会是primitive主数据类型，数组一定是对象。<br><br>2.数组的使用:<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Dog[] pets;声明一个Dog数组变量&lt;br/&gt;</span><br><span class="line">pets = new Dog[7];对Dog对象的引用&lt;br/&gt;</span><br><span class="line">此时需要实际的Dog对象&lt;br/&gt;</span><br><span class="line">pets[0] = new Dog();&lt;br/&gt;</span><br><span class="line">pets[1] = new Dog();&lt;br/&gt;</span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/570911275/570911275.github.io/2019/05/22/Java-primitive主数据类型和引用小结/" data-id="cjye872ef00051otn24awzhib" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java-基础/">java_基础</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/3/">&laquo; 上一页</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/5/">下一页 &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/javaEE-基础/">javaEE_基础</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java-基础/">java_基础</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/javaEE-基础/" style="font-size: 10px;">javaEE_基础</a> <a href="/tags/java-基础/" style="font-size: 20px;">java_基础</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">七月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">六月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">五月 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/07/19/JavaEE之JDBC小结/">JavaEE之JDBC小结</a>
          </li>
        
          <li>
            <a href="/2019/07/19/JavaEE之三层架构小结/">JavaEE之三层架构小结</a>
          </li>
        
          <li>
            <a href="/2019/07/19/JavaEE之JSTL表达式小结/">JavaEE之JSTL表达式小结</a>
          </li>
        
          <li>
            <a href="/2019/07/19/JavaEE之EL表达式小结/">JavaEE之EL表达式小结</a>
          </li>
        
          <li>
            <a href="/2019/07/18/JavaEE之MVC概念小结/">JavaEE之MVC概念小结</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>
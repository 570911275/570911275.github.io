<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="https://github.com/570911275/570911275.github.io/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://github.com/570911275/570911275.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-新文档8080" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/08/04/新文档8080/" class="article-date">
  <time datetime="2019-08-04T02:08:21.388Z" itemprop="datePublished">2019-08-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="SpringMVC"><a href="#SpringMVC" class="headerlink" title="SpringMVC"></a>SpringMVC</h2><h3 id="SpringMVC的Json"><a href="#SpringMVC的Json" class="headerlink" title="SpringMVC的Json"></a>SpringMVC的Json</h3><pre><code>1. SpringMVC设置静态资源不拦截
   1. 方式一：在SpringMVC.xml中添加静态资源的映射
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">location指的是本地的真实的物理路径 ，mapping指的是映射到的虚拟路径(比如前端请求的url地址)</span><br><span class="line">    &lt;mvc:resources location=&quot;/css/&quot; mapping=&quot;/css/**&quot;/&gt;  &lt;!-- 样式 --&gt;</span><br><span class="line">    &lt;mvc:resources location=&quot;/images/&quot; mapping=&quot;/images/**&quot;/&gt;  &lt;!-- 图片 --&gt;</span><br><span class="line">    &lt;mvc:resources location=&quot;/js/&quot; mapping=&quot;/js/**&quot;/&gt;  &lt;!-- javascript --&gt;</span><br></pre></td></tr></table></figure>
<pre><code>2. 方式二：在SpringMVC.xml中添加静态资源默认Servlet处理
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;mvc:default-servlet-handler/&gt;</span><br></pre></td></tr></table></figure>
<pre><code>3. 方式三：在web.xml中配置映射
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;servlet-mapping&gt;</span><br><span class="line">    &lt;servlet-name&gt;default&lt;/servlet-name&gt;</span><br><span class="line">    &lt;url-pattern&gt;*.js&lt;/url-pattern&gt;</span><br><span class="line">    &lt;url-pattern&gt;*.css&lt;/url-pattern&gt;</span><br><span class="line">    &lt;url-pattern&gt;*.ico&lt;/url-pattern&gt;</span><br><span class="line">    &lt;url-pattern&gt;/img/*&lt;/url-pattern&gt;</span><br><span class="line">    &lt;url-pattern&gt;/fonts/*&lt;/url-pattern&gt;</span><br><span class="line">    &lt;url-pattern&gt;/font/*&lt;/url-pattern&gt;</span><br><span class="line">&lt;/servlet-mapping&gt;</span><br></pre></td></tr></table></figure>
<pre><code>2. 使用注解@RequestBody获取请求体数据
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">response.jsp</span><br><span class="line"></span><br><span class="line">        //页面加载，绑定单击事件</span><br><span class="line">        $(function () &#123;</span><br><span class="line">           $(&quot;#btn&quot;).click(function () &#123;</span><br><span class="line">               // alert(&quot;hello&quot;);</span><br><span class="line">               //发送ajax请求</span><br><span class="line">               $.ajax(&#123;</span><br><span class="line">                   //编写json格式，设置属性和值</span><br><span class="line">                   url:&quot;user/testAjax&quot;,</span><br><span class="line">                   contentType:&quot;application/json;charset=UTF-8&quot;,</span><br><span class="line">                   data:&apos;&#123;&quot;username&quot;:&quot;haha&quot;,&quot;password&quot;:&quot;123&quot;,&quot;age&quot;:&quot;18&quot;&#125;&apos;,</span><br><span class="line">                   dataType:&quot;json&quot;,</span><br><span class="line">                   type:&quot;post&quot;,</span><br><span class="line">                   success:function(data)&#123;</span><br><span class="line">                       //data服务器端响应的json的数据，进行解析</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;);</span><br><span class="line">           &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">获取请求体的数据UserController.class</span><br><span class="line"></span><br><span class="line">    @RequestMapping(&quot;testAjax&quot;)</span><br><span class="line">    public void testAjax(@RequestBody String body)&#123;</span><br><span class="line">        System.out.println(&quot;testAjax方法执行了&quot;);</span><br><span class="line">        System.out.println(body);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<pre><code>3. 使用注解@RequestBody和@ResponseBody
     * 使用@RequestBody注解把json的字符串转换成JavaBean的对象
     * 使用@ResponseBody注解把JavaBean对象转换成json字符串，直接响应
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">使用@RequestBody和@ResponseBody</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 模拟异步请求响应</span><br><span class="line">     *</span><br><span class="line">     *当json的字符串的key值与JavaBean中的属性名相同</span><br><span class="line">     *SpringMVC将会自动把数据封装到对象中</span><br><span class="line">     * 此过程需要额外的jar包(jackson)——数据之间的转换</span><br><span class="line">     */</span><br><span class="line">    @RequestMapping(&quot;testAjax&quot;)</span><br><span class="line">    public @ResponseBody User testAjax(@RequestBody User user)&#123;</span><br><span class="line">        System.out.println(&quot;testAjax方法执行了&quot;);</span><br><span class="line">        //客户端发送ajax的请求，传的是json字符串，后端把json字符串封装到user对象中</span><br><span class="line">        System.out.println(user);</span><br><span class="line">        //做响应，模拟查询数据库</span><br><span class="line">        user.setUsername(&quot;haha&quot;);</span><br><span class="line">        user.setAge(17);</span><br><span class="line">        //做响应</span><br><span class="line">        return user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">response.jsp</span><br><span class="line"></span><br><span class="line">        //页面加载，绑定单击事件</span><br><span class="line">        $(function () &#123;</span><br><span class="line">           $(&quot;#btn&quot;).click(function () &#123;</span><br><span class="line">               // alert(&quot;hello&quot;);</span><br><span class="line">               //发送ajax请求</span><br><span class="line">               $.ajax(&#123;</span><br><span class="line">                   //编写json格式，设置属性和值</span><br><span class="line">                   url:&quot;user/testAjax&quot;,</span><br><span class="line">                   contentType:&quot;application/json;charset=UTF-8&quot;,</span><br><span class="line">                   data:&apos;&#123;&quot;username&quot;:&quot;haha&quot;,&quot;password&quot;:&quot;123&quot;,&quot;age&quot;:&quot;18&quot;&#125;&apos;,</span><br><span class="line">                   dataType:&quot;json&quot;,</span><br><span class="line">                   type:&quot;post&quot;,</span><br><span class="line">                   success:function(data)&#123;</span><br><span class="line">                       //data服务器端响应的json的数据，进行解析</span><br><span class="line">                       alert(data);</span><br><span class="line">                       alert(data.username);</span><br><span class="line">                       alert(data.password);</span><br><span class="line">                       alert(data.age);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;);</span><br><span class="line">           &#125;);</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>
<h3 id="SpringMVC的文件上传"><a href="#SpringMVC的文件上传" class="headerlink" title="SpringMVC的文件上传"></a>SpringMVC的文件上传</h3>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/570911275/570911275.github.io/2019/08/04/新文档8080/" data-id="cjywzvwmk002y3ctn20smahkb" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-JavaEE之SpringMVC之Restful小结" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/08/02/JavaEE之SpringMVC之Restful小结/" class="article-date">
  <time datetime="2019-08-02T05:20:01.000Z" itemprop="datePublished">2019-08-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/08/02/JavaEE之SpringMVC之Restful小结/">JavaEE之SpringMVC之Restful小结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="SpringMVC之Restful小结"><a href="#SpringMVC之Restful小结" class="headerlink" title="SpringMVC之Restful小结"></a>SpringMVC之Restful小结</h2><h3 id="URL设计"><a href="#URL设计" class="headerlink" title="URL设计"></a>URL设计</h3><pre><code>1. 动词+宾语
    * Restful的核心思想就是，客户端发出的数据操作指令都是&quot;动词+宾语&quot;的结构。
    * 比如：GET/articles;GET是动词，/articles是宾语

2. 动词的种类
    * 动词通常就是五种HTTP方法，对应CRUD操作
    * 动词一律大写
        * GET: 读取(Read)
        * POST: 新建(Create)
        * PUT: 更新(Update)
        * PATCH: 更新(Update)——部分更新
        * DELETE: 删除(Delete)

3. 动词的覆盖与宾语必须是名词
     1.  有些客户端只能使用GET和POST这两种方法。服务器必须接受POST模拟其他三个方法（PUT、PATCH、DELETE）。这时，客户端发出的 HTTP 请求，要加上X-HTTP-Method-Override属性，告诉服务器应该使用哪一个动词，覆盖POST方法。
           * 在下列代码中：X-HTTP-Method-Override指定本次请求的方法是PUT，而不是POST。
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">POST /api/Person/4 HTTP/1.1  </span><br><span class="line">X-HTTP-Method-Override: PUT</span><br></pre></td></tr></table></figure>
<pre><code>2.  宾语就是 API 的 URL，是 HTTP 动词作用的对象。它应该是名词，不能是动词。比如，/articles这个 URL 就是正确的，而下面的 URL 不是名词，所以都是错误的。
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/getAllCars</span><br><span class="line">/createNewCar</span><br><span class="line">/deleteAllRedCars</span><br></pre></td></tr></table></figure>
<pre><code>4. URL的规范
      1. 复数URL：
            * 既然 URL 是名词，那么应该使用复数，还是单数？
            * 这没有统一的规定，但是常见的操作是读取一个集合，比如GET /articles（读取所有文章），这里明显应该是复数。
            * 为了统一起见，建议都使用复数 URL，比如GET /articles/2要好于GET /article/2。

      2. 避免多级 URL：
            * 常见的情况是，资源需要多级分类，因此很容易写出多级的 URL，比如获取某个作者的某一类文章。
            `GET /authors/12/categories/2`
            * 这种 URL 不利于扩展，语义也不明确，往往要想一会，才能明白含义。
            * 更好的做法是，除了第一级，其他级别都用查询字符串表达。
            `GET /authors/12?categories=2`
            * 下面是另一个例子，查询已发布的文章。你可能会设计成下面的 URL。
            `GET /articles/published`
            * 查询字符串的写法明显更好。
            `GET /articles?published=true`
</code></pre><h3 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h3><pre><code>1. 状态码的概念：
     * 客户端的每一次请求，服务器都必须给出回应。回应包括 HTTP 状态码和数据两部分。

2. 状态码的类别：
     * 1xx：相关信息
     * 2xx：操作成功
     * 3xx：重定向
     * 4xx：客户端错误
     * 5xx：服务器错误
</code></pre><h3 id="服务器回应"><a href="#服务器回应" class="headerlink" title="服务器回应"></a>服务器回应</h3><pre><code>1. 不要返回纯本文
     * PI 返回的数据格式，不应该是纯文本，而应该是一个 JSON 对象，这样才能返回标准的结构化数据。
     * 所以，服务器回应的 HTTP 头的Content-Type属性要设为application/json。
     * 客户端请求时，也要明确告诉服务器，可以接受 JSON 格式，即请求的 HTTP 头的ACCEPT属性也要设成application/json。
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GET /orders/2 HTTP/1.1 </span><br><span class="line">Accept: application/json</span><br></pre></td></tr></table></figure>
<pre><code>2. 发生错误时，不要返回 200 状态码
   1. 错误做法
      * 有一种不恰当的做法是，即使发生错误，也返回200状态码，把错误信息放在数据体里面
      * 如此一来解析数据体以后，才能得知操作失败。
   2. 正确做法
      * 状态码反映发生的错误
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">错误做法：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Content-Type: application/json</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;status&quot;: &quot;failure&quot;,</span><br><span class="line">  &quot;data&quot;: &#123;</span><br><span class="line">    &quot;error&quot;: &quot;Expected at least two items in list.&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">正确做法：</span><br><span class="line"></span><br><span class="line">HTTP/1.1 400 Bad Request</span><br><span class="line">Content-Type: application/json</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;error&quot;: &quot;Invalid payoad.&quot;,</span><br><span class="line">  &quot;detail&quot;: &#123;</span><br><span class="line">     &quot;surname&quot;: &quot;This field is required.&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre><code>3. 提供链接
     1. API 的使用者未必知道，URL 是怎么设计的。一个解决方法就是，在回应中，给出相关链接，便于下一步操作。这样的话，用户只要记住一个 URL，就可以发现其他的 URL。这种方法叫做 HATEOAS。

     * 举例来说，GitHub 的 API 都在 api.github.com 这个域名。访问它，就可以得到其他 URL。
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  &quot;feeds_url&quot;: &quot;https://api.github.com/feeds&quot;,</span><br><span class="line">  &quot;followers_url&quot;: &quot;https://api.github.com/user/followers&quot;,</span><br><span class="line">  &quot;following_url&quot;: &quot;https://api.github.com/user/following&#123;/target&#125;&quot;,</span><br><span class="line">  &quot;gists_url&quot;: &quot;https://api.github.com/gists&#123;/gist_id&#125;&quot;,</span><br><span class="line">  &quot;hub_url&quot;: &quot;https://api.github.com/hub&quot;,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre><code>2. 上面的回应中，挑一个 URL 访问，又可以得到别的 URL。对于用户来说，不需要记住 URL 设计，只要从 api.github.com 一步步查找就可以了。

* HATEOAS 的格式没有统一规定，上面例子中，GitHub 将它们与其他属性放在一起。更好的做法应该是，将相关链接与其他属性分开。
</code></pre><pre><code>HTTP/1.1 200 OK
Content-Type: application/json

{
  &quot;status&quot;: &quot;In progress&quot;,
   &quot;links&quot;: {[
    { &quot;rel&quot;:&quot;cancel&quot;, &quot;method&quot;: &quot;delete&quot;, &quot;href&quot;:&quot;/api/status/12345&quot; } ,
    { &quot;rel&quot;:&quot;edit&quot;, &quot;method&quot;: &quot;put&quot;, &quot;href&quot;:&quot;/api/status/12345&quot; }
  ]}
}

</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/570911275/570911275.github.io/2019/08/02/JavaEE之SpringMVC之Restful小结/" data-id="cjyx0vhre0000jstnz7qfhb1q" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/javaEE-基础/">javaEE_基础</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-JavaEE之Spring之AOP小结小结" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/08/01/JavaEE之Spring之AOP小结小结/" class="article-date">
  <time datetime="2019-08-01T01:40:11.000Z" itemprop="datePublished">2019-08-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/08/01/JavaEE之Spring之AOP小结小结/">JavaEE之Spring之AOP小结小结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Spring之AOP小结"><a href="#Spring之AOP小结" class="headerlink" title="Spring之AOP小结"></a>Spring之AOP小结</h2><h3 id="一、AOP概念"><a href="#一、AOP概念" class="headerlink" title="一、AOP概念"></a>一、AOP概念</h3><pre><code>1. 面向切面编程，指扩展功能不修改源代码，将功能代码从业务逻辑代码中分离出来。
     * 主要功能：日志记录、性能统计、安全控制、事务处理、异常处理等等
     * 主要意图：将日志记录、性能统计、安全控制、事务管理、异常处理等代码从业务逻辑代码中划分出来，通过对这些行为的分离，我们希望可以将它们独立到非指导业务逻辑的方法中，进而改变这些行为的时候不影响业务逻辑的代码。
</code></pre><h3 id="二、AOP特点"><a href="#二、AOP特点" class="headerlink" title="二、AOP特点"></a>二、AOP特点</h3><pre><code>1. 采用横向抽取机制，取代了传统纵向继承体系重复性代码
</code></pre><h3 id="三、AOP底层实现"><a href="#三、AOP底层实现" class="headerlink" title="三、AOP底层实现"></a>三、AOP底层实现</h3><pre><code>1. AOP底层使用动态代理实现。包括两种方式：
      * 使用JDK动态代理实现
      * 使用cglib来实现

2. JDK动态代理实现
      * 只能对实现了接口的类生成代理，而不是针对类，该目标类型实现的接口都将被代理。原理是通过在运行期间创建一个接口的实现类来完成对目标对象的代理。
      * 步骤：
          1. 定义一个实现接口InvocationHandler的类
          2. 通过构造函数，注入被代理类
          3. 实现invoke（Object proxy,Method method,Object[] args）方法
          4. 在主函数中获得被代理类的类加载器
          5. 使用Proxy.newProxyInstance()产生一个代理对象
          6. 通过代理对象调用各种方法

3. cglib动态代理实现
       * 针对类实现代理，对是否实现接口无要求。原理是对知道的类生成一个子类，覆盖其中的方法，因为是继承，所以被代理的类或方法最好不要声明被final类型。
       * 步骤：
           1. 如果目标对象实现了接口，默认情况下会采用JDK的动态代理实现AOP，也可以强制使用cglib实现AOP
           2. 如果目标对象没有实现接口，必须采用cglib库，Spring会自动在JDK动态代理和cglib之间转换

4. 静态代理和动态代理的区别：
       * 静态代理：自己编写创建代理类，然后再进行编译，在程序运行前，代理类的.class文件就已经存在了
       * 动态代理：在实现阶段不用关心代理水，而在运行阶段(通过反射机制)才指定代理哪一个对象
</code></pre><h3 id="四、AOP操作术语"><a href="#四、AOP操作术语" class="headerlink" title="四、AOP操作术语"></a>四、AOP操作术语</h3><pre><code>1. 术语总结：
 * Joinpoint(连接点)：类里面可以被增强的方法，这些方法被称为连接点
 * Pointcut(切入点)：所谓切入点是指我们要对哪些Jpinpoint进行拦截的定义
 * Advice(通知/增强): 所谓通知(增强)是指拦截到Joinpoint之后所要做的事情就是通知，通知分为前置通知、后置通知、异常通知、最终通知、环绕通知(切面要完成的功能)
 * Aspect(切面): 是切入点和通知(引介)的结合
 * Introduction(引介): 引介是一种特殊的通知在不修改类代码的前提下, Introduction可以在运行期为类动态地添加一些方法或Field
 * Target(目标对象): 代理的目标对象(要增强的类) 
 * Weaving(织入): 是把增强应用到目标的过程，把advice 应用到 target的过程
 * Proxy(代理): 一个类被AOP织入增强后，就产生一个结果代理类  

2. 常用术语：
 * 切入点(Pointcut)：在类里边可以有很多方法被增强，比如实际操作中，只是增强了个别方法，则定义实际被增强的某个方法为切入点。
 * 通知/增强(Advice) ：增强的逻辑，称为增强，比如扩展日志功能，这个日志功能称为增强
       * 前置通知：在方法之前执行
       * 后置通知：在方法之后执行
       * 异常通知：方法出现异常执行
       * 最终通知：在后置之后执行
       * 环绕通知：在方法之前和之后执行​​​​​​​
 * 切面：把增强应用到具体方法上面的过程称为切面。​​​​​​​
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/570911275/570911275.github.io/2019/08/01/JavaEE之Spring之AOP小结小结/" data-id="cjywzvwk6001m3ctnqna8rcly" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/javaEE-基础/">javaEE_基础</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-新文档8888" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/31/新文档8888/" class="article-date">
  <time datetime="2019-07-31T13:24:17.469Z" itemprop="datePublished">2019-07-31</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="SpringMVC"><a href="#SpringMVC" class="headerlink" title="SpringMVC"></a>SpringMVC</h2><h3 id="SpringMVC的基本概念"><a href="#SpringMVC的基本概念" class="headerlink" title="SpringMVC的基本概念"></a>SpringMVC的基本概念</h3><pre><code>1. SpringMVC是什么：
     * SpringMVC是一种基于Java的实现MVC设计模型的请求驱动类型的轻量级Web框架。
     * SpringMVC通过一套注解，让一个简单的Java类成为处理请求的控制器，而无须实现任何接口。同时它还支持RESTful编程风格的请求。

2. 环境搭建：
     * 导入jar包
     * 搭建前端控制器
     * 搭建服务器

3. 入门案例总结：
     1. 启动服务器，加载一些配置文件
          * DispatchherServlet对象创建
          * springmvc.xml被加载了
          * HelloController创建成对象
     2. 发送请求，后台处理请求
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">          项目名称(/hello)</span><br><span class="line">       &lt;a href=&quot;hello&quot;&gt;入门程序&lt;/a&gt; </span><br><span class="line">                |                          6</span><br><span class="line">            1   |   |———————————————————————————————————————————————— |                        </span><br><span class="line">               \|  \|/                                                |    </span><br><span class="line">       7  控制中心、指挥中心   4         视图解析器对象          5      /|\</span><br><span class="line">结果 &lt;————DispatcherServlet ————&gt;InternalResourceViewResolver————&gt;success.jsp</span><br><span class="line">                |   |\</span><br><span class="line">            2   |   |   3</span><br><span class="line">               \|   |</span><br><span class="line">          @RequestMapping(path=&quot;/hello&quot;)</span><br><span class="line">public String sayHello()&#123;</span><br><span class="line">    System.out.println(&quot;hello StringMVC&quot;);</span><br><span class="line">    return &quot;success&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre><code>3. 入门案组件小结：
     1. DispatcherServlet：前端控制器 
          * 用户请求到达前端控制器，它就相当于 mvc 模式中的 c，dispatcherServlet 是整个流程控制的中心，由 它调用其它组件处理用户的请求，dispatcherServlet 的存在降低了组件之间的耦合性 

     2. HandlerMapping：处理器映射器
          * HandlerMapping 负责根据用户请求找到 Handler 即处理器，SpringMVC 提供了不同的映射器实现不同的 映射方式，例如：配置文件方式，实现接口方式，注解方式等。

     3. Handler：处理器 
          * 它就是我们开发中要编写的具体业务控制器。由 DispatcherServlet 把用户请求转发到 Handler。由 Handler 对具体的用户请求进行处理。

     4. HandlAdapter：处理器适配器 
          * 通过 HandlerAdapter 对处理器进行执行，这是适配器模式的应用，通过扩展适配器可以对更多类型的处理 器进行执行。 

     5. View Resolver：视图解析器 
          * View Resolver 负责将处理结果生成 View 视图，View Resolver 首先根据逻辑视图名解析成物理视图名 即具体的页面地址，再生成 View 视图对象，最后对 View 进行渲染将处理结果通过页面展示给用户

     6. View：视图 
          * SpringMVC 框架提供了很多的 View 视图类型的支持，包括：jstlView、freemarkerView、pdfView 等。我们最常用的视图就是 jsp。 一般情况下需要通过页面标签或页面模版技术将模型数据通过页面展示给用户，需要由程序员根据业务需求开发具体的页面

     7. &lt;mvc:annotation-driven&gt;说明
          * 在 SpringMVC 的各个组件中，处理器映射器、处理器适配器、视图解析器称为 SpringMVC 的三大组件。 
          * 使用&lt;mvc:annotation-driven&gt; 自动加载 RequestMappingHandlerMapping （处理映射器）和 RequestMappingHandlerAdapter （ 处 理 适 配 器 ） ， 
          * 可 用 在 SpringMVC.xml 配 置 文 件 中 使 用 &lt;mvc:annotation-driven&gt;替代注解处理器和适配器的配置。
          *  它就相当于在 xml 中配置了：
          *   &lt;!-- 上面的标签相当于 如下配置--&gt;
          *   &lt;!-- Begin --&gt;
          *   &lt;!-- HandlerMapping --&gt;
          *   &lt;bean

4. RequestMapping的作用：
      * 用于建立请求 URL 和处理请求方法之间的对应关系。
      * 出现位置：
            1. 类上：请求 URL 的第一级访问目录。此处不写的话，就相当于应用的根目录。写的话需要以/开头。它出现的目的是为了使我们的 URL 可以按照模块化管理
            2. 方法上：请求 URL 的第二级访问目录
</code></pre><pre><code>   账户模块：
     /account/add
     /account/update 
     /account/delete 
* account：是在类上
* add、update、delete：是在方法上 
</code></pre><pre><code>5. RequestMapping的属性：
       1. value：用于指定请求的URL。它和path属性的作用是一样的。
       2. method：用于指定请求的方式。
       3.   params：用于指定限制请求参数的条件。它支持简单的表达式。要求请求参数的 key 和 value 必须和 配置的一模一样。
</code></pre><p><code>例如：     params = {&quot;accountName&quot;}，表示请求参数必须有 accountName     params = {&quot;moeny!100&quot;}，表示请求参数中 money 不能是 100。</code>  </p>
<pre><code>4. headers：用于指定限制请求消息头的条件。
* 注意：   以上四个属性只要出现 2 个或以上时，他们的关系是与的关系。
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/570911275/570911275.github.io/2019/07/31/新文档8888/" data-id="cjywzvwmn00303ctnbo9nj86z" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-JavaEE之Spring快速入门之下小结" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/31/JavaEE之Spring快速入门之下小结/" class="article-date">
  <time datetime="2019-07-31T02:38:15.275Z" itemprop="datePublished">2019-07-31</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h2><h3 id="第五章————高级装配"><a href="#第五章————高级装配" class="headerlink" title="第五章————高级装配"></a>第五章————高级装配</h3><pre><code>1. Spring中的单例Bean
    1. 无论我们是否去主动获取bean对象，Spring上下文一加载就会创建bean对象
    2. 无论获取多少次，拿到的都是同一个对象
    3. 无论我们是否去主动获取或注入bean对象，Spring上下文一加载就会创建bean对象
    4. 无论注入多少次，拿到的都是同一个对象

2. bean的作用域
    1. 单例(sinleton)：
        * 在整个应用程序中，只创建bean的一个实例
    2. 原形(prototype)：
        * 每次注入或通过Spring上下文获取的时候，都会创建一个新的bean实例
    3. 会话(session)：
        * 在web应用中，为每个会话创建一个bean实例
    4. 请求(request)：
        * 在web应用中，为每个请求创建一个bean实例
    5. 单例与原形的区别：
          1. 单例：
              * scope=&quot;singleton&quot;
              * 1.无论我们是否去主动获取或注入bean对象，Spring上下文一加载就会创建bean对象
              * 2.无论注入多少次，拿到的都是同一个对象
          2. 原形：
              * scope=&quot;prototype&quot;
              * 1.Spring上下文加载的时候不会创建bean对象
              * 2.每次注入，都会拿到不同的bean对象

3. 自动装配中定义bean的作用域
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/570911275/570911275.github.io/2019/07/31/JavaEE之Spring快速入门之下小结/" data-id="cjywzvwka001o3ctn3mxic8qi" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-JavaEE之Spring快速入门之中小结" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/26/JavaEE之Spring快速入门之中小结/" class="article-date">
  <time datetime="2019-07-26T06:03:21.000Z" itemprop="datePublished">2019-07-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/26/JavaEE之Spring快速入门之中小结/">JavaEE之Spring快速入门之中小结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h2><h3 id="第三章————Java装配"><a href="#第三章————Java装配" class="headerlink" title="第三章————Java装配"></a>第三章————Java装配</h3><pre><code>1. 当我们想将第三方库中的组件装配到应用程序中，则没有办法在类上添加@Compenent和@Autowired等注解

2. 解决方案：显示配置
      * java中进行显示的配置(本章)
      * xml中进行显示的配置(第四章)

3. JavaConfig
     * 不同于自动装配的地方：
         * 无需在实现类标注注解：@Component
         * 无需在AppConfig出标注注解@ComponentScan

     * @Configuration
         * 同自动装配一样，同样需要给AppConfig文件标注此注解；
         * 表示其为配置文件（为JavaConfig的关键）

     * @Bean
         * 说明spring程序启动时会读取到Configuration注解
         * 而Configuration注解会将当前的类当成基础配置类
         * 并且会寻找有没有被标注为Bean的方法，如果有则此方法会在程序启动时自动调用
         * 由Bean标注的方法为单例的
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">AppConfig：</span><br><span class="line"></span><br><span class="line">@Configuration</span><br><span class="line">public class AppConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    //说明spring程序启动时会读取到Configuration注解</span><br><span class="line">    //而Configuration注解会将当前的类当成基础配置类</span><br><span class="line">    //并且会寻找有没有被标注为Bean的方法，如果有则此方法会在程序启动时自动调用</span><br><span class="line">    public UserDao userDaoNormal()&#123;</span><br><span class="line">        System.out.println(&quot;创建UserDao对象&quot;);</span><br><span class="line">        return new UserDaoNormal();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre><code>4. 依赖注入
     * 构造函数
        * 在类中定义构造函数(无参)与有参
        * 有参构造函数将UserDao和UserService关联起来
        * 自动装配时，需要在类名上标注注解@Component;在变量上标注注解@Autowired

     * Bean方法中使用参数
        * 由于实际情况中，在调用new被Bean标记的对象的方法时无新的对象产生
        * 而是之前便存在的。所以可采取不使用new方法

     * setter
        * 通过使用setter方法，进行依赖注入
     * 任意方法
        * 同setter一样，只是改一个方法名
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">1. 自动装配的情况下：</span><br><span class="line">@Service</span><br><span class="line">public class UserServiceNormal implements UserService &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private UserDao userDao;</span><br><span class="line">    public void add() &#123;</span><br><span class="line">        userDao.add();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2.1 带有构造函数的UserServiceNormal类：</span><br><span class="line">public class UserServiceNormal implements UserService &#123;</span><br><span class="line"></span><br><span class="line">    private UserDao userDao;</span><br><span class="line"></span><br><span class="line">    //构造函数注入</span><br><span class="line">    //无参构造函数</span><br><span class="line">    public UserServiceNormal() &#123;</span><br><span class="line">        super();</span><br><span class="line">    &#125;</span><br><span class="line">    //有参构造函数</span><br><span class="line">    //将UserDao和UserService关联起来</span><br><span class="line">    public UserServiceNormal(UserDao userDao) &#123;</span><br><span class="line">        this.userDao = userDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void add() &#123;</span><br><span class="line">        userDao.add();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">2.2 构造函数的情况下：</span><br><span class="line">@Configuration</span><br><span class="line">public class AppConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public UserDao userDaoNormal()&#123;</span><br><span class="line">        System.out.println(&quot;创建UserDao对象&quot;);</span><br><span class="line">        return new UserDaoNormal();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public UserService userServiceNormal()&#123;</span><br><span class="line">        System.out.println(&quot;创建UserService对象&quot;);</span><br><span class="line">        UserDao userDao = userDaoNormal();</span><br><span class="line">        return new UserServiceNormal(userDao);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">3. Bean方法中使用参数</span><br><span class="line">    @Bean</span><br><span class="line">    public UserService userServiceNormal(UserDao userDao)&#123;</span><br><span class="line">        System.out.println(&quot;创建UserService对象&quot;);</span><br><span class="line">        return new UserServiceNormal(userDao);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">4.1 set方法</span><br><span class="line">    public void setUserDao(UserDao userDao) &#123;</span><br><span class="line">        this.userDao = userDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">4.2 setter方法依赖注入</span><br><span class="line">    @Bean</span><br><span class="line">    public UserService userServiceNormal(UserDao userDao)&#123;</span><br><span class="line">        System.out.println(&quot;创建UserService对象&quot;);</span><br><span class="line">        UserServiceNormal userService = new UserServiceNormal();</span><br><span class="line">        userService.setUserDao(userDao);</span><br><span class="line">        return userService;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<pre><code>5. 装配过程的歧义性
     1. 当接口下的多个实现类被标注了Bean注解时将发生歧义性

     2. 同自动装配中使用的方法差不多
           * 首选Bean(@Primary)
              * 调用被标注了注解为@Primary的方法
              * 同样只能有一个@Primary

           * 使用限定符
              * 使用限定符，为每一个Bean标注Qualifier
              * 在使用时，参数位置处的Qualifier需要标注在括号内；而不是类外。

           * 使用限定符和bean id
              * 使用Bean id 同限定符的作用一样
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">1. 首选Bean：</span><br><span class="line">    @Bean</span><br><span class="line">    @Primary</span><br><span class="line">    public UserDao userDaoCache()&#123;...&#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public UserService userServiceNormal(UserDao userDao)&#123;...&#125;</span><br><span class="line"></span><br><span class="line">2. 使用限定符</span><br><span class="line">    @Bean</span><br><span class="line">    @Qualifier(&quot;cache&quot;)</span><br><span class="line">    public UserDao userDaoCache()&#123;...&#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    @Qualifier(&quot;normal&quot;)</span><br><span class="line">    public UserDao userDaoNormal()&#123;...&#125;</span><br><span class="line"></span><br><span class="line">调用方：</span><br><span class="line">    @Bean</span><br><span class="line">    public UserService userServiceNormal(@Qualifier(&quot;normal&quot;)UserDao userDao)&#123;...&#125;</span><br><span class="line">    @Bean</span><br><span class="line">    public UserService userServiceNormal(@Qualifier(&quot;normal&quot;)UserDao userDao)&#123;</span><br><span class="line">        System.out.println(&quot;创建UserService对象&quot;);</span><br><span class="line">        UserServiceNormal userService = new UserServiceNormal();</span><br><span class="line">        userService.prepare(userDao);</span><br><span class="line">        return userService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">3. 使用限定符和Bean id</span><br><span class="line">    @Bean(&quot;cache&quot;)</span><br><span class="line">    public UserDao userDaoCache()&#123;...&#125; </span><br><span class="line"></span><br><span class="line">    @Bean(&quot;normal&quot;)</span><br><span class="line">    public UserDao userDaoNormal()&#123;...&#125;</span><br><span class="line"></span><br><span class="line">调用方：</span><br><span class="line">    @Bean</span><br><span class="line">    public UserService userServiceNormal(@Qualifier(&quot;normal&quot;)UserDao userDao)&#123;...&#125;</span><br></pre></td></tr></table></figure>
<h3 id="第四章————XML装配"><a href="#第四章————XML装配" class="headerlink" title="第四章————XML装配"></a>第四章————XML装配</h3><pre><code>1. 创建Bean对象
    1. 配置applicationContext.xml文件
        * 添加&lt;bean class=&quot;com.qfedu.demo.soundsystem.CompactDisc&quot;/&gt;语句
        * 此语句中的class为bean对象所在的类

    2. 配置文件中存在多个相同Bean对象时，编译器将无法识别是使用哪一个Bean对象
        * 此时需要为Bean对象赋予id
        * &lt;bean  id=&quot;compactDisc1&quot; class=&quot;com.qfedu.demo.soundsystem.CompactDisc&quot;/&gt;
        * &lt;bean  id=&quot;compactDisc2&quot; class=&quot;com.qfedu.demo.soundsystem.CompactDisc&quot;/&gt;

    3. id和name属性
        1. id属性为唯一的，不可重复
        2. name的作用是和id一样的
            * 当有多个name时，可通过空格、分号、逗号进行分割
            * name=&quot;compactDisc1 compacDisc12&quot;
        3. name中Bean对象可以有多个别名，id中Bean只能有一个别名
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">    &lt;bean id=&quot;compactDisc1&quot; class=&quot;com.qfedu.demo.soundsystem.CompactDisc&quot;/&gt;</span><br><span class="line">    &lt;bean id=&quot;compactDisc2&quot; class=&quot;com.qfedu.demo.soundsystem.CompactDisc&quot;/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean name=&quot;compactDisc1 compactDisc12&quot; class=&quot;com.qfedu.demo.soundsystem.CompactDisc&quot;/&gt;</span><br><span class="line">    &lt;bean name=&quot;compactDisc2&quot; class=&quot;com.qfedu.demo.soundsystem.CompactDisc&quot;/&gt;</span><br><span class="line">```             </span><br><span class="line"></span><br><span class="line">           4. 通过构造函数依赖注入</span><br><span class="line">               1. &lt;constructor-arg&gt;元素</span><br><span class="line">                   * 将其他对象作为参数传入此对象中</span><br><span class="line">               2. c-名称空间</span><br><span class="line">                   * 使用C名称空间，声明构造函数的参数；作为了Bean元素的一个属性</span><br><span class="line">                   * c:cd-ref</span><br><span class="line">                        * c: ——&gt;c名称空间的前缀</span><br><span class="line">                        * cd ——&gt;构造函数的参数名称</span><br><span class="line">                        * -ref——&gt;表示我们注入的是另一个Bean对象的引用</span><br></pre></td></tr></table></figure>
<ol>
<li><p><constructor-arg></constructor-arg></p>
 <bean id="CDPlayer1" class="com.qfedu.demo.soundsystem.CDPlayer"><br>     <constructor-arg ref="compactDisc1"><br> </constructor-arg></bean>
</li>
<li><p>c名称空间<br> <bean id="cdPlayer2" class="com.qfedu.demo.soundsystem.CDPlayer" c:cd-ref="compactDisc2"></bean></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">5. 简单类型的注入</span><br><span class="line">     1. 通过&lt;constructor-arg&gt;</span><br><span class="line">          * 默认情况下按照顺序逐个赋值传入对象</span><br><span class="line">     2. c-名称空间</span><br><span class="line">          * c:变量名=“值”</span><br></pre></td></tr></table></figure>
</li>
<li><p><constructor-arg></constructor-arg></p>
 <bean id="compactDisc1" class="com.qfedu.demo.soundsystem.CompactDisc"><br>     <constructor-arg index="0" value="I DO"><br>     <constructor-arg index="1" value="陈奕迅"><br> </constructor-arg></constructor-arg></bean><br> <bean id="compactDisc1" class="com.qfedu.demo.soundsystem.CompactDisc"><br>     <constructor-arg name="title" value="I DO"><br>     <constructor-arg name="artist" value="陈奕迅"><br> </constructor-arg></constructor-arg></bean>
</li>
<li><p>c-名称空间<br> <bean id="compactDisc2" class="com.qfedu.demo.soundsystem.CompactDisc" c:title="周杰伦的床边故事" c:artist="周杰伦"><br> <bean id="compactDisc3" class="com.qfedu.demo.soundsystem.CompactDisc" c:_0="周杰伦的床边故事" c:_1="周杰伦"></bean></bean></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">6. 注入list与数组类型</span><br><span class="line">     1. 简单数据类型的List</span><br><span class="line">            * 使用value</span><br><span class="line">     2. 对象类型的List </span><br><span class="line">            * 先使用Bean创建对象</span><br><span class="line">            * 再使用ref</span><br><span class="line">     3. 数组：只需将list标签改为array即可</span><br></pre></td></tr></table></figure>
</li>
<li><p>简单数据类型</p>
 <bean id="compactDisc1" class="com.qfedu.demo.soundsystem.CompactDisc"><br>     <constructor-arg name="title" value="I DO"><br>     <constructor-arg name="artist" value="陈奕迅"><br>     <constructor-arg name="tracks"><br>         <list><br>             <value>I DO 1</value><br>             <value>I DO 2</value><br>             <value>I DO 3</value><br>         </list><br>     </constructor-arg><br> </constructor-arg></constructor-arg></bean>
</li>
<li><p>对象类型<br>2.1 创建对象<br> <bean id="music1" class="com.qfedu.demo.soundsystem.Music"></bean></p>
<pre><code>&lt;constructor-arg value=&quot;I Do 1&quot;/&gt;
&lt;constructor-arg value=&quot;270&quot;/&gt;
</code></pre><p> <br> <bean id="music2" class="com.qfedu.demo.soundsystem.Music"></bean></p>
<pre><code>&lt;constructor-arg value=&quot;I Do 2&quot;/&gt;
&lt;constructor-arg value=&quot;90&quot;/&gt;
</code></pre><p> <br>2.2 使用ref<br> <bean id="compactDisc1" class="com.qfedu.demo.soundsystem.CompactDisc"></bean></p>
<pre><code>&lt;constructor-arg  name=&quot;title&quot; value=&quot;I DO&quot;/&gt;
&lt;constructor-arg  name=&quot;artist&quot; value=&quot;陈奕迅&quot;/&gt;
&lt;constructor-arg  name=&quot;tracks&quot;&gt;
    &lt;list&gt;
        &lt;ref bean=&quot;music1&quot;/&gt;
        &lt;ref bean=&quot;music2&quot;/&gt;
    &lt;/list&gt;
&lt;/constructor-arg&gt;
</code></pre><p> </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">7. 注入set与数组类型</span><br><span class="line">    1. 用法：同list一样；只需将list标签改为set即可</span><br><span class="line"> </span><br><span class="line">    </span><br><span class="line">    2. 与list的区别：set中不可出现重复的内容；重复的内容将不会再处理 </span><br><span class="line">    </span><br><span class="line">    3. 底层使用的是ListHashSet：使得顺序可以得到保证</span><br><span class="line"></span><br><span class="line">8. 注入map类型</span><br><span class="line">    1. 用法：同list一样；只需改动标签</span><br><span class="line">    </span><br><span class="line">    2. 与list的区别：</span><br><span class="line">         1. 遍历的时候，是遍历key；随后根据key来得到key和value</span><br><span class="line">         2. 在配置文件中的标签要使用&lt;entry &gt;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>遍历：<br>        for (String key : tracks.keySet()) {<br>            System.out.println(“key: “+key);<br>            Music music = tracks.get(key);<br>            System.out.println(“音乐：”+music.getTitle()+”时长：”+music.getDuration());<br>        }</p>
<p>配置文件：<br>    <bean id="compactDisc1" class="com.qfedu.demo.soundsystem.CompactDisc"><br>        <constructor-arg name="title" value="I DO"><br>        <constructor-arg name="artist" value="陈奕迅"><br>        <constructor-arg name="tracks"><br>            <map><br>                <entry key="m1" value-ref="music1"><br>                <entry key="m2" value-ref="music2"><br>                <entry key="m3" value-ref="music3"><br>            </entry></entry></entry></map><br>        </constructor-arg><br>    </constructor-arg></constructor-arg></bean><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">9. 属性注入：</span><br><span class="line">   * 即使用set方法进行依赖注入</span><br><span class="line">    1. 在配置文件中进行Bean对象的依赖注入</span><br><span class="line">         1. 使用property标签</span><br><span class="line">         2. 用name表示属性名</span><br><span class="line">         3. 简单数据用value;引用使用ref</span><br><span class="line">         4. 在配置文件中进行Bean对象的依赖注入后</span><br><span class="line">         *  只要标有注解ContextConfiguration即可自动加载出Bean</span><br></pre></td></tr></table></figure></p>
<p>两个Bean对象的依赖注入：</p>
<pre><code>&lt;bean id=&quot;music1&quot; class=&quot;com.qfedu.demo.soundsystem.Music&quot;&gt;
    &lt;property name=&quot;title&quot; value=&quot;告白气球&quot;/&gt;
    &lt;property name=&quot;duration&quot; value=&quot;215&quot;/&gt;
&lt;/bean&gt;

&lt;bean id=&quot;music2&quot; class=&quot;com.qfedu.demo.soundsystem.Music&quot;&gt;
    &lt;property name=&quot;title&quot; value=&quot;爱情废材&quot;/&gt;
    &lt;property name=&quot;duration&quot; value=&quot;305&quot;/&gt;
&lt;/bean&gt;
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">10. 属性中注入列表和数组：</span><br></pre></td></tr></table></figure>
<pre><code>&lt;bean id=&quot;CompactDisc1&quot; class=&quot;com.qfedu.demo.soundsystem.CompactDisc&quot;&gt;
    &lt;property name=&quot;title&quot; value=&quot;周杰伦的床边故事&quot;/&gt;
    &lt;property name=&quot;artist&quot; value=&quot;周杰伦&quot;/&gt;
    &lt;property name=&quot;tracks&quot;&gt;
        &lt;array&gt;
            &lt;ref bean=&quot;music1&quot;/&gt;
            &lt;ref bean=&quot;music2&quot;/&gt;
        &lt;/array&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">11. 属性中注入对象和引用：</span><br><span class="line">      * 需要配置set方法</span><br><span class="line">      * 随后在配置文件中使用set方法进行依赖注入</span><br></pre></td></tr></table></figure>
<pre><code>public void setCd(CompactDisc cd) {
    this.cd = cd;
    System.out.println(&quot;--在&quot;+this.toString()+&quot;中注入cd&quot;);
}
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">12. p名称空间：</span><br><span class="line">     1. 首先在开头的网站中引入p名称空间</span><br><span class="line">          * xmlns:p=&quot;http://www.springframework.org/schema/p&quot;</span><br><span class="line">     </span><br><span class="line">     2. p名称空间的使用</span><br><span class="line">          * 使用P：属性名=&quot;值&quot;的形式</span><br><span class="line">          * 缺点：无法代替数组、集合等形式</span><br></pre></td></tr></table></figure>
<p>p名称空间的使用</p>
<ol>
<li>简单类型 <bean id="music2" class="com.qfedu.demo.soundsystem.Music" p:title="爱情废柴" p:duration="305"></bean></li>
<li><p>对象的引用<br> &lt;bean id=”CDPlayer1” class=”com.qfedu.demo.soundsystem.CDPlayer”</p>
<pre><code>p:cd-ref=&quot;CompactDisc1&quot;/&gt;
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">13. util名称空间：</span><br><span class="line">      1. 可以处理p无法处理的数组与集合等形式</span><br><span class="line">     </span><br><span class="line">      2. 与c和p的不同：</span><br><span class="line">           * c和p的使用位置是位于元素属性位置</span><br><span class="line">           * util的使用位置是位于元素前缀位置</span><br><span class="line">          </span><br><span class="line">      3. util名称空间的使用：</span><br><span class="line">           1. 在元素前缀加上&lt;util:list&gt;&lt;/util:list&gt;标签。则在网址处将自动添加3个网址</span><br><span class="line">           2. list：可表示list与数组</span><br><span class="line">              map:表示map</span><br><span class="line">              set:表示set</span><br></pre></td></tr></table></figure>
<p> &lt;util:list id=”trackList”&gt;</p>
<pre><code>&lt;ref bean=&quot;music1&quot;/&gt;
&lt;ref bean=&quot;music2&quot;/&gt;
</code></pre><p> &lt;/util:list&gt;<br> &lt;bean id=”CompactDisc1” class=”com.qfedu.demo.soundsystem.CompactDisc”</p>
<pre><code>p:title=&quot;周杰伦的床边故事&quot;
p:artist=&quot;周杰伦&quot;
p:tracks-ref=&quot;trackList&quot;&gt;
</code></pre><p> <br><code>`</code></p>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/570911275/570911275.github.io/2019/07/26/JavaEE之Spring快速入门之中小结/" data-id="cjywzvwnl003i3ctn8y4hwoyn" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/javaEE-基础/">javaEE_基础</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-JavaEE之Spring快速入门之上小结" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/26/JavaEE之Spring快速入门之上小结/" class="article-date">
  <time datetime="2019-07-26T01:57:41.000Z" itemprop="datePublished">2019-07-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/26/JavaEE之Spring快速入门之上小结/">JavaEE之Spring快速入门之上小结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h2><h3 id="第一章————入门"><a href="#第一章————入门" class="headerlink" title="第一章————入门"></a>第一章————入门</h3><pre><code>1. 概念：
   * Spring是一个非常活跃的开源框架
   * 由Rod Johnson开发
   * 帮助分离项目组件之间的依赖关系
   * 它的主要目的是简化企业开发

2. 核心概念：
   1. IOC
       * Inversion of Control
       * 控制反转
       * 对象创建以及对象之间的依赖关系的维护交给Spring
   2. DI
       * Dependency Injection
       * 依赖注入
       * 对象和对象之间的依赖关系的创建
   3. AOP
       * Aspect Oriented Programming
       * 面向切面编程

3. log4j日志
       * 导入依赖
       * *导入配置文件
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">配置文件：</span><br><span class="line"></span><br><span class="line">log4j.rootCategory=INFO, stdout</span><br><span class="line"></span><br><span class="line">log4j.appender.stdout=org.apache.log4j.ConsoleAppender</span><br><span class="line">log4j.appender.stdout.layout=org.apache.log4j.PatternLayout</span><br><span class="line">log4j.appender.stdout.layout.ConversionPattern=%d&#123;ABSOLUTE&#125; %5p %t %c&#123;2&#125;:%L - %m%n</span><br><span class="line"></span><br><span class="line">log4j.category.org.springframework.beans.factory=DEBUG</span><br><span class="line"></span><br><span class="line">导入依赖</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;log4j&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;log4j&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.2.17&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<pre><code>4. 入门程序的应用
     1. 注解方式的使用
          1. @Component
              * 此注解的作用为通知spring容器，
              * 我们应用程序的对象——此例子中为MessageService
              * 未来将通过Spring容器进行创建；无需人工new创建
          2. @ComponentScan
              * 基于注解的方式来初始化Spring容器
              * 主键扫描注解
              * 即扫描一切有注解Component的类
          3. @Autowired
              * 表示调用MessagePrinter类时，将会自动调用此方法
              * 即自动关联起MessagePrinter和MessageService的关系
     2. xml文件配置方式的使用
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--</span><br><span class="line">   bean元素：描述当前的对象需要由spring容器管理</span><br><span class="line">   id属性：标识对象，未来在应用程序中可以根据id获取对象</span><br><span class="line">   class：被管理对象的类全名</span><br><span class="line"> --&gt;</span><br><span class="line">&lt;bean id=&quot;service&quot; class=&quot;hello.MessageService&quot;&gt;&lt;/bean&gt;</span><br><span class="line">&lt;bean id=&quot;printer&quot; class=&quot;hello.MessagePrinter&quot;&gt;</span><br><span class="line">    &lt;!--name属性的值：与MessagePrinter中的service属性对应</span><br><span class="line">        ref：表示name属性指向的对象；在此例中，此对象为id=service的bean对象--&gt;</span><br><span class="line">    &lt;property name=&quot;service&quot; ref=&quot;service&quot;&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>
<h3 id="第二章————自动装配"><a href="#第二章————自动装配" class="headerlink" title="第二章————自动装配"></a>第二章————自动装配</h3><pre><code>1. bean对象的装配：
    1. 依赖注入的概念：
       * 通过Spring来管理对象和对象之间的依赖关系
    2. java中的对象称为bean对象
       * 把在java中创建bean对象和为这个对象注入依赖的过程称为装配bean或bean的装配

2. 装配bean的三种方式
     * 隐式的bean发现机制和自动装配
     * 在java中进行显示的配置
     * 在xml中进行显示的配置

3. 自动装配中的注解：
    1. 组件扫描：
         * @Component：表示这个类需要在应用程序中被创建
         * @ComponentScan：自动发现应用程序中创建的类
    2. 自动装配：
         * @Autowired：自动满足bean之间的依赖
    3. 定义配置类：
         * @Configuration：表示当前类是一个配置类
         * 作用：
             * 将ComponentScan注解与main主函数进行解耦
             * 使得在不存在main主函数时，可以在其他环境(web、安卓、iOS)下进行组件扫描

4. Junit4单元测试
     1. 引入依赖
           1. Maven：Junit、Spring-test
           2. @RunWith(SpringJUnit4ClassRunner.class)
              * 此注解为自动生成Spring的上下文环境
     2. 加载配置类
           1. @ContextConfiguration(classes=Appconfig.class)
              * 读取配置文件
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@RunWith(SpringJUnit4ClassRunner.class)</span><br><span class="line">////此注解为自动生成Spring的上下文环境</span><br><span class="line">@ContextConfiguration(classes=Appconfig.class)</span><br><span class="line">////读取配置文件</span><br><span class="line">public class AppTest &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private CDPlayer player;</span><br><span class="line">    @Test</span><br><span class="line">    public void testPlay()&#123;</span><br><span class="line">        player.play();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre><code>5. AutoWriter的应用场景
     1. 构造函数（*）
          * 自动将构造函数中的参数装配到当前类的bean对象中
          * *多个依赖的情况
          * 效率最高
     2. 用在成员变量上
          * 最便捷
     3. 用在setter方法上
     4. 用在任意方法上
     5. required属性
       *  应用场景：
          * @Autowired(required = false)[默认为true]
          * 表示注入的对象是可选的
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">1. 构造方法</span><br><span class="line">    @Autowired</span><br><span class="line">    public CDPlayer(CompactDisc cd, Power power) &#123;</span><br><span class="line">        this.cd = cd;</span><br><span class="line">        this.power = power;</span><br><span class="line">        System.out.println(&quot;CDPlayer的多参数构造函数&quot;);</span><br><span class="line"></span><br><span class="line">2. 成员变量</span><br><span class="line">    //@Autowired</span><br><span class="line">    private CompactDisc cd;</span><br><span class="line">    //@Autowired</span><br><span class="line">    private Power power;</span><br><span class="line"></span><br><span class="line">3. setter方法</span><br><span class="line">    @Autowired</span><br><span class="line">    public void setCd(CompactDisc cd) &#123;</span><br><span class="line">        this.cd = cd;</span><br><span class="line">        System.out.println(&quot;CD&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    @Autowired</span><br><span class="line">    public void setPower(Power power) &#123;</span><br><span class="line">        this.power = power;</span><br><span class="line">        System.out.println(&quot;POWER&quot;);</span><br><span class="line"></span><br><span class="line">4. 任意方法</span><br><span class="line">    @Autowired</span><br><span class="line">    public void prepare(CompactDisc cd ,Power power)&#123;</span><br><span class="line">        this.cd = cd;</span><br><span class="line">        this.power = power;</span><br><span class="line">        System.out.println(&quot;prepare&quot;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<pre><code>6. 使用接口
    1. 应用场景：
         * @Autowired(required = false)
         * 表示注入的对象是可选的
    2. 自动装配的歧义性
         * 当接口下有多个实现类且都使用了@Component注解
         * 所以当他们被扫描的时候能在Spring应用上下文里面的bean
         * 这时进行自动装配，将会发生歧义性
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class UserServiceFestival implements UserService &#123;...&#125;</span><br><span class="line"></span><br><span class="line">@Component</span><br><span class="line">public class UserServiceNormal implements UserService &#123;...&#125;</span><br></pre></td></tr></table></figure>
<pre><code>3. 自动装配的歧义性的解决方案
     1. 设置首选Bean(primary)
         * 在声明类的时候使用@Primary
         * 只能定义一个@Primary
         * 缺点：如果我们不止一个primary那么编译器将报错。则首选就没有办法解决歧义性
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">@Primary</span><br><span class="line">public class UserServiceNormal implements UserService &#123;...&#125;</span><br></pre></td></tr></table></figure>
<pre><code>2. 使用限定符(Qualifier)
    * 在声明的时候和装配的时候分别使用@Qualifier
    * 通过在实现类标识注解Qualifier，可使得调用接口时，让Spring确认是需要是需要传输该接口下的哪一个Bean对象
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">实现类：</span><br><span class="line">@Component</span><br><span class="line">@Qualifier(&quot;festival&quot;)</span><br><span class="line">public class UserServiceFestival implements UserService &#123;...&#125;</span><br><span class="line"></span><br><span class="line">@Component</span><br><span class="line">@Qualifier(&quot;normal&quot;)</span><br><span class="line">public class UserServiceNormal implements UserService &#123;...&#125;</span><br><span class="line"></span><br><span class="line">调用接口：</span><br><span class="line">@RunWith(SpringJUnit4ClassRunner.class)</span><br><span class="line">@ContextConfiguration(classes = AppConfig.class)</span><br><span class="line">public class UserServiceTest &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    @Qualifier(&quot;festival&quot;)</span><br><span class="line">    private UserService userService;</span><br><span class="line">    @Test</span><br><span class="line">    public void testAdd()&#123;</span><br><span class="line">        userService.add();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre><code>3. 使用类ID
     * 在声明的的时候指定bean的id（默认的id是首写字母小写的类名）
     * 在装配的时候使用@Qualifier
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">无默认时：</span><br><span class="line"></span><br><span class="line">实现类：</span><br><span class="line">@Component(&quot;festival&quot;)</span><br><span class="line">public class UserServiceFestival implements UserService &#123;...&#125;</span><br><span class="line">调用接口：</span><br><span class="line">public class UserServiceTest &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    @Qualifier(&quot;festival&quot;)</span><br><span class="line">    private UserService userService;</span><br><span class="line">    @Test</span><br><span class="line">    public void testAdd()&#123;</span><br><span class="line">        userService.add();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">默认时：</span><br><span class="line"></span><br><span class="line">实现类：</span><br><span class="line">@Component</span><br><span class="line">public class UserServiceFestival implements UserService &#123;...&#125;</span><br><span class="line">调用接口：</span><br><span class="line">public class UserServiceTest &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    @Qualifier(&quot;userServiceFestival&quot;)</span><br><span class="line">    private UserService userService;</span><br><span class="line">    @Test</span><br><span class="line">    public void testAdd()&#123;</span><br><span class="line">        userService.add();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre><code>4. 使用Java标准的解决方案(Resource)
     * 此方法并非Spring中的标准
     * 使用此方法可替代下边两个注解
         * @Autowired
         * @Qualifier
     * 用法同类ID
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/*    @Autowired</span><br><span class="line"> @Qualifier(&quot;festival&quot;)*/</span><br><span class="line"> @Resource(name=&quot;userServiceFestival&quot;)</span><br><span class="line"> private UserService userService;</span><br></pre></td></tr></table></figure>
<pre><code>7. 处理分层结构
    1. web程序的基本架构：
        浏览器——&gt;web层(controller)——&gt;业务层(service)——&gt;数据访问层(dao)——Data
           * 其中业务层(service)、数据访问层(dao)皆细分为接口与实现类
    2. 新的注解(Repository、service、controller)
        * Repository——dao层
        * service——service层
        * controller——web层
        * 这三个注解可替换掉@Component，更加明确的标注了此类是什么层次的类


8. 设置组件扫描的基础包
     1. 默认情况下@ComponentScan只可扫描其所在的包以及其子包下的类

     2. 解决方案：
         1. @ComponentScan(&quot;包名&quot;)
            * @ComponentScan(&quot;com.qfedu.demo&quot;)
              * 指定扫描的包名
         2. @ComponentScan(basePackages = {&quot;包名&quot;,&quot;包名&quot;,&quot;包名&quot;}) 
            * @ComponentScan(basePackages = {&quot;com.qfedu.demo.web&quot;,&quot;com.qfedu.demo.service&quot;,&quot;com.qfedu.demo.dao&quot;}) 
              * 可指定多个扫描的包名
         3. @ComponentScan(basePackagesClasses = {类名,类名,类名})
            * @ComponentScan(basePackagesClasses = {UserController.class,UserService.class,UserDao.class})
              * 可指定多个扫描的类名

     3. 通过xml启用组件扫描
         1. 配置applicationContext.xml文件(此文件的作用相当于注解@Configuration)
              * @Configuration的作用：表示该文件为配置文件

         2. 使用标签&lt;context:component-scan&gt;
              * &lt;context:component-scan base-package=&quot;com.qfedu.demo&quot;/&gt;
              * 此标签的作用相当于注解@ComponentScan(&quot;com.qfedu.demo&quot;)
              * 规划了扫描范围

         3. 使用时注解同样要发生变化
              * @ContextConfiguration(&quot;classpath:applicationContext.xml&quot;)
              * 代替了@ContextConfiguration(classes = AppConfig.class)
              * 使得其配置文件从Appconfig.class变化为applicationContext。xml配置文件

9. 小结
   1. 定义配置：
      * @Configuration
      * ComponentScan

   2. 定义组件
      * @Component
      * @Autowired
      * @Autowired(required = false)

   3. 自动装配歧义性
      * @Primary
      * @Qualifier
      * @Resource

   4. 分层架构中定义组件
      * Controller
      * Service

   5. Spring测试环境
      * RunWith
      * ContextConfiguration

   6. 使用xml启用组件扫描
      * &lt;context:component-scan base-package=&quot;...&quot;&gt;
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/570911275/570911275.github.io/2019/07/26/JavaEE之Spring快速入门之上小结/" data-id="cjywzvwnn003k3ctndvh9oqca" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/javaEE-基础/">javaEE_基础</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-JavaEE之MyBatis高级知识之下小结" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/25/JavaEE之MyBatis高级知识之下小结/" class="article-date">
  <time datetime="2019-07-25T10:52:11.000Z" itemprop="datePublished">2019-07-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/25/JavaEE之MyBatis高级知识之下小结/">JavaEE之MyBatis高级知识之下小结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="MyBatis"><a href="#MyBatis" class="headerlink" title="MyBatis"></a>MyBatis</h2><pre><code>1. 基础知识（重点，内容多）
    对原生态jdbc程序（单独使用jdbc开发）问题总结
    mybatis框架原理（掌握）
    mybatis入门程序
         用户的增删改查
    mybatis开发两种方法：
         原始dao开发方法（程序需要编写dao接口和dao实现类）（掌握）
         mybaits的mapper接口（相当于dao接口）代理开发方法（掌握）
    mybatis配置文件SqlMapConfig.xml
    mybatis核心：
         mybatis输入映射（掌握）
         mybatis输出映射（掌握）
    mybatis的动态SQL（掌握）

 2. 高级知识
    订单商品数据模型分析
    高级结果集映射（一对一，一对多，多对多）
    mybatis延迟加载
    mybatis查询缓冲（一级缓冲、二级缓冲）
    mybaits和spring进行整合（掌握）
    mybatis逆向工程
</code></pre><h3 id="一、高级知识"><a href="#一、高级知识" class="headerlink" title="一、高级知识"></a>一、高级知识</h3><h4 id="1-mybatis查询缓存（一级缓存、二级缓存）————mybatis整合ehcache："><a href="#1-mybatis查询缓存（一级缓存、二级缓存）————mybatis整合ehcache：" class="headerlink" title="1. mybatis查询缓存（一级缓存、二级缓存）————mybatis整合ehcache："></a>1. mybatis查询缓存（一级缓存、二级缓存）————mybatis整合ehcache：</h4><pre><code>1. ehcache:
    * ehcache是一个分布式缓存框架

2. 分布缓存：
    * 我们系统为了提高系统并发，性能、一般对系统进行分布式部署（集群部署方式）
    * 不使用分布缓存，缓存的数据在各各服务单独存储，不方便系统 开发。所以要使用分布式缓存对缓存数据进行集中管理。
    * 对缓存数据进行集中管理（redis集群）使用分布式缓存框架
       * 如：redis、memcached、ehcache。。。
    * mybatis无法实现分布式缓存，因此需要和其它分布式缓存框架进行整合。

3. 整合方法：
    1. 引入缓存的依赖包
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.ehcache&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;ehcache&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;3.8.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.mybatis.caches&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;mybatis-ehcache&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.1.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<pre><code>2. 引入缓存配置文件
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;ehcache xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">         xsi:noNamespaceSchemaLocation=&quot;http://ehcache.org/ehcache.xsd&quot;&gt;</span><br><span class="line">    &lt;diskStore path=&quot;D:\ehcache&quot;/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 默认缓存配置 --&gt;</span><br><span class="line">    &lt;defaultCache</span><br><span class="line">            maxElementsInMemory=&quot;10000&quot;</span><br><span class="line">            eternal=&quot;false&quot;</span><br><span class="line">            timeToIdleSeconds=&quot;120&quot;</span><br><span class="line">            timeToLiveSeconds=&quot;120&quot;</span><br><span class="line">            overflowToDisk=&quot;true&quot;</span><br><span class="line">    /&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;/ehcache&gt;</span><br></pre></td></tr></table></figure>
<pre><code>3. 引入xsd的url
   * 打开settings-&gt;languages&amp;frameworks-&gt;schemas and dtds ,添加地址 http://ehcache.org/ehcache.xsd

4. 开启ehcache缓存
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">修改mapper.xml文件，在cache中指定EhcacheCache。</span><br><span class="line">&lt;cache type=&quot;org.mybatis.caches.ehcache.EhcacheCache&quot;/&gt;</span><br><span class="line"></span><br><span class="line">根据需求调整缓存参数：</span><br><span class="line">&lt;cache type=&quot;org.mybatis.caches.ehcache.EhcacheCache&quot; &gt; </span><br><span class="line">        &lt;property name=&quot;timeToIdleSeconds&quot; value=&quot;3600&quot;/&gt;</span><br><span class="line">        &lt;property name=&quot;timeToLiveSeconds&quot; value=&quot;3600&quot;/&gt;</span><br><span class="line">        &lt;!-- 同ehcache参数maxElementsInMemory --&gt;</span><br><span class="line">		&lt;property name=&quot;maxEntriesLocalHeap&quot; value=&quot;1000&quot;/&gt;</span><br><span class="line">		&lt;!-- 同ehcache参数maxElementsOnDisk --&gt;</span><br><span class="line">        &lt;property name=&quot;maxEntriesLocalDisk&quot; value=&quot;10000000&quot;/&gt;</span><br><span class="line">        &lt;property name=&quot;memoryStoreEvictionPolicy&quot; value=&quot;LRU&quot;/&gt;</span><br><span class="line">    &lt;/cache&gt;</span><br></pre></td></tr></table></figure>
<h4 id="2-mybaits和spring进行整合（掌握）"><a href="#2-mybaits和spring进行整合（掌握）" class="headerlink" title="2. mybaits和spring进行整合（掌握）"></a>2. mybaits和spring进行整合（掌握）</h4><pre><code>1. 整合思路：
    1. 需要spring通过单例方式管理SqlSessionFactory
    2. spring和mybatis整合生成代理对象，使用SqlSessionFactory创建SqlSession。（Spring和mybatis整合自动完成）
    3. 持久层的mapper都需要由spring进行管理

2. 整合环境
    1. 导入jar包
        * mybatis
        * spring
        * mybatis_spring整合包
        * 此处为了方便，直接导入mybatis、spring、springMVC的整合

3. sqlSessionFactory
     1. 在applicationContext.xml配置sqlSessionFactory和数据源
     2. sqlSessionFactory在mybatis和spring的整合包下
</code></pre><pre><code>&lt;!-- 加载db.properties文件 --&gt;
&lt;context:property-placeholder location=&quot;classpath:db.properties&quot;/&gt;

   &lt;!-- 配置数据库连接池 --&gt;
   &lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt;
       &lt;property name=&quot;driverClassName&quot; value=&quot;${jdbc.driver}&quot;&gt;&lt;/property&gt;
       &lt;property name=&quot;url&quot; value=&quot;${jdbc.url}&quot;&gt;&lt;/property&gt;
       &lt;property name=&quot;username&quot; value=&quot;${jdbc.username}&quot;&gt;&lt;/property&gt;
       &lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot;&gt;&lt;/property&gt;
   &lt;/bean&gt;

   &lt;!--sqlSessionFactory--&gt;
   &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;
       &lt;!--加载mybatis的配置文件--&gt;
       &lt;property name=&quot;configLocation&quot; value=&quot;SqlMapConfig.xml&quot;/&gt;
       &lt;!--数据源--&gt;
       &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;
   &lt;/bean&gt;
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/570911275/570911275.github.io/2019/07/25/JavaEE之MyBatis高级知识之下小结/" data-id="cjywzvwjg00193ctnr03g98rs" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/javaEE-基础/">javaEE_基础</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-JavaEE之MyBatis高级知识之中小结" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/25/JavaEE之MyBatis高级知识之中小结/" class="article-date">
  <time datetime="2019-07-25T06:06:16.000Z" itemprop="datePublished">2019-07-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/25/JavaEE之MyBatis高级知识之中小结/">JavaEE之MyBatis高级知识之中小结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="MyBatis"><a href="#MyBatis" class="headerlink" title="MyBatis"></a>MyBatis</h2><pre><code>1. 基础知识（重点，内容多）
    对原生态jdbc程序（单独使用jdbc开发）问题总结
    mybatis框架原理（掌握）
    mybatis入门程序
         用户的增删改查
    mybatis开发两种方法：
         原始dao开发方法（程序需要编写dao接口和dao实现类）（掌握）
         mybaits的mapper接口（相当于dao接口）代理开发方法（掌握）
    mybatis配置文件SqlMapConfig.xml
    mybatis核心：
         mybatis输入映射（掌握）
         mybatis输出映射（掌握）
    mybatis的动态SQL（掌握）

 2. 高级知识
    订单商品数据模型分析
    高级结果集映射（一对一，一对多，多对多）
    mybatis延迟加载
    mybatis查询缓冲（一级缓冲、二级缓冲）
    mybaits和spring进行整合（掌握）
    mybatis逆向工程
</code></pre><h3 id="一、高级知识"><a href="#一、高级知识" class="headerlink" title="一、高级知识"></a>一、高级知识</h3><h4 id="1-mybatis延迟加载："><a href="#1-mybatis延迟加载：" class="headerlink" title="1. mybatis延迟加载："></a>1. mybatis延迟加载：</h4><pre><code>1. 概念：
    * resultMap可以实现高级映射(使用association、collection实现一对一及一对多映射)，association、collection具备延迟加载功能。
    * 需求：
       * 如果查询订单并且关联查询用户信息。如果先查询订单信息即可满足要求，当我们需要查询用户信息时再查询用户信息。把对用户信息的按需去查询就是延迟加载
    * 延迟加载：先从单表查询，需要时再从关联表去关联查询，大大提高数据库性能，因为查询单表要比关联表查询多张表速度要快

2. 使用association实现延迟加载：
  * 查询订单并且关联查询用户信息
     1. mapper.xml
       * 需要定义两个mapper的方法对呀的statement
       1. 只查询订单信息
       SELECT * FROM orders
       在查询订单的statement中使用association去延迟加载（执行）下边的satatement关联查询用户信息
       2. 关联查询用户信息
           *通过上边查询到的订单信息中的user_id去关联查询用户信息

 2.1 定义延迟加载resultMap
      **使用association中的select指定延迟加载去执行的statement的id**
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;resultMap type=&quot;cn.itcast.po.Orders&quot; id=&quot;OrderUserLazyLoadingResultMap&quot;&gt;</span><br><span class="line">     &lt;!--对订单信息进行映射配置--&gt;</span><br><span class="line">     &lt;id column=&quot;id&quot; property=&quot;id&quot;/&gt;</span><br><span class="line">     &lt;result column=&quot;user_id&quot; property=&quot;userId&quot;/&gt;</span><br><span class="line">     &lt;result column=&quot;createtime&quot; property=&quot;createtime&quot;/&gt;</span><br><span class="line">     &lt;result column=&quot;note&quot; property=&quot;note&quot;/&gt;</span><br><span class="line">     &lt;result column=&quot;number&quot; property=&quot;number&quot;/&gt;</span><br><span class="line">     &lt;!--对用户信息进行延迟加载--&gt;</span><br><span class="line">     &lt;!--select：指定延迟加载需要执行的statement的id（是根据user_id去查询用户信息的statement）</span><br><span class="line">         要使用userMapper.xml中findUserById完成根据用户id(user_id)用户信息的查询</span><br><span class="line">         如果findUserById不在本mapper中，前面需要加namespace</span><br><span class="line">         column：订单的信息中关联用户信息查询的列，是user_id</span><br><span class="line">         关联查询的SQL理解为：</span><br><span class="line">             SELECT orders.*,</span><br><span class="line">            (SELECT username FROM USER WHERE orders.`user_id`=user.`id`)username,</span><br><span class="line">            (SELECT sex FROM USER WHERE orders.`user_id`=user.`id`)sex</span><br><span class="line">             FROM orders--&gt;</span><br><span class="line">     &lt;association property=&quot;user&quot; javaType=&quot;cn.itcast.po.User&quot; select=&quot;cn.itcast.mapper.UserMapper.findUserById&quot; column=&quot;user_id&quot;&gt;</span><br><span class="line"></span><br><span class="line">     &lt;/association&gt;</span><br><span class="line"> &lt;/resultMap&gt;</span><br></pre></td></tr></table></figure>
<pre><code>2.2 mapper.xml
  1. 只查询订单信息
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id=&quot;findOrderUserLazyLoading&quot; resultMap=&quot;OrderUserLazyLoadingResultMap&quot;&gt;</span><br><span class="line">    SELECT * FROM orders</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure>
<pre><code>2. 关联查询用户信息
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id=&quot;findUserById&quot; parameterType=&quot;int&quot; resultType=&quot;cn.itcast.po.User&quot;&gt;</span><br><span class="line">      SELECT * FROM USER WHERE id=#&#123;id&#125;</span><br><span class="line"> &lt;/select&gt;</span><br></pre></td></tr></table></figure>
<pre><code>  3. 思路：
      * 上边先去执行findOrdersUserLazyLoding,当需要去查询用户的时候再去执行findUserById，通过resultMap的定义将延迟加载配置起来

2.3 mapper.java
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//查询订单关联用户信息，用户信息使用延迟加载</span><br><span class="line">public List&lt;Orders&gt; findOrderUserLazyLoading() throws Exception;</span><br></pre></td></tr></table></figure>
<pre><code>2.4 测试思路：
    1. 执行上边mapper方法(findOrdersUserLazyLoading)，内部去调用cn.itcast.mapper.OrdersMapperCustom中的findOrdersUserLazyLoading,只查询orders信息（单表）
    2. 在程序汇总去遍历上一步查询出的List&lt;Orders&gt;，当我们调用Orders中的getUser方法时，开始进行延迟加载
    3. 延迟加载，去调用UserMapper.xml中的findUserbyId这个方法获取用户信息

2.5 延迟加载配置：
    * mybatis默认没有开启延迟加载，需要在SqlMapConfig.xml中setting配置
    *  设置项                      描述                           允许值          默认值
  lazyLoadingEnabled        全局性设置懒加载。如果设为‘false’， true | false      false
                            则所有相关联的都会被初始化加载。    

  aggressiveLazyLoading        当设置为‘true’的时候，             true | false      true
                            懒加载的对象可能被任何懒属性全部加载。
                            否则，每个属性都按需加载。    
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--全局配置参数，需要时再设置--&gt;</span><br><span class="line">&lt;settings&gt;</span><br><span class="line">    &lt;!--打开延迟加载的开关--&gt;</span><br><span class="line">    &lt;setting name=&quot;lazyLoadingEnabled&quot; value=&quot;true&quot;/&gt;</span><br><span class="line">    &lt;setting name=&quot;aggressiveLazyLoading&quot; value=&quot;false&quot;/&gt;</span><br><span class="line">&lt;/settings&gt;</span><br></pre></td></tr></table></figure>
<pre><code>2.5 测试类
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public void findOrderUserLazyLoading() throws Exception&#123;</span><br><span class="line">    //mybatis配置文件</span><br><span class="line">    String resource = &quot;SqlMapConfig.xml&quot;;</span><br><span class="line">    //得到配置文件流</span><br><span class="line">    InputStream inputStream = Resources.getResourceAsStream(resource);</span><br><span class="line">    //创建会话工厂,传入mybatis的配置文件信息</span><br><span class="line">    SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);</span><br><span class="line">    SqlSession sqlSession = sqlSessionFactory.openSession();</span><br><span class="line">    //创建OrdersMapperCustom对象，mybatis自动生成OrderMapperCustom代理对象</span><br><span class="line">    OrdersMapperCustom ordersMapperCustom = sqlSession.getMapper(OrdersMapperCustom.class);</span><br><span class="line"></span><br><span class="line">    //查询订单信息（单表）</span><br><span class="line">    List&lt;Orders&gt;  list = ordersMapperCustom.findOrderUserLazyLoading();</span><br><span class="line">    //遍历上边的订单列表</span><br><span class="line">    for (Orders orders : list) &#123;</span><br><span class="line">        //执行getUser()去查询用户信息，这里实现按需加载</span><br><span class="line">         User user = orders.getUser();</span><br><span class="line">        System.out.println(user);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    sqlSession.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre><code>2.6 延迟加载思考
   * 不使用mybatis提供的association及collection中的延迟加载功能如何实现延迟加载？
   * 实现方法：
       * 定义两个mapper方法：
          1. 查询订单列表
          2. 根据用户id查询用户信息
   * 实现思路：
       * 先去查询第一个mapper方法，获取订单信息列表
       * 在程序中（service），按需去调用第二个mapper方法去查询用户信息

2.7 延迟加载总结
   * 使用延迟加载方法，先去查询简单的SQL（最好单表，也可以关联查询），再去按需要加载关联查询的其他信息 
</code></pre><h4 id="2-mybatis查询缓存（一级缓存、二级缓存）————一级缓存："><a href="#2-mybatis查询缓存（一级缓存、二级缓存）————一级缓存：" class="headerlink" title="2. mybatis查询缓存（一级缓存、二级缓存）————一级缓存："></a>2. mybatis查询缓存（一级缓存、二级缓存）————一级缓存：</h4><pre><code>1. 一级缓存和二级缓存的定义：
     1. Mybatis一级缓存的作用域是同一个SqlSession，在同一个sqlSession中两次执行相同的sql语句，第一次执行完毕会将数据库中查询的数据写到缓存（内存），第二次会从缓存中获取数据将不再从数据库查询，从而提高查询效率。当一个sqlSession结束后该sqlSession中的一级缓存也就不存在了。Mybatis默认开启一级缓存。

     2. Mybatis二级缓存是多个SqlSession共享的，其作用域是mapper的同一个namespace，不同的sqlSession两次执行相同namespace下的sql语句且向sql中传递参数也相同即最终执行相同的sql语句，第一次执行完毕会将数据库中查询的数据写到缓存（内存），第二次会从缓存中获取数据将不再从数据库查询，从而提高查询效率。Mybatis默认没有开启二级缓存需要在setting全局参数中配置开启二级缓存。

2. 一级缓存的流程：
     1. 第一次发起查询用户id为1的用户信息，先去找缓存中是否有id为1的用户信息，如果没有从数据库查询用户信息得到用户信息，将用户信息存储到一级缓存中
     2. 如果SqlSession去执行commit操作（执行插入、更新、删除），情况SqlSession中的一级缓存，这样做的目的是让缓存中存储的是最      新的信息，避免脏读。
     3. 第二次发起查询用户id为1的用户信息，先去找缓存中是否有id为1的用户信息，缓存汇总有，直接从缓存中获取用户信息 

3. 一级缓存的测试：
     * mybatis默认支持一级缓存，不需要在配置文件中去配置
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">	public void testCache1() throws Exception&#123;</span><br><span class="line">		SqlSession sqlSession = sqlSessionFactory.openSession();//创建代理对象</span><br><span class="line">		UserMapper userMapper = sqlSession.getMapper(UserMapper.class);</span><br><span class="line">		</span><br><span class="line">		//下边查询使用一个SqlSession</span><br><span class="line">		//第一次发起请求，查询id为1的用户</span><br><span class="line">		User user1 = userMapper.findUserById(1);</span><br><span class="line">		System.out.println(user1);</span><br><span class="line">		</span><br><span class="line">//		如果sqlSession去执行commit操作（执行插入、更新、删除），清空SqlSession中的一级缓存，这样做的目的为了让缓存中存储的是最新的信息，避免脏读。</span><br><span class="line">		</span><br><span class="line">		//更新user1的信息</span><br><span class="line">		user1.setUsername(&quot;测试用户22&quot;);</span><br><span class="line">		userMapper.updateUser(user1);</span><br><span class="line">		//执行commit操作去清空缓存</span><br><span class="line">		sqlSession.commit();</span><br><span class="line">		</span><br><span class="line">		//第二次发起请求，查询id为1的用户</span><br><span class="line">		User user2 = userMapper.findUserById(1);</span><br><span class="line">		System.out.println(user2);</span><br><span class="line">		</span><br><span class="line">		sqlSession.close();</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<pre><code>3. 一级缓存的实际运用：
   * 正式开放：是将mybatis和spring进行整合开发，事务控制在service中。
   * 一个service方法中包括很多mapper方法调用
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">service&#123;</span><br><span class="line">    //开始执行时，开启事务，创建SqlSession对象</span><br><span class="line">    //第一次调用mapper的方法findUserById(1)</span><br><span class="line">  </span><br><span class="line">    //第二次调用mapper的方法findUserById(1)从一级缓存中取数据</span><br><span class="line">    //方法介绍，SqlSession关闭</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre><code>* 如果是执行两次service调用查询相同的用户信息，不走一级缓存，因为session方法结束，sqlSession就关闭，一级缓存就清空  
* 
</code></pre><h4 id="1-mybatis查询缓存（一级缓存、二级缓存）————二级缓存："><a href="#1-mybatis查询缓存（一级缓存、二级缓存）————二级缓存：" class="headerlink" title="1. mybatis查询缓存（一级缓存、二级缓存）————二级缓存："></a>1. mybatis查询缓存（一级缓存、二级缓存）————二级缓存：</h4><pre><code>1. 一级缓存和二级缓存的定义：
     1. Mybatis一级缓存的作用域是同一个SqlSession，在同一个sqlSession中两次执行相同的sql语句，第一次执行完毕会将数据库中查询的数据写到缓存（内存），第二次会从缓存中获取数据将不再从数据库查询，从而提高查询效率。当一个sqlSession结束后该sqlSession中的一级缓存也就不存在了。Mybatis默认开启一级缓存。

     2. Mybatis二级缓存是多个SqlSession共享的，其作用域是mapper的同一个namespace，不同的sqlSession两次执行相同namespace下的sql语句且向sql中传递参数也相同即最终执行相同的sql语句，第一次执行完毕会将数据库中查询的数据写到缓存（内存），第二次会从缓存中获取数据将不再从数据库查询，从而提高查询效率。Mybatis默认没有开启二级缓存需要在setting全局参数中配置开启二级缓存。

2. 二级缓存的流程：
     1. 首先开启mybatis的二级缓存
     2. sqlSession1去查询用户id为1的用户信息，查询到用户信息会将查询数据存储到二级缓存中
     3. sqlSession2去查询用户id为1的用户信息，去缓存中找是否存在数据，如果存在直接从缓存中取出数据
     4. 如果sqlSession3去执行相同mapper下的SQL，执行commit提交，清空该mapper下的二级缓存区域的数据
     5. 二级缓存和一级缓存区别：二级缓存的范围更大，多个sqlSession可以共享mapper的一个二级缓存
     * UserMapper有一个二级缓存区域(按namespace分)，其他mapper也有自己的二级缓存区域(按namespace分)
     * 每一个namespace的mapper有一个二级缓存区域。即：两个mapper的namespace如果相同，这两个mapper执行SQL查询到的数据将存在相同的二级缓存区域中

3. 二级缓存的开启
     * mybatis的二级缓存是mapper范围级别，除了在SqlMapper.xml设置二级缓存的总开关，还要在具体的mapper.xml中开启二级缓存
        * SqlMapper.xml中设置二级缓存的总开关
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--开启二级缓存--&gt;</span><br><span class="line">&lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&gt;</span><br></pre></td></tr></table></figure>
<pre><code>* 在UserMapper.xml中开启二级缓存，UserMapper.xml下的SQL执行完成会存储到它的缓存区域(HashMap)
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--开启本mapper的namespace下的二级缓存--&gt;</span><br><span class="line">&lt;cache/&gt;</span><br></pre></td></tr></table></figure>
<pre><code>4. 调用pojo类实现序列化接口
      * 为了将缓存数据取出执行反序列化操作，因为二级缓存数据存储介质多种多样，不一定在内存，可能在硬盘或者远程服务
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public class User implements Serializable &#123;</span><br></pre></td></tr></table></figure>
<pre><code>5. 二级缓存的测试方法
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">// 二级缓存测试</span><br><span class="line">	@Test</span><br><span class="line">	public void testCache2() throws Exception &#123;</span><br><span class="line">		SqlSession sqlSession1 = sqlSessionFactory.openSession();</span><br><span class="line">		SqlSession sqlSession2 = sqlSessionFactory.openSession();</span><br><span class="line">		SqlSession sqlSession3 = sqlSessionFactory.openSession();</span><br><span class="line">		// 创建代理对象</span><br><span class="line">		UserMapper userMapper1 = sqlSession1.getMapper(UserMapper.class);</span><br><span class="line">		// 第一次发起请求，查询id为1的用户</span><br><span class="line">		User user1 = userMapper1.findUserById(1);</span><br><span class="line">		System.out.println(user1);</span><br><span class="line">		</span><br><span class="line">		//这里执行关闭操作，将sqlsession中的数据写到二级缓存区域</span><br><span class="line">		sqlSession1.close();</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		//使用sqlSession3执行commit()操作</span><br><span class="line">		UserMapper userMapper3 = sqlSession3.getMapper(UserMapper.class);</span><br><span class="line">		User user  = userMapper3.findUserById(1);</span><br><span class="line">		user.setUsername(&quot;张明明&quot;);</span><br><span class="line">		userMapper3.updateUser(user);</span><br><span class="line">		//执行提交，清空UserMapper下边的二级缓存</span><br><span class="line">		sqlSession3.commit();</span><br><span class="line">		sqlSession3.close();</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line"></span><br><span class="line">		UserMapper userMapper2 = sqlSession2.getMapper(UserMapper.class);</span><br><span class="line">		// 第二次发起请求，查询id为1的用户</span><br><span class="line">		User user2 = userMapper2.findUserById(1);</span><br><span class="line">		System.out.println(user2);</span><br><span class="line"></span><br><span class="line">		sqlSession2.close();</span><br><span class="line"></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<pre><code>6. 二级缓存的useCache配置
    1. 在statement中设置useCache=false可以禁用当前select语句的二级缓存，即每次查询都会发出sql去查询，默认情况是true，即该sql使用二级缓存。
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id=&quot;findOrderListResultMap&quot; resultMap=&quot;ordersUserMap&quot; useCache=&quot;false&quot;&gt;</span><br></pre></td></tr></table></figure>
<pre><code>    * 总结：针对每次查询都需要最新的数据sql，要设置成useCache=false，禁用二级缓存。

7. 二级缓存的刷新缓存（就是清空缓存）
    1. 在mapper的同一个namespace中，如果有其它insert、update、delete操作数据后需要刷新缓存，如果不执行刷新缓存会出现脏读。

    2. 设置statement配置中的flushCache=&quot;true&quot; 属性，默认情况下为true即刷新缓存，如果改成false则不会刷新。使用缓存时如果手动修改数据库表中的查询数据会出现脏读。
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">如下：</span><br><span class="line">&lt;insert id=&quot;insertUser&quot; parameterType=&quot;cn.itcast.mybatis.po.User&quot; flushCache=&quot;true&quot;&gt;</span><br></pre></td></tr></table></figure>
<pre><code>   * 总结：一般下执行完commit操作都需要刷新缓存，flushCache=true表示刷新缓存，这样可以避免数据库脏读。

8.    应用场景
    1. 对于访问多的查询请求且用户对查询结果实时性要求不高，此时可采用mybatis二级缓存技术降低数据库访问量，提高访问速度，业务场景比如：耗时较高的统计分析sql、电话账单查询sql等。

    2. 实现方法如下：通过设置刷新间隔时间，由mybatis每隔一段时间自动清空缓存，根据数据变化频率设置缓存刷新间隔flushInterval，比如设置为30分钟、60分钟、24小时等，根据需求而定。


9.    局限性
    1. mybatis二级缓存对细粒度的数据级别的缓存实现不好，
    2. 比如如下需求：对商品信息进行缓存，由于商品信息查询访问量大，但是要求用户每次都能查询最新的商品信息，此时如果使用mybatis的二级缓存就无法实现当一个商品变化时只刷新该商品的缓存信息而不刷新其它商品的信息，
    3. 因为mybaits的二级缓存区域以mapper为单位划分，当一个商品信息变化会将所有商品信息的缓存数据全部清空。解决此类问题需要在业务层根据需求对数据有针对性缓存。
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/570911275/570911275.github.io/2019/07/25/JavaEE之MyBatis高级知识之中小结/" data-id="cjywzvwom003z3ctnketb4tsj" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/javaEE-基础/">javaEE_基础</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-JavaEE之MyBatis高级知识之上小结" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/25/JavaEE之MyBatis高级知识之上小结/" class="article-date">
  <time datetime="2019-07-25T02:42:26.000Z" itemprop="datePublished">2019-07-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/25/JavaEE之MyBatis高级知识之上小结/">JavaEE之MyBatis高级知识之上小结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="MyBatis"><a href="#MyBatis" class="headerlink" title="MyBatis"></a>MyBatis</h2><pre><code>1. 基础知识（重点，内容多）
    对原生态jdbc程序（单独使用jdbc开发）问题总结
    mybatis框架原理（掌握）
    mybatis入门程序
         用户的增删改查
    mybatis开发两种方法：
         原始dao开发方法（程序需要编写dao接口和dao实现类）（掌握）
         mybaits的mapper接口（相当于dao接口）代理开发方法（掌握）
    mybatis配置文件SqlMapConfig.xml
    mybatis核心：
         mybatis输入映射（掌握）
         mybatis输出映射（掌握）
    mybatis的动态SQL（掌握）

 2. 高级知识
    订单商品数据模型分析
    高级结果集映射（一对一，一对多，多对多）
    mybatis延迟加载
    mybatis查询缓冲（一级缓冲、二级缓冲）
    mybaits和spring进行整合（掌握）
    mybatis逆向工程
</code></pre><h3 id="一、高级知识"><a href="#一、高级知识" class="headerlink" title="一、高级知识"></a>一、高级知识</h3><h4 id="1-订单商品数据模型分析"><a href="#1-订单商品数据模型分析" class="headerlink" title="1. 订单商品数据模型分析"></a>1. 订单商品数据模型分析</h4><pre><code>1.1 数据模型分析思路：
     1. 每张表记录的数据内容：
          * 分模块对每张表记录的内容进行熟悉，相当于你学习系统需求（功能）的过程
     2. 每张表重要的字段设置：
          * 非空字段、外键字段
     3. 数据库级别表与表之间的关系
          * 外键关系
     4. 表与表之间的业务关系
          * 在分析表与表之间的业务关系时一定要建立在某个业务意义基础上去分析 
</code></pre><h4 id="2-高级结果集映射（一对一，一对多，多对多）"><a href="#2-高级结果集映射（一对一，一对多，多对多）" class="headerlink" title="2. 高级结果集映射（一对一，一对多，多对多）"></a>2. 高级结果集映射（一对一，一对多，多对多）</h4><pre><code>2.1 一对一查询：
     * 查询订单信息，关联查询创建订单的用户信息
  2.1.1 resultType
    2.1.1.1 SQL语句
           1. 确定查询的主表：订单表
           2. 确定查询的关联表：用户表
               * 关联查询使用内连接还是外连接
                    * 由于orders表中有一个外键（user_id），通过外键关联查询用户表只能查询出来一条记录
                    * 因此可以内连接
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">SQL语句：</span><br><span class="line"></span><br><span class="line">SELECT </span><br><span class="line">       orders.*,</span><br><span class="line">       user.`sex`,</span><br><span class="line">       user.`address`,</span><br><span class="line">       user.`birthday`,</span><br><span class="line">       user.`username`     </span><br><span class="line">FROM</span><br><span class="line"> orders,USER </span><br><span class="line"> WHERE orders.`user_id`=user.`id`</span><br></pre></td></tr></table></figure>
<pre><code>2.1.1.2 创建pojo
        1. 将上边SQL查询的结果映射到pojo中，pojo中必须包含所有的查询列名
            * 原始的Order.java不能映射全部字段，需要新创建的pojo
            * 解决方法：创建一个pojo继承包括查询字段较多的po类

2.1.1.3 mapper.xml
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--查询订单关联用户信息--&gt;</span><br><span class="line">&lt;select id=&quot;findOrderUser&quot;  resultMap=&quot;cn.itcast.po.OrdersCustom&quot;&gt;</span><br><span class="line">    SELECT</span><br><span class="line">   orders.*,</span><br><span class="line">   user.`sex`,</span><br><span class="line">   user.`address`,</span><br><span class="line">   user.`birthday`,</span><br><span class="line">   user.`username`</span><br><span class="line">   FROM</span><br><span class="line">   orders,USER</span><br><span class="line">   WHERE orders.`user_id`=user.`id`</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure>
<pre><code>2.1.1.4 mapper.java
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public interface OrdersMapperCustom &#123;</span><br><span class="line">    //查询订单关联用户信息</span><br><span class="line">    public List&lt;OrdersCustom&gt; findOrdersUser() throws Exception;</span><br><span class="line">&#125;</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">         2.1.2 resultMap</span><br><span class="line">           2.1.2.1 SQL语句</span><br><span class="line">               * 同resultType一样</span><br><span class="line">           2.1.2.2 定义resultMap</span><br></pre></td></tr></table></figure>
<pre><code>&lt;!--订单查询关联用户的resultMap
    将整个查询的结果映射额到cn.itcast.po.Orders中
    --&gt;
&lt;resultMap type=&quot;cn.itcast.po.Orders&quot; id=&quot;OrdersUserResultMap&quot;&gt;
        &lt;!--配置映射的订单信息--&gt;
        &lt;!--id:指定查询列中的唯一标识，订单信息中的唯一标识，如果有多个列组成唯一标识，配置多个id
            column：订单信息的唯一标识列
            property：订单信息的唯一标识列所映射到Orders中的哪一个属性
            --&gt;
    &lt;id column=&quot;id&quot; property=&quot;id&quot;/&gt;
    &lt;result column=&quot;user_id&quot; property=&quot;userId&quot;/&gt;
    &lt;result column=&quot;number&quot; property=&quot;number&quot;/&gt;
    &lt;result column=&quot;createtime&quot; property=&quot;createtime&quot;/&gt;
    &lt;result column=&quot;note&quot; property=&quot;note&quot;/&gt;

    &lt;!--配置映射的关联的用户信息--&gt;
    &lt;!--association:用于映射关联查询单个对象的信息
        property:要将关联查询的用户信息映射到Orders中的哪一个属性--&gt;
    &lt;association property=&quot;user&quot; javaType=&quot;cn.itcast.po.User&quot; &gt;
        &lt;!--id:关联用户的唯一标识
            column：指定唯一标识用户信息的列
            JavaType：映射到user的哪一个属性--&gt;
        &lt;id column=&quot;user_id&quot; property=&quot;id&quot;/&gt;
        &lt;result column=&quot;usernmae&quot; property=&quot;username&quot;/&gt;
        &lt;result column=&quot;address&quot; property=&quot;address&quot;/&gt;
        &lt;result column=&quot;birthday&quot; property=&quot;birthday&quot;/&gt;
        &lt;result column=&quot;sex&quot; property=&quot;sex&quot;/&gt;
    &lt;/association&gt;
&lt;/resultMap&gt;
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2.1.2.3 mapper.xml</span><br></pre></td></tr></table></figure>
<pre><code>&lt;select id=&quot;findOrdersUserResultMap&quot;  resultMap=&quot;OrdersUserResultMap&quot;&gt;
    SELECT
   orders.*,
   user.`sex`,
   user.`address`,
   user.`birthday`,
   user.`username`
   FROM
   orders,USER
   WHERE orders.`user_id`=user.`id`
&lt;/select&gt;
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2.1.2.3 mapper.java</span><br></pre></td></tr></table></figure>
<pre><code>//查询订单关联用户信息使用resultMap
public List&lt;Orders&gt; findOrdersUserResultMap() throws Exception;
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2.1.2.3 Orders.java</span><br></pre></td></tr></table></figure>
<pre><code>private User user;
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">     </span><br><span class="line">    </span><br><span class="line">  2.1.3 resultType和resultMap实现一对一查询小结</span><br><span class="line">        * resultType:使用resultType实现较为简单，如果pojo中没有包括查询出来的列名。需要增加列名对应的属性，即可完成映射</span><br><span class="line">        * 如果没有查询结果的特殊要求建议使用resultType</span><br><span class="line"></span><br><span class="line">        * resultMap：需要单独定义resultMap,实现有点麻烦，如果对查询结果有特殊要求，使用resultMap可以完成将关联查询映射pojo的属性中</span><br><span class="line"></span><br><span class="line">        * resultMap可以实现延迟加载，resultType无法实现延迟加载</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2.2 一对多查询</span><br><span class="line">   * 查询订单及订单明细的信息</span><br><span class="line">  2.2.1 SQL语句</span><br><span class="line">      * 确定主查询表：订单表</span><br><span class="line">      * 确定关联查询表：订单明细  </span><br><span class="line">      * 在一对以查询继承上添加订单明细表关联即可   </span><br><span class="line">      * **在此处对orderDetails.id设置别名，避免与orders.id发送冲突**</span><br></pre></td></tr></table></figure>
<p>SQL语句：<br>        SELECT<br>       orders.*,<br>       orderdetail.<code>id</code> orderdetail_id,<br>       orderdetail.<code>orders_id</code>,<br>       orderdetail.<code>items_id</code>,<br>       orderdetail.<code>items_num</code>,<br>       user.<code>sex</code>,<br>       user.<code>address</code>,<br>       user.<code>birthday</code>,<br>       user.<code>username</code></p>
<pre><code>FROM
orders,USER,orderdetail
WHERE orders.`user_id`=user.`id` AND orderdetail.`orders_id`=orders.`id`
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">2.2.2 分析：</span><br><span class="line">   * 使用resultType将上边的查询结果映射到pojo中，订单信息就是重复</span><br><span class="line">   * 要求：</span><br><span class="line">       * 对orders映射不能出现重复记录</span><br><span class="line">   * 方法：</span><br><span class="line">       * 在orders.java类中添加List&lt;orderDetail&gt;orderDetails属性</span><br><span class="line">       * 最终会将订单信息映射到orders中，订单所对应的订单明细映射到orders中的orderDetails属性中。</span><br><span class="line">       * 映射成的orders记录数为两条(orders信息不重复)</span><br><span class="line">       * 每个orders中的orderDetails属性存储了该订单过对应的订单明细</span><br><span class="line"></span><br><span class="line">2.2.3 在orders.java类中添加List&lt;orderDetail&gt;orderDetails属性</span><br></pre></td></tr></table></figure>
<pre><code>//订单明细
private List&lt;Orderdetail&gt; orderdetails;
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">2.2.4 定义resultMap</span><br><span class="line">       * 使用了继承</span><br></pre></td></tr></table></figure>
<pre><code>&lt;!--订单及订单明细的resultMap--&gt;
&lt;!--使用extends继承，不用在中配置订单信息和用户信息的映射--&gt;
&lt;resultMap type=&quot;cn.itcast.po.Orders&quot; id=&quot;findOrdersAndOrderDetailResultMap&quot; extends=&quot;OrdersUserResultMap&quot;&gt;
    &lt;!--订单信息--&gt;
    &lt;!--用户信息--&gt;
    &lt;!--使用extends继承，不用在中配置订单信息和用户信息的映射--&gt;
    &lt;!--订单明细信息--&gt;
    &lt;!--一个订单关联查询出来多条明细，要使用collection进行映射
        collection：对关联查询到多条记录映射到集合对象中
        association:用于映射关联查询单个对象的信息
        一个多个，一个单个
        property:要将关联查询的多条记录映射到Orders中的哪一个属性
        ofType:指定映射到list集合属性中pojo的类型--&gt;
    &lt;collection property=&quot;orderdetails&quot; ofType=&quot;cn.itcast.po.Orderdetail&quot;&gt;
        &lt;!--id:订单明细的唯一标识
            property:要将订单明细中的唯一标识映射到Orderdetail的哪一个属性--&gt;
        &lt;id column=&quot;orderdetail_id&quot; property=&quot;id&quot;/&gt;
        &lt;result column=&quot;orders_id&quot; property=&quot;ordersId&quot;/&gt;
        &lt;result column=&quot;items_id&quot; property=&quot;itemsId&quot;/&gt;
        &lt;result column=&quot;items_num&quot; property=&quot;itemsNum&quot;/&gt;
    &lt;/collection&gt;
&lt;/resultMap&gt;
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">2.2.5 mapper.xml</span><br></pre></td></tr></table></figure>
<pre><code>&lt;!--查询订单关联用户信息以及订单明细，使用resultMap--&gt;
&lt;select id=&quot;findOrdersAndOrderDetailResultMap&quot;  resultMap=&quot;findOrdersAndOrderDetailResultMap&quot;&gt;
   SELECT
   orders.*,
   orderdetail.id orderdetail_id,
   orderdetail.`orders_id`,
   orderdetail.`items_id`,
   orderdetail.`items_num`,
   user.`sex`,
   user.`address`,
   user.`username`

   FROM
   orders,USER,orderdetail
   WHERE orders.`user_id`=user.`id` AND orderdetail.`orders_id`=orders.`id`
&lt;/select&gt;
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2.2.6 mapper.java</span><br></pre></td></tr></table></figure>
<pre><code>//查询订单(关联用户)及订单明细
public List&lt;Orders&gt; findOrdersAndOrderDetailResultMap() throws  Exception;
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2.2.7 测试类</span><br></pre></td></tr></table></figure>
<pre><code>public void findOrdersAndOrderDetailResultMap() throws Exception {
    //mybatis配置文件
    String resource = &quot;SqlMapConfig.xml&quot;;
    //得到配置文件流
    InputStream inputStream = Resources.getResourceAsStream(resource);
    //创建会话工厂,传入mybatis的配置文件信息
    SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);
    SqlSession sqlSession = sqlSessionFactory.openSession();
    //创建OrdersMapperCustom对象，mybatis自动生成OrderMapperCustom代理对象
    OrdersMapperCustom ordersMapperCustom = sqlSession.getMapper(OrdersMapperCustom.class);

    List&lt;Orders&gt; list = ordersMapperCustom.findOrdersAndOrderDetailResultMap();

    System.out.println(list);

    sqlSession.close();

}
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  2.2.8 小结</span><br><span class="line">      * mybatis使用resultMap的collection对关联查询的多条记录映射到一个list集合属性汇总。</span><br><span class="line">      * 使用resultType实现：</span><br><span class="line">           * 将订单明细映射到orders中的orderdetails中，需要自己处理，使用双重循环遍历，去掉重复记录，将订单明细放在orderdetails中</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2.3 多对多查询</span><br><span class="line">   * 查询用户及用户购买商品信息</span><br><span class="line"></span><br><span class="line">  2.3.1 SQL语句</span><br><span class="line">     * 查询主表是：用户表</span><br><span class="line">     * 关联表：由于用户和商品没有直接关联，通过订单和订单明细进行关联</span><br><span class="line">     * 所以关联表是：orders、orderdetails、items</span><br></pre></td></tr></table></figure>
<pre><code> SELECT
orders.*,
items.`id` items_id,
items.`name` items_name,
items.`detail` items_detail,
items.`price` items_price,
orderdetail.`id` orderdetail_id,
orderdetail.`orders_id`,
orderdetail.`items_id`,
orderdetail.`items_num`,
user.`sex`,
user.`address`,
user.`birthday`,
user.`username`

FROM
orders,USER,orderdetail,items
WHERE orders.`user_id`=user.`id`
 AND orderdetail.`orders_id`=orders.`id`
 AND orderdetail.`items_id`=items.`id`
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">2.3.2 映射思路 </span><br><span class="line">   * 将用户信息映射到user中</span><br><span class="line">   * 在user类中添加订单列表属性List&lt;Orders&gt;ordersList，将用户创建的订单映射到ordersList</span><br><span class="line">   * 在Orders中添加订单明细列表属性List&lt;OrderDetail&gt;orderdetail,将订单的明细映射到orderdetail</span><br><span class="line">   * 在OrderDetail中添加items属性，将订单明细所对应的商品映射到items</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2.3.3 定义resultMap</span><br><span class="line">   * 无法使用继承</span><br><span class="line">   * 通过表与表之间的对应关系，进行连接</span><br></pre></td></tr></table></figure>
<pre><code>&lt;!--查询订单关联用户信息与商品信息的resultMap--&gt;
&lt;resultMap type=&quot;cn.itcast.po.User&quot;   id=&quot;findUserAndItemsResultMap&quot; &gt;
    &lt;!--用户信息--&gt;
    &lt;id column=&quot;user_id&quot; property=&quot;id&quot;/&gt;
    &lt;result column=&quot;username&quot; property=&quot;username&quot;/&gt;
    &lt;result column=&quot;address&quot; property=&quot;address&quot;/&gt;
    &lt;result column=&quot;sex&quot; property=&quot;sex&quot;/&gt;

    &lt;!--订单信息--&gt;
    &lt;!--一个用户对应多个订单--&gt;
    &lt;collection property=&quot;ordersList&quot; ofType=&quot;cn.itcast.po.Orders&quot; &gt;
        &lt;id column=&quot;id&quot; property=&quot;id&quot;/&gt;
        &lt;result column=&quot;user_id&quot; property=&quot;userId&quot;/&gt;
        &lt;result column=&quot;number&quot; property=&quot;number&quot;/&gt;
        &lt;result column=&quot;createtime&quot; property=&quot;createtime&quot;/&gt;
        &lt;result column=&quot;note&quot; property=&quot;note&quot;/&gt;


            &lt;!--订单明细--&gt;
            &lt;!--一个订单对应多个订单明细--&gt;
            &lt;collection property=&quot;orderdetails&quot; ofType=&quot;cn.itcast.po.Orderdetail&quot; &gt;
                &lt;id column=&quot;orderdetail_id&quot; property=&quot;id&quot;/&gt;
                &lt;result column=&quot;orders_id&quot; property=&quot;ordersId&quot;/&gt;
                &lt;result column=&quot;items_id&quot; property=&quot;itemsId&quot;/&gt;
                &lt;result column=&quot;items_num&quot; property=&quot;itemsNum&quot;/&gt;

                    &lt;!--商品信息--&gt;
                    &lt;!--一个订单明细对呀一个商品信息--&gt;
                    &lt;association property=&quot;items&quot; javaType=&quot;cn.itcast.po.Items&quot;&gt;
                        &lt;id  column=&quot;items_id&quot; property=&quot;id&quot;/&gt;
                        &lt;result column=&quot;items_name&quot; property=&quot;name&quot;/&gt;
                        &lt;result column=&quot;items_detail&quot; property=&quot;detail&quot;/&gt;
                        &lt;result column=&quot;items_price&quot; property=&quot;price&quot;/&gt;

                    &lt;/association&gt;

            &lt;/collection&gt;

    &lt;/collection&gt;

&lt;/resultMap&gt;
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">2.3.4 mapper.xml</span><br></pre></td></tr></table></figure>
<pre><code>&lt;select id=&quot;findUserAndItemsResultMap&quot;  resultMap=&quot;findUserAndItemsResultMap&quot;&gt;
    SELECT
   orders.*,
   items.`id` items_id,
   items.`name` items_name,
   items.`detail` items_detail,
   items.`price` items_price,
   orderdetail.`id` orderdetail_id,
   orderdetail.`orders_id`,
   orderdetail.`items_id`,
   orderdetail.`items_num`,
   user.`sex`,
   user.`address`,
   user.`birthday`,
   user.`username`

   FROM
   orders,USER,orderdetail,items
   WHERE orders.`user_id`=user.`id`
    AND orderdetail.`orders_id`=orders.`id`
    AND orderdetail.`items_id`=items.`id`
&lt;/select&gt;
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">2.3.5 mapper.java</span><br></pre></td></tr></table></figure>
<pre><code>//查询用户以及购买的商品信息
public List&lt;User&gt; findUserAndItemsResultMap() throws Exception;
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2.3.6 测试类</span><br></pre></td></tr></table></figure>
<pre><code>List&lt;User&gt; list = ordersMapperCustom.findUserAndItemsResultMap();
</code></pre><p><code>`</code><br>         2.3.7 小结</p>
<pre><code>       * 将查询用户购买的商品信息明细清单，(用户名、用户地址、购买商品名称、购买商品时间、购买商品数量)
       * 针对上边的需求就使用resultType将查询到的记录映射到一个扩展的pojo中，很简单师兄明细清单的功能

3.高级结果集映射（一对一，一对多，多对多）小结
    * 一对多是多对多的特例，如下需求：
        查询用户购买的商品信息，用户和商品的关系是多对多关系。
          需求1：
            查询字段：用户账号、用户名称、用户性别、商品名称、商品价格(最常见)
            企业开发中常见明细列表，用户购买商品明细列表，
            使用resultType将上边查询列映射到pojo输出。

          需求2：
            查询字段：用户账号、用户名称、购买商品数量、商品明细（鼠标移上显示明细）
            使用resultMap将用户购买的商品明细列表映射到user对象中。
    * 对查询结果映射有特殊要求的使用resultMap，比如要求映射成list中包含多个list

4.resultType与resultMap小结
    1. resultType：
        作用：
            将查询结果按照sql列名pojo属性名一致性映射到pojo中。
        场合：
            常见一些明细记录的展示，比如用户购买商品明细，将关联查询信息全部展示在页面时，此时可直接使用resultType将每一条记录映射到pojo中，在前端页面遍历list（list中是pojo）即可。

    2. resultMap：
        使用association和collection完成一对一和一对多高级映射（对结果有特殊的映射要求）。

        1. association：
        作用：
            将关联查询信息映射到一个pojo对象中。
        场合：
            为了方便查询关联信息可以使用association将关联订单信息映射为用户对象的pojo属性中，比如：查询订单及关联用户信息。
            使用resultType无法将查询结果映射到pojo对象的pojo属性中，根据对结果集查询遍历的需要选择使用resultType还是resultMap。

        2. collection：
        作用：
            将关联查询信息映射到一个list集合中。
        场合：
            为了方便查询遍历关联信息可以使用collection将关联信息映射到list集合中，比如：查询用户权限范围模块及模块下的菜单，可使用collection将模块映射到模块list中，将菜单列表映射到模块对象的菜单list属性中，这样的作的目的也是方便对查询结果集进行遍历查询。
            如果使用resultType无法将查询结果映射到list集合中。
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/570911275/570911275.github.io/2019/07/25/JavaEE之MyBatis高级知识之上小结/" data-id="cjywzvwol003y3ctnmz3kl25a" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/javaEE-基础/">javaEE_基础</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/2/">下一页 &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/javaEE-基础/">javaEE_基础</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java-基础/">java_基础</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/javaEE-基础/" style="font-size: 20px;">javaEE_基础</a> <a href="/tags/java-基础/" style="font-size: 10px;">java_基础</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">八月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">七月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">六月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">五月 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/08/04/新文档8080/">(no title)</a>
          </li>
        
          <li>
            <a href="/2019/08/02/JavaEE之SpringMVC之Restful小结/">JavaEE之SpringMVC之Restful小结</a>
          </li>
        
          <li>
            <a href="/2019/08/01/JavaEE之Spring之AOP小结小结/">JavaEE之Spring之AOP小结小结</a>
          </li>
        
          <li>
            <a href="/2019/07/31/新文档8888/">(no title)</a>
          </li>
        
          <li>
            <a href="/2019/07/31/JavaEE之Spring快速入门之下小结/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>
<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="https://github.com/570911275/570911275.github.io/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://github.com/570911275/570911275.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-java-图形用户接口之下小结" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/06/04/java-图形用户接口之下小结/" class="article-date">
  <time datetime="2019-06-04T07:36:28.000Z" itemprop="datePublished">2019-06-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/06/04/java-图形用户接口之下小结/">java_图形用户接口之下小结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/570911275/570911275.github.io/2019/06/04/java-图形用户接口之下小结/" data-id="cjwhhp0wz0003zctne5rnfpsj" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-java-图形用户接口之中小结" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/06/03/java-图形用户接口之中小结/" class="article-date">
  <time datetime="2019-06-03T04:05:00.000Z" itemprop="datePublished">2019-06-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/06/03/java-图形用户接口之中小结/">java_图形用户接口之中小结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/570911275/570911275.github.io/2019/06/03/java-图形用户接口之中小结/" data-id="cjwhhp0x50005zctn7t82agyk" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-java-图形用户接口之上小结" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/06/02/java-图形用户接口之上小结/" class="article-date">
  <time datetime="2019-06-02T14:05:01.000Z" itemprop="datePublished">2019-06-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/06/02/java-图形用户接口之上小结/">java_图形用户接口之上小结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/570911275/570911275.github.io/2019/06/02/java-图形用户接口之上小结/" data-id="cjwhhp0wr0001zctn3gyc8zdo" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java-基础/">java_基础</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-java-异常处理小结" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/06/01/java-异常处理小结/" class="article-date">
  <time datetime="2019-06-01T15:02:12.000Z" itemprop="datePublished">2019-06-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/06/01/java-异常处理小结/">java_异常处理小结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/570911275/570911275.github.io/2019/06/01/java-异常处理小结/" data-id="cjwhhp0xg0009zctn00ykbmgj" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-java-数字与静态之下小结" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/05/31/java-数字与静态之下小结/" class="article-date">
  <time datetime="2019-05-31T14:52:33.000Z" itemprop="datePublished">2019-05-31</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/05/31/java-数字与静态之下小结/">java_数字与静态之下小结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="1-静态方法"><a href="#1-静态方法" class="headerlink" title="1.静态方法"></a>1.静态方法</h2><p>4.静态<strong>final</strong>常数<br><br>&nbsp;&nbsp;&nbsp;&nbsp;a.<strong>静态</strong>的<strong>final变量</strong>是<strong>常数</strong><br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//被标记为final的变量代表它一旦<strong>被初始化之后就不会改动了</strong>。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//命名惯例:<strong>全部都是大写字母以下划线分隔</strong><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static final double PI = 3.1415923</span><br><span class="line">关键词:</span><br><span class="line">public: 可供各方读取</span><br><span class="line">static: 静态,不需要Math的实例</span><br><span class="line">final : 不变值,因为圆周率是不变的</span><br></pre></td></tr></table></figure></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;b.静态<strong>final</strong>变量的<strong>初始化</strong><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1.声明的时候</span><br><span class="line">public class Foo&#123;</span><br><span class="line">    public static final int FOO_X = 25;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">2.在静态初始化程序中</span><br><span class="line">public class Bar&#123;</span><br><span class="line">    public static final double BAR_SIGN;</span><br><span class="line">    </span><br><span class="line">    static&#123;</span><br><span class="line">        BAR_SIGN = (double) Math.random();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;c.final的<strong>方法与类</strong><br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//final的<strong>方法</strong>代表<strong>不能覆盖掉该方法</strong><br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//final的<strong>类</strong>代表<strong>不能继承该类(即创建他的子类)</strong><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1.final的方法</span><br><span class="line">class Poof&#123;</span><br><span class="line">    final void calcWhuffie()&#123;</span><br><span class="line">        //该方法无法被覆盖</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">2.final的类</span><br><span class="line">final class MyMostPerfectClass&#123;</span><br><span class="line">    //不能被继承</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>

<h2 id="3-包装类型的方法-autoboxing"><a href="#3-包装类型的方法-autoboxing" class="headerlink" title="3.包装类型的方法(autoboxing)"></a>3.包装类型的方法(autoboxing)<br></h2><p>&nbsp;&nbsp;&nbsp;&nbsp;a.<strong>primitive主数据类型</strong>的<strong>包装</strong>用的类<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;注意<strong>包装的类的名字不是</strong>完全和<strong>primitive主数据类型</strong>的名称<strong>相同</strong>。<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Boolean 布尔        Character 字符</span><br><span class="line">Byte    字节        Short     短整形</span><br><span class="line">Integer 整形        Long      长整形</span><br><span class="line">Float   单精度浮点  Double    双精度浮点</span><br><span class="line"></span><br><span class="line">包装值</span><br><span class="line">int i = 288;</span><br><span class="line">Integer iWrap = new Integer(i);</span><br><span class="line"></span><br><span class="line">解开包装</span><br><span class="line">int unWrapped - iWrap.intValue();</span><br></pre></td></tr></table></figure></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;b.包装的<strong>作用</strong><br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>autoboxing</strong>功能能够<strong>自动</strong>地将<strong>primitive</strong>主数据类型<strong>转换成包装过的对象</strong><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public void doNumsNewWay()&#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; listOfNumbers = new ArrayList&lt;Integer&gt;();</span><br><span class="line">    //创建Integer类型的ArrayList</span><br><span class="line">    listOfNumbers.add(3);</span><br><span class="line">    //直接加3</span><br><span class="line">    //虽然ArrayList没有add(int)这样的方法,但是编译器会自动帮用户包装</span><br><span class="line">    int num = listOfNumbers.get(0);</span><br><span class="line">    //编译器会自动接口Integer对象的包装,因此可以直接赋值给&quot;num&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;c.包装的<strong>运用</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">1.方法的参数</span><br><span class="line">//发给参数是某种包装类型,则可以传入相对应的primitive主数据类型。</span><br><span class="line">void takeNumber(Integer i)&#123;</span><br><span class="line">    //Integer对象与int数据类型皆可以作为参数传入</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">2.返回值</span><br><span class="line">//如果method声明返回某种primitive主数据类型</span><br><span class="line">//也可以返回兼容的primitive主数据类型或者该primitive主数据类型的包装类型</span><br><span class="line">int fiveNumber()&#123;</span><br><span class="line">    ...</span><br><span class="line">    return x;</span><br><span class="line">    //Integer对象和int数据类型皆可以作为返回值返回</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">3.boolean表达式</span><br><span class="line">//任何预期boolean值的位置都可以用求出boolean的表达式来代替</span><br><span class="line">//例如Boolean包装类型的引用或者&quot;4&gt;2&quot;</span><br><span class="line">if(bool)&#123;</span><br><span class="line">    System.out.println(&quot;true&quot;);</span><br><span class="line">    //boolean对象与boolean数据皆可以传入</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">4.数值运算</span><br><span class="line">//可以在使用primitive主数据类型作为运算子的操作中用包装类型类替换</span><br><span class="line">//这意味着可以对Integer的对象作递增运算</span><br><span class="line">Integer i = new Integer(42);</span><br><span class="line">i++;</span><br><span class="line">或者</span><br><span class="line">Integer j = new Integer(25);</span><br><span class="line">Integer k = j+3;</span><br><span class="line"></span><br><span class="line">5.赋值</span><br><span class="line">//可以将包装类型或primitive主数据类型赋给声明给相对应的包装或primitive主数据类型</span><br><span class="line">Double d = x;</span><br><span class="line">//Integer对象和int数据皆可作为&quot;x&quot;赋值给&quot;d&quot;</span><br></pre></td></tr></table></figure></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;4.包装的静态方法<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a.将<strong>String</strong>转换成<strong>primitive</strong>主数据类型<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String s = &quot;2&quot;;</span><br><span class="line">int    x = Integer.parseInt(s);</span><br><span class="line">double d = Double.parseDouble(&quot;40.24&quot;);</span><br><span class="line">//boolean不一样，并没有BooleanparseBpplean()</span><br><span class="line">boolean b = new Boolean(&quot;true&quot;).booleanValue();</span><br><span class="line">//Boolean的构造函数可以取用String来创建对象</span><br></pre></td></tr></table></figure></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b.将<strong>primitive</strong>主数据类型转换成<strong>String</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.将数字接上现有的String</span><br><span class="line">double b = 42.5;</span><br><span class="line">String doubleString = &quot; &quot;+d;</span><br><span class="line">2.使用静态方法</span><br><span class="line">double b = 42.5;</span><br><span class="line">String doubleString = Doouble.toString(d);</span><br></pre></td></tr></table></figure></p>
<hr>

<h2 id="2-格式化"><a href="#2-格式化" class="headerlink" title="2.格式化"></a>2.格式化</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;1.<strong>格式化</strong>的说明<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;格式化说明最多会有<strong>5个部分</strong>(<strong>不包括”%”符号</strong>)，下面”<strong>[]</strong>“中的内容都是<strong>可选项目</strong>，因此<strong>只有%与type是必要</strong>的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">%[argument number] [flags] [width] [.precision] type</span><br><span class="line">argument number:如果格式化的参数超过一个以上，可以在此处指定是哪一个</span><br><span class="line">flags:特定类型的特定选项，例如数字要加逗号或正负号</span><br><span class="line">width:最小的字符数，(这不是总数)输出可以超过此宽度，若不足则主动补0</span><br><span class="line">.precision:精确度</span><br></pre></td></tr></table></figure></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;2.<strong>日期</strong>的格式<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;数值与日期时间格式化的区别在于<strong>日期格式的类型是用”t”开头</strong>的<strong>两个字符</strong>表示<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">完整的日期与时间:%tc</span><br><span class="line">String.format(&quot;%tc&quot;,new Date());</span><br><span class="line"></span><br><span class="line">只有时间:%tr</span><br><span class="line">String.format(&quot;%tr&quot;,new Date());</span><br><span class="line"></span><br><span class="line">周、月、日:%tA %tB %td</span><br><span class="line">Date today = new Date();</span><br><span class="line">String.format(&quot;tA,%tB %td&quot;,today,today,today);</span><br><span class="line">//此处的&quot;,&quot;为直接输出的</span><br><span class="line">//输出为 Sunday, November 28</span><br><span class="line">//此种输入需要将Date对象传入3次</span><br><span class="line"></span><br><span class="line">同上但是使用&quot;&lt;&quot;，此时无需重复传参</span><br><span class="line">Date today = new Date();</span><br><span class="line">String.format(&quot;tA,%&lt;tB %&lt;td&quot;,today);</span><br><span class="line">//&quot;&lt;&quot;这个符号是告知程序重复利用之前用过的参数</span><br></pre></td></tr></table></figure></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;3.操作日期<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在2中使用<strong>java.util.Date</strong>来<strong>查询日期</strong>，现在使用<strong>java.util.Calendar</strong>来<strong>操作日期</strong>。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因为<strong>Calendar</strong>是一个<strong>抽象的类</strong>，使用只能用到他的<strong>具体子类</strong>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">取得继承过Calendar的对象:</span><br><span class="line">1.Calendar cal = new Calendar();</span><br><span class="line">//无法通过编译</span><br><span class="line"></span><br><span class="line">2.Calendar cal = Calendar.getInstance();</span><br><span class="line">//通过调用静态方法</span><br></pre></td></tr></table></figure></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;运用<strong>Calendar对象</strong>的几个概念<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a.<strong>字段会保存状态</strong>——Calendar对象使用许多<strong>字段</strong>来表示<strong>日期和时间</strong>。(用户可以读取和设定他的year或month字段)<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b.<strong>日期和时间可以运算</strong>——Calendar的方法可以使得用户对<strong>不同的字段</strong>做<strong>加法或减法的运算</strong>。(用户可以对month字段加一个月或者对year字段减去3年)<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c.<strong>日期和时间可以用millisecond来表示</strong>——Calendar可以<strong>将日期</strong>转换成<strong>微秒</strong>的表示法，或将<strong>微秒</strong>转换成<strong>日期</strong>。(用户可以<strong>执行精确的相对时间计算</strong>)<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Calendar c = Calendar.getInstance();</span><br><span class="line"></span><br><span class="line">c.set(2004,1,7,15,40);</span><br><span class="line">//蛇精睡觉为2004年1月7日15:40</span><br><span class="line"></span><br><span class="line">long day1 = c.getTimeInMillis();</span><br><span class="line">//讲时间转换成用millisecond微秒来表示</span><br><span class="line"></span><br><span class="line">day1 += 1000*60*60;</span><br><span class="line">//将时间将上一个小时</span><br><span class="line"></span><br><span class="line">c.setTimeInMillis(day1);</span><br><span class="line">//将微秒转换成日期</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;new hour&quot; + c.get(c.HOUR_OF_DAY));</span><br><span class="line">//打印出时间</span><br><span class="line"></span><br><span class="line">c.add(c.DATE, 35);</span><br><span class="line">//加上35天，所以此时的月份变为了2月</span><br><span class="line"></span><br><span class="line">c.roll(c.DATE, 35);</span><br><span class="line">//滚动35天，此时只有日期改变，月份不改变</span><br><span class="line"></span><br><span class="line">c.set(c.DATE, 1);</span><br><span class="line">//直接设定DATE的值</span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/570911275/570911275.github.io/2019/05/31/java-数字与静态之下小结/" data-id="cjwhhp0xr000ezctnvcr8ttgx" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java-基础/">java_基础</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-java-数字与静态之上小结" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/05/30/java-数字与静态之上小结/" class="article-date">
  <time datetime="2019-05-30T14:45:41.000Z" itemprop="datePublished">2019-05-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/05/30/java-数字与静态之上小结/">java_数字与静态之上小结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="1-Math的方法"><a href="#1-Math的方法" class="headerlink" title="1.Math的方法"></a>1.Math的方法</h2><p>1.Math这个类中<strong>所有的方法</strong>都不需要实例变量值。因为这些方法都是<strong>静态</strong>的,所有<strong>无需Math的实例</strong>。只会用到他的<strong>类</strong>本身。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int x = Math.round(42.2);</span><br><span class="line">int y = Math.min(56,12);</span><br></pre></td></tr></table></figure></p>
<p>2.Math的方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Math.random()</span><br><span class="line">//返回介于0.0~1.0之间的双精度浮点数</span><br><span class="line">double r1 = Math.random();</span><br><span class="line">int r2 = (int) (Math.random() * 5);</span><br><span class="line"></span><br><span class="line">Math.abs()</span><br><span class="line">//返回双精度浮点类型参数的绝对值。</span><br><span class="line">//这个方法有覆盖的版本,传入整数会返回整数,传入双精度浮点数会返回双精度浮点数。</span><br><span class="line">int x = Math.abs(-24); //返回24</span><br><span class="line">double d = Math.abs(240.25); //返回240.25</span><br><span class="line"></span><br><span class="line">Math.min()</span><br><span class="line">//返回两个精度中较小的那一个</span><br><span class="line">//这个有int,long,float或double的覆盖版本</span><br><span class="line">int x = Math.min(24,240); //返回24</span><br><span class="line">double y = Math.min(982.25,654.32); //返回982.25</span><br><span class="line"></span><br><span class="line">Math.max()</span><br><span class="line">//返回两个精度中较大的一个</span><br><span class="line">//同Math.min()一致</span><br></pre></td></tr></table></figure></p>
<hr>

<h2 id="2-静态方法"><a href="#2-静态方法" class="headerlink" title="2.静态方法"></a>2.静态方法</h2><p>1.非静态方法与静态方法的差别<br><br>&nbsp;&nbsp;&nbsp;&nbsp;a.”<strong>static</strong>“这个关键词可以标记出<strong>不需类实例</strong>的方法。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;b.一个静态方法代表说<strong>一种不依靠实例变量</strong>也就<strong>不需要对象</strong>的行为。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//静态方法中<strong>绝对没有对象</strong>。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;c.区别:<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;静态方法:<strong>不依靠实例变量</strong><br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;非静态方法:<strong>实例变量</strong>的值会<strong>影响到方法</strong>的行为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">非静态方法:</span><br><span class="line">public class Song&#123;</span><br><span class="line">    String title;</span><br><span class="line">    //实例变量将影响方法的行为</span><br><span class="line">    public Song(String t)&#123;</span><br><span class="line">        title = t;</span><br><span class="line">    &#125;</span><br><span class="line">    public void play()&#123;</span><br><span class="line">        SoundPlayer player = new SoundPlayer();</span><br><span class="line">        player.playSound(title);</span><br><span class="line">        //&quot;title&quot;的值会决定&quot;play()&quot;的行为</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">静态方法:</span><br><span class="line">public static int min(int a,int b)&#123;</span><br><span class="line">    //返回a与b之间较小的值</span><br><span class="line">    //没有实例变量</span><br><span class="line">    //没有对象</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>2.静态方法的调用<br><br>&nbsp;&nbsp;&nbsp;&nbsp;a.以<strong>类的名称</strong>调用<strong>静态的方法</strong><br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<code>Math.min(86,88);</code><br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//虽然可以用引用变量的名称调用静态方法但是<strong>不建议</strong>使用。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;b.以<strong>引用变量的名称</strong>调用<strong>非静态的方法</strong><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Song t2 = new Song();</span><br><span class="line">t2.play();</span><br></pre></td></tr></table></figure></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;c.静态方法<strong>不能调用</strong>非静态的变量:<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>静态方法</strong>是在<strong>无关特定特定类</strong>的实例情况下执行的。甚至<strong>不会有该类的实例</strong>出现。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因为<strong>静态方法是通过类的名称</strong>调用的,所以静态方法<strong>无法引用</strong>到该类的<strong>任何实例变量</strong>。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;所以静态方法<strong>无法识别</strong>可以使用哪一个实例变量。<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class Duck&#123;</span><br><span class="line">    private int size;</span><br><span class="line">    </span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        System.out.println(&quot;Size of duck is &quot; + size);</span><br><span class="line">        //此刻静态方法&quot;main()&quot;无法得知堆上是否有Duck</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void setSize(int s)&#123;</span><br><span class="line">        size = s;</span><br><span class="line">    &#125;</span><br><span class="line">    public int getSize()&#123;</span><br><span class="line">        return size;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;d.静态方法<strong>不能调用</strong>非静态方法<br><br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;非静态方法同上是<strong>以实例变量的状态</strong>来影响该<strong>方法</strong>的行为。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;同上方c同理<strong>静态方法无法识别</strong>是哪一个实例变量。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//即便非静态方法中<strong>无使用到实例变量</strong>也<strong>无法</strong>通过编译。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//因为<strong>无法确保</strong>之后是否会将非静态方法<strong>改为需要</strong>实例变量的。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//亦或者是无法保证不发生<strong>子类去覆盖</strong>这个方法成有用到实例变量的版本。<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class Duck&#123;</span><br><span class="line">    private int size;</span><br><span class="line">    </span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        System.out.println(&quot;Size of duck is &quot; + getSize());</span><br><span class="line">        //同c一样此刻静态方法&quot;main()&quot;无法识别需要的是哪一个实例变量</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void setSize(int s)&#123;</span><br><span class="line">        size = s;</span><br><span class="line">    &#125;</span><br><span class="line">    public int getSize()&#123;</span><br><span class="line">        return size;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>3.静态变量<br><br>静态变量对<strong>所有的实例</strong>来说都相同。<br><br>静态变量是<strong>共享的</strong>。<br><br><strong>同一个类</strong>所有的实例变量<strong>共享一份静态变量</strong>。<br><br>实例变量:每个<strong>实例</strong>一个。<br><br>静态变量:每个<strong>类</strong>一个。<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">在构造函数中增加静态变量</span><br><span class="line">class Duck&#123;</span><br><span class="line">    int duckCount = 0;</span><br><span class="line">    public Duck()&#123;</span><br><span class="line">        duckCount++;</span><br><span class="line">        //这无法在创建Duck对象的时候执行递增</span><br><span class="line">        //因为duckCount是一个实例变量</span><br><span class="line">        //所以每个Duck在初始化的时候duckCount的值都是0</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Duck&#123;</span><br><span class="line">    private int size; </span><br><span class="line">    private static int duckCount = 0;</span><br><span class="line">    //静态变量&quot;duckCount&quot;只有在类第一次载入的时候被初始化</span><br><span class="line">    </span><br><span class="line">    public Duck()&#123;</span><br><span class="line">        duckCount++;</span><br><span class="line">        //每当构造函数执行的时候</span><br><span class="line">        //这个值就会递增</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void setSize(int s)&#123;</span><br><span class="line">        size = s;</span><br><span class="line">    &#125;</span><br><span class="line">    public int getSize()&#123;</span><br><span class="line">        return size;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>静态变量会在该类的<strong>任何对象</strong>创建之前就完成初始化。<br>静态变量会在该类<strong>任何静态方法</strong>执行之前就初始化。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Player&#123;</span><br><span class="line">    static int palyerCount = 0;</span><br><span class="line">    private String name;</span><br><span class="line">    public Player(String n)&#123;</span><br><span class="line">        name = n;</span><br><span class="line">        playerCount++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public calss PlayerTestDrive&#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        System.out.println(Player.playerCount);</span><br><span class="line">        Player one = new Player(&quot;Tiger Woods&quot;);</span><br><span class="line">        Systrm.out.println(Player.playerCount);</span><br><span class="line">        //静态变量通过类的名称来存取</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出为:</span><br><span class="line">0    //实例创建之前</span><br><span class="line">1    //对象创建之后</span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/570911275/570911275.github.io/2019/05/30/java-数字与静态之上小结/" data-id="cjwhhp0xk000bzctn3dv32zjt" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java-基础/">java_基础</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-java-构造器与垃圾回收器之垃圾回收器小结" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/05/29/java-构造器与垃圾回收器之垃圾回收器小结/" class="article-date">
  <time datetime="2019-05-29T15:34:46.000Z" itemprop="datePublished">2019-05-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/05/29/java-构造器与垃圾回收器之垃圾回收器小结/">java_构造器与垃圾回收器之垃圾回收器小结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h2><p>1.引用永久性的离开他的返回<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class StackRef&#123;</span><br><span class="line">    public void foof()&#123;</span><br><span class="line">    //foof()处于栈上,无声明变量</span><br><span class="line">        barf();</span><br><span class="line">    //barf()处于栈上</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void barf()&#123;</span><br><span class="line">        Duck d = new Duck();</span><br><span class="line">    //创建一个对象以及他的引用</span><br><span class="line">    //barf()执行完毕</span><br><span class="line">    //引用彻底的离开</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>2.引用被赋值到其他的对象上<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pubilc class ReRef&#123;</span><br><span class="line">    Duck d = new Duck();</span><br><span class="line">    //创建一个对象以及他的引用&quot;d&quot;</span><br><span class="line">    </span><br><span class="line">    public void go()&#123;</span><br><span class="line">        d = new Duck();</span><br><span class="line">    //引用&quot;d&quot;被赋值给新的Duck对象</span><br><span class="line">    //原先的Duck对象无引用所以死亡</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>3.直接将引用设定成null<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class ReRef&#123;</span><br><span class="line">    Duck d = new Duck();</span><br><span class="line">    //创建一个对象以及他的引用&quot;d&quot;</span><br><span class="line">    </span><br><span class="line">    public void go()&#123;</span><br><span class="line">        d = null;</span><br><span class="line">    //引用&quot;d&quot;被赋值为null</span><br><span class="line">    //原先的Duck对象无引用死亡</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/570911275/570911275.github.io/2019/05/29/java-构造器与垃圾回收器之垃圾回收器小结/" data-id="cjwhhp0y0000gzctnz92eqn6c" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java-基础/">java_基础</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-java-构造器与垃圾回收器之构造器小结" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/05/28/java-构造器与垃圾回收器之构造器小结/" class="article-date">
  <time datetime="2019-05-28T15:32:38.000Z" itemprop="datePublished">2019-05-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/05/28/java-构造器与垃圾回收器之构造器小结/">java_构造器与垃圾回收器之构造器小结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="1-栈与堆-生存空间"><a href="#1-栈与堆-生存空间" class="headerlink" title="1.栈与堆:生存空间"></a>1.栈与堆:生存空间</h2><p>1.堆与栈的基本概念<br><br>堆:<strong>对象</strong>的生存空间堆<br><br>&nbsp;&nbsp;&nbsp;&nbsp;//<strong>实例变量</strong>是被<strong>声明在类</strong>而不是方法里面。它们代表的每个独立对象的”字段”。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;//<strong>实例变量</strong>存在于<strong>所属的对象</strong>中。<br><br>栈:<strong>方法调用</strong>及<strong>局部变量</strong>的生存空间<br><br>&nbsp;&nbsp;&nbsp;&nbsp;//<strong>局部变量</strong>和<strong>方法的参数</strong>是被<strong>声明在方法</strong>中。它们是<strong>暂时的</strong>。<br>&nbsp;&nbsp;&nbsp;&nbsp;//其<strong>生命周期</strong>只限于<strong>方法被放在栈上</strong>的这段时间。<br><br><br>2.栈上的<strong>对象引用</strong><br><br>非primitive的变量只是<strong>保存对象的引用</strong>。而不是对象的本身,<br><br>如果<strong>局部变量</strong>是个对该<strong>对象的引用</strong>,<strong>只有变量本身会被放在栈上，对象本身只会存在堆上。</strong><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class StackRef&#123;</span><br><span class="line">    public void foof()&#123;</span><br><span class="line">        barf();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void barf()&#123;</span><br><span class="line">        Duck d = new Duck();</span><br><span class="line">        //其中&quot;d&quot;这个局部变量是存在于栈上的。</span><br><span class="line">        //&quot;Duck&quot;这个对象是存在于堆上。</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>

<h2 id="2-构造函数"><a href="#2-构造函数" class="headerlink" title="2.构造函数"></a>2.构造函数</h2><p>1.对象的<strong>声明</strong>与<strong>赋值</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.声明引用变量</span><br><span class="line">&quot;Duck myDuck&quot; = new Duck();</span><br><span class="line">2.创建对象</span><br><span class="line">Duck myDuck = &quot;new Duck()&quot;;</span><br><span class="line">//构造函数就在这一步进行操作</span><br><span class="line">3.连接对象与引用</span><br><span class="line">Duck myDuck &quot;=&quot; new Duck();</span><br></pre></td></tr></table></figure></p>
<p>2.构造函数的<strong>调用</strong><br><br><code>Duck myDuck = &quot;new Duck()&quot;;</code><br><br>这一步调用了Duck的<strong>构造函数</strong>。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;a.在用户<strong>没有编写构造函数</strong>的情况下,编译器将会<strong>自动编写</strong>。<br>&nbsp;&nbsp;&nbsp;&nbsp;b.<strong>唯一</strong>能够在<strong>构造函数之外调用构造函数</strong>的方式为–新建一个类**。<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">在用户无编写构造函数的情况下,系统自行编写的构造函数</span><br><span class="line">public Duck()&#123;</span><br><span class="line">    //其中构造函数的名称必须与类的名称相同</span><br><span class="line">    //与方法区别的一点为:</span><br><span class="line">    //方法有返回类型,构造函数没有返回类型</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>3.构造函数的<strong>意义</strong><br><br>构造函数:会在对象能够<strong>被赋值给引用之前</strong>就执行。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;//这意味着用户有机会在对象<strong>被使用之前</strong>介入。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;//使得用户在构造过程的步骤中<strong>加入一些操作</strong>。<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Duck&#123;</span><br><span class="line">    public Duck()&#123;</span><br><span class="line">        System.out.println(&quot;Quack&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class UseADuck&#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        Duck d = new Duck();</span><br><span class="line">        //启动Duck的构造函数</span><br><span class="line">        //此处输出Quack</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>4.构造函数的<strong>参数</strong><br><br>&nbsp;&nbsp;&nbsp;&nbsp;a.使用构造函数来初始化对象的状态。(即设置和给对象的实例变量赋值)<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//讲构造函数设定成需要参数的。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;b.一定要有不需要参数的构造函数。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//使得用户在创建对象的时候有两个选择:<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//1.可以初始化对象的状态(通过构造函数的参数)<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//2.使用默认值无需初始化<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">构造函数含参数时:</span><br><span class="line">public class Duck&#123;</span><br><span class="line">    int size;</span><br><span class="line">    </span><br><span class="line">    public Duck(int duckSize)&#123;</span><br><span class="line">        System.out.println(&quot;Quack&quot;);</span><br><span class="line">        </span><br><span class="line">        size = duckSize;</span><br><span class="line">        </span><br><span class="line">        System.out.println(&quot;size is &quot; + size);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class UseADuck&#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        Duck d = new Duck(2);</span><br><span class="line">        //此处传值给构造函数</span><br><span class="line">        //此处输出</span><br><span class="line">        //       Quack </span><br><span class="line">        //       size is 2</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>5.构造函数的<strong>重载</strong><br><br>1.如果一个类有了<strong>一个以上</strong>的构造函数,则<strong>参数</strong>一定要<strong>不一样</strong>。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;a.包括了<strong>参数的顺序</strong>与<strong>类型</strong>。只要<strong>不一样</strong>即可。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;b.编译器查看的是<strong>参数的类型</strong>和<strong>顺序</strong>而不是参数的名字。<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public clas Mushroom&#123;</span><br><span class="line">    public Mushroom(int size) &#123;&#125;</span><br><span class="line">    //只含有一个参数</span><br><span class="line">    </span><br><span class="line">    public Mushroom() &#123;&#125;</span><br><span class="line">    //无参数类型</span><br><span class="line">    </span><br><span class="line">    public Mushroom(boolean isMagic) &#123;&#125;</span><br><span class="line">    //只含有一个参数(参数类型发生改变)</span><br><span class="line">    </span><br><span class="line">    public Mushroom(boolean isMagic, int size) &#123;&#125;</span><br><span class="line">    public Mushroom(int size, boolean isMagic) &#123;&#125;</span><br><span class="line">    //顺序不同通过编译</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>6.调用<strong>父类</strong>的构造函数<br><br>唯一调用父类构造函数的方法是调用super()<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Duck extends Animal&#123;</span><br><span class="line">    int size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Duck(int newSize)&#123;</span><br><span class="line">    super();</span><br><span class="line">    size = newSize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/570911275/570911275.github.io/2019/05/28/java-构造器与垃圾回收器之构造器小结/" data-id="cjwhhp0y9000kzctnkes3d6gn" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java-基础/">java_基础</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-java-接口与抽象类小结" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/05/27/java-接口与抽象类小结/" class="article-date">
  <time datetime="2019-05-27T15:01:14.000Z" itemprop="datePublished">2019-05-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/05/27/java-接口与抽象类小结/">java_接口与抽象类小结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="1-抽象类与具体类"><a href="#1-抽象类与具体类" class="headerlink" title="1.抽象类与具体类"></a>1.抽象类与具体类</h2><p>1.<strong>抽象类</strong><br><br>&nbsp;&nbsp;&nbsp;&nbsp;a.有些类不该被<strong>初始化</strong>,则通过<strong>标记类为抽象类</strong>。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//抽象类仍可以作为<strong>引用类型</strong>。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//抽象类<strong>不可被初始化</strong>。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;b.抽象类<strong>除了被继承过</strong>之外,是<strong>没有用途</strong>、<strong>没有值</strong>、<strong>没有目的</strong>的。<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">abstract public class Canine extends Animal</span><br><span class="line">&#123;</span><br><span class="line">    //定义一个抽象类&quot;Canine&quot;;</span><br><span class="line">    public void roam();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class MakeCanine&#123;</span><br><span class="line">    public void go()&#123;</span><br><span class="line">        Canine c;</span><br><span class="line">        c = new Dog;</span><br><span class="line">        //此处是可以通过编译器的;</span><br><span class="line">        //因为可以赋值子类对象给父类的引用&quot;c&quot;。即使该父类&quot;Canine&quot;为抽象的。</span><br><span class="line">        c = new Canine();</span><br><span class="line">        //此处是不可以通过编译器的;</span><br><span class="line">        //因为这个类&quot;Canine&quot;已经被标记为抽象的了。不可以被初始化</span><br><span class="line">        c.roam();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>2.<strong>具体类</strong><br><br>不是抽象的类,就是<strong>具体类</strong><br></p>
<hr>

<h2 id="2-抽象的方法"><a href="#2-抽象的方法" class="headerlink" title="2.抽象的方法"></a>2.抽象的方法</h2><p>1.除了类之外,也可以将<strong>方法</strong>标记为”<strong>abstract</strong>“。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;a.<strong>抽象的类</strong>代表此类<strong>必须要被继承”extend”过</strong>。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;b.<strong>抽象的方法</strong>代表此方法<strong>必须要被覆盖过</strong>。<br><br><br>2.抽象的方法<strong>没有实体</strong><br><br>&nbsp;&nbsp;&nbsp;&nbsp;//因为抽象的方法<strong>必须要被覆盖</strong>,所以编写出抽象方法的代码<strong>没有意义</strong>(即不会含有方法在其中)。<br><br><br>3.抽象的方法<strong>所在的类</strong>必须为<strong>抽象</strong>的<br><br>&nbsp;&nbsp;&nbsp;&nbsp;//就算<strong>只有一个</strong>方法是抽象的,该类也必须为<strong>抽象类</strong>。<br><br>4.抽象方法的<strong>意义</strong><br><br>&nbsp;&nbsp;&nbsp;&nbsp;a.抽象的意义在于:就算无法实现出方法的的内容，但是还可以定义出一组<strong>子型共同的协议</strong><br><br>&nbsp;&nbsp;&nbsp;&nbsp;b.好处:利于多态。这样所有的子型都会有那些抽象的方法。<br><br><br>5.抽象方法的<strong>要求</strong><br><br>&nbsp;&nbsp;&nbsp;&nbsp;a.<strong><em>第一个具体类</em></strong>必须实现<strong>所有</strong>的<strong>抽象方法</strong>。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//必须实现所有的方法:表示必须<strong>写出内容</strong>,必须以<strong>相同的方法</strong>鉴名(<strong>名称</strong>和<strong>参数</strong>)和<strong>相容的返回类型</strong>创建出<strong>非抽象的方法</strong>。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;b.抽象类可以带有<strong>抽象</strong>的和<strong>非抽象</strong>的方法。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//这表示抽象类可以<strong>实现部分抽象方法</strong>,这样<strong>第一个具体类</strong>就可以<strong>不必去实现</strong>这一部分。<br></p>
<hr>

<h2 id="3-对象之母——Object"><a href="#3-对象之母——Object" class="headerlink" title="3.对象之母——Object"></a>3.对象之母——Object</h2><p>1.<strong>在java中所有的类都是从Object这个类继承出来的</strong>。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;a.<strong>Object</strong>是<strong>所有类的源头</strong>,他是<strong>所有类的父类</strong>。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;b.如果java中<strong>没有共同的父类</strong>,讲<strong>无法创建</strong>出可以处理<strong>自定义类型的类</strong>(即无法写出如同<strong>ArrayList</strong>这样可以<strong>处理各种类的类</strong>)。<br><br><br>2.<strong>没有继承</strong>过其他类的类会是<strong>隐含的继承对象</strong><br><br>&nbsp;&nbsp;&nbsp;&nbsp;//如同”Dog”这个类<strong>没有直接继承”extend”对象”Object”</strong>,但是还是会<strong>通过”Dog”的父类</strong>“Animal”来<strong>继承对象”Object”</strong>。<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">关于上述1——b的ArrayList</span><br><span class="line">ArrayList:</span><br><span class="line">boolean remove(Object elem)</span><br><span class="line">//根据索引参数移动对象,如果list中没有元素返回true。</span><br><span class="line"></span><br><span class="line">boolean contains(Object elem)</span><br><span class="line">//如果和对象的参数相匹配的话返回true</span><br><span class="line"></span><br><span class="line">int indexOf(Object elem)</span><br><span class="line">//返回对象参数的索引或-1</span><br><span class="line"></span><br><span class="line">由上述例子可知,许多的ArrayList的方法都用到了Object这个终极类型。</span><br><span class="line">因为每个类都是对象&quot;Object&quot;的子类,所以ArrayList可以处理任何类。</span><br></pre></td></tr></table></figure></p>
<p>3.<strong>Object中的方法</strong>(部分)<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">1.equals(Object o) 判断是否相等</span><br><span class="line">eg:</span><br><span class="line">Dog d = new Dog();</span><br><span class="line">Cat c = new Cat();</span><br><span class="line">if(d.equals(c))&#123;</span><br><span class="line">    System.out.println(&quot;true&quot;);</span><br><span class="line">&#125;else&#123;</span><br><span class="line">    System.out.println(&quot;false&quot;);</span><br><span class="line">&#125;</span><br><span class="line">//此处打印出&quot;flase&quot;</span><br><span class="line"></span><br><span class="line">2.getClass() 告知用户对象是从哪里被初始化的</span><br><span class="line">eg:</span><br><span class="line">Cat c = new Cat();</span><br><span class="line">Systrm.out.println(c.getClass())</span><br><span class="line">//此处打印出&quot;class Cat&quot;</span><br><span class="line"></span><br><span class="line">3.hashCode() 列出此对象的哈希代码(如同唯一的ID)</span><br><span class="line">eg:</span><br><span class="line">Cat c = new Cat();</span><br><span class="line">Systrm.out.println(c.hashCode())</span><br><span class="line">//此处打印出&quot;8202111&quot;</span><br><span class="line"></span><br><span class="line">4.toString() 列出类的名称和一串数字</span><br><span class="line">eg:</span><br><span class="line">Cat c = new Cat();</span><br><span class="line">Systrm.out.println(c.toString())</span><br><span class="line">//此处打印出&quot;Cat@7d277f&quot;</span><br></pre></td></tr></table></figure></p>
<p>4.使用<strong>Object类型的多态引用</strong>的后果<br><br>&nbsp;&nbsp;&nbsp;&nbsp;a.此处<strong>不涉及</strong>制作出<strong>Object类型的实例</strong>。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;b.任何<strong>被Object类型的引用变量</strong>所引用的对象,将被编译器认为为<strong>Object类型</strong>。<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">正常的:</span><br><span class="line">ArrayList&lt;Dog&gt; myDogArrayList = new ArrayList&lt;Dog&gt;();</span><br><span class="line">//保存Dog的Arraylist</span><br><span class="line">Dog aDog = new Dog();</span><br><span class="line">//新建一个Dog</span><br><span class="line">myDogArrayList.add(aDog);</span><br><span class="line">//将aDog放入ArrayList中</span><br><span class="line">Dog d = myDogArrayList.get(0);</span><br><span class="line">//讲Dog赋值给新的Dog引用变量</span><br><span class="line"></span><br><span class="line">Object类型的引用变量下:</span><br><span class="line">ArrayList&lt;Object&gt; myDogArrayList = new ArrayList&lt;Object&gt;();</span><br><span class="line">//保存Object的Arraylist</span><br><span class="line">Dog aDog = new Dog();</span><br><span class="line">//新建一个Dog</span><br><span class="line">myDogArrayList.add(aDog);</span><br><span class="line">//将aDog放入ArrayList中</span><br><span class="line">Dog d = myDogArrayList.get(0);</span><br><span class="line">//此处无法通过编译器</span><br><span class="line">//因为对ArrayList&lt;Object&gt;调用get()方法会返回Object类型</span><br><span class="line">//编译器无法确认它为Dog</span><br><span class="line">//即任何从ArrayList&lt;Object&gt;中取出的Object都会被当做是Object这个类的实例。</span><br></pre></td></tr></table></figure></p>
<hr>

<h2 id="4-引用类型"><a href="#4-引用类型" class="headerlink" title="4.引用类型"></a>4.引用类型</h2><p>1.从上述3——4——b中可以得知当<strong>引用类型改变</strong>时,编译器将<strong>无法识别原先的类型</strong>。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;//即引用仍为<strong>同一个引用</strong>,但是<strong>引用类型</strong>已经发生了<strong>改变</strong>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">3——4——b的修改方法:</span><br><span class="line">ArrayList&lt;Object&gt; myDogArrayList = new ArrayList&lt;Object&gt;();</span><br><span class="line">Dog aDog = new Dog();</span><br><span class="line">myDogArrayList.add(aDog);</span><br><span class="line">Object d = myDogArrayList.get(0);</span><br><span class="line">//这样则可以通过编译</span><br></pre></td></tr></table></figure></p>
<p>2.编译器是<strong>根据引用类型</strong>来<strong>判断</strong>有<strong>哪些方法”method”可以调用</strong>的,而<strong>不是根据</strong>Object<strong>确实的类型</strong>。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;//即便用户知道对象有这个功能,但是编译器只会把他当成<strong>一般的Object</strong>来看待。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;//即他只能调用<strong>Object内所含有的方法</strong>。编译器只管<strong>引用的类型</strong>,而<strong>不是对象的类型</strong>。<br></p>
<hr>

<h2 id="5-对象类型的装换"><a href="#5-对象类型的装换" class="headerlink" title="5.对象类型的装换"></a>5.对象类型的装换</h2><p>1.<strong>可以确认</strong>该变量为什么类型,并且<strong>希望调用该变量本身类型的方法</strong>。则可以将其<strong>声明</strong>为<strong>该变量本身类型</strong>。<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Object o = al.get(index);</span><br><span class="line">Dog d = (Dog) o ;</span><br><span class="line">//o本身类型为Dog的情况下</span><br><span class="line">//可以通过此方式进行类型转换</span><br><span class="line">d.roam();</span><br></pre></td></tr></table></figure></p>
<p>2.<strong>无法确认</strong>变量类型时,可以通过使用<strong>“instanceof”</strong>这个<strong>运算符</strong>来<strong>进行检查</strong>。如果类型转换错误,则在执行期将遇到<strong>“ClassCastException”异常</strong>并且<strong>终止</strong>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if(o instanceof Dog)&#123;</span><br><span class="line">    Dog d = (Dog) o ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>

<h2 id="6-接口"><a href="#6-接口" class="headerlink" title="6.接口"></a>6.接口</h2><p>1.接口的<strong>定义与实现</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">接口的定义:</span><br><span class="line">public interface Pet&#123;...&#125;</span><br><span class="line">//使用&quot;interface&quot;来代替&quot;class&quot;</span><br><span class="line"></span><br><span class="line">接口的实现:</span><br><span class="line">public class Dog extends Canine impements Pet&#123;...&#125;</span><br><span class="line">//使用&quot;implements&quot;这个关键词</span><br></pre></td></tr></table></figure></p>
<p>2.接口中的<strong>方法</strong><br><br>接口中<strong>全部的</strong>方法都是<strong>抽象的</strong>。<br><br>这样子类则必须实现此方法。可解决”致命方块”问题。<br><br>3.接口的<strong>意义</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;a.<strong>利于多态</strong>,接口具有<strong>无比的适用性</strong>。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//使用接口取代<strong>具体的子类</strong>或<strong>抽象的父类</strong>作为<strong>参数或返回类型</strong>。则可以<strong>传入任何</strong>有<strong>实现该接口</strong>的东西。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;b.继承<strong>超过一个以上</strong>的来源<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//使用接口的情况下,类有<strong>继承”extend”过某个父类</strong>并且<strong>实现其他的接口</strong>。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//同时<strong>其他的类</strong>也可以实现<strong>同一个接口</strong>。<br><br><br>4.<strong>不同继承树的类</strong>也可以实现<strong>相同的接口</strong><br><br>&nbsp;&nbsp;&nbsp;&nbsp;a.当把一个<strong>类</strong>作为<strong>多态类型</strong>运用时,<strong>相同的类型</strong>必定来自<strong>同一个继承树</strong>。并且为<strong>该多态类型的子类</strong>。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;b.当把<strong>接口</strong>作为<strong>多态类型</strong>运用时,对象就可以来自<strong>任何的地方</strong>了。<strong>唯一的条件是该对象必须是来自有实现此接口的类</strong>。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;c.类可以实现<strong>多个接口</strong><br><br><code>public class Dog extends Animal implements Pet, Saveable, paintable{...}</code><br><br><br>5.<strong>设计类</strong>、<strong>子类</strong>、<strong>抽象类</strong>、<strong>接口</strong>的判断<br><br>&nbsp;&nbsp;&nbsp;&nbsp;a.如果新的类无法对其他的类通过IS-A的测试时,就设计不继承其他类的类。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;b.只有在需要某类的特殊版本时,以覆盖或增加新的方法来继承现有的类。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;c.当你需要定义一群子类的模版,又不想让程序初始化此模版时,设计出抽象的类给。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;d.如果想要定义出类可以扮演的角色,使用接口。<br></p>
<hr>

<h2 id="7-调用父类的方法"><a href="#7-调用父类的方法" class="headerlink" title="7.调用父类的方法"></a>7.调用父类的方法</h2><p>当想要调用父类中的方法时,可以使用<strong>“super”</strong>这个关键词在<strong>子类中调用父类</strong>的方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">abstract class Report&#123;</span><br><span class="line">    void runReport()&#123;</span><br><span class="line">        //设置报告</span><br><span class="line">    &#125;</span><br><span class="line">    void printReport()&#123;</span><br><span class="line">        //输出</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class BuzzwordsReport extends Report&#123;</span><br><span class="line">    void runReport()&#123;</span><br><span class="line">        super.runReport();</span><br><span class="line">        //调用父类的方法</span><br><span class="line">        buzzwordCompliance();</span><br><span class="line">        printReport();</span><br><span class="line">    &#125;</span><br><span class="line">    void buzzwordCompliance()&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/570911275/570911275.github.io/2019/05/27/java-接口与抽象类小结/" data-id="cjwhhp0z9000qzctn0o1b7o7w" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java-基础/">java_基础</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-java-继承与多态小结" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/05/26/java-继承与多态小结/" class="article-date">
  <time datetime="2019-05-26T11:00:07.000Z" itemprop="datePublished">2019-05-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/05/26/java-继承与多态小结/">java_继承与多态小结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="1-继承的设计"><a href="#1-继承的设计" class="headerlink" title="1.继承的设计"></a>1.继承的设计</h2><p>1.找出Class中<strong>共有的部分</strong><br><br>2.提取出<strong>共有部分</strong>,并设计代表共同状态与行为的新的类<br><br>3.将原先的类以称为<strong>继承</strong>的关系连接到新的类上<br><br>//此时原先的类称为”<strong>子类</strong>“，新的类称为”<strong>父类</strong>“。<br><br>//子类会<strong>自动</strong>获得父类的<strong>功能</strong><br><br>4.决定子类是否需要让<strong>某些行为</strong>(也就是<strong>方法的实现</strong>)有特定的<strong>不同的</strong>运作方式<br><br>5.当子类与父类同一方法有所改变时，可进行<strong>覆盖</strong>。<strong>覆盖</strong>:由子类<strong>重新定义</strong>继承下来的方法以<strong>改变或延伸此方法的行为</strong>。<br><br>//此时<strong>调用对象引用的方法</strong>时,会调用到该对象类型<strong>最接近</strong>的方法<br><br>//(也就是先看本人有没有该方法，没有则找父亲有没有，再没有寻找他爷爷，逐级升高)</p>
<hr>

<h2 id="2-继承的运行方式"><a href="#2-继承的运行方式" class="headerlink" title="2.继承的运行方式"></a>2.继承的运行方式</h2><p>1.类的成员:实例变和方法<br><br>2.继承的关系意味着子类继承了父类的<strong>方法</strong><br><br>&nbsp;&nbsp;&nbsp;a.子类可以加入自己的<strong>实例变量和方法</strong>也可以覆盖掉来自父类的方法。<br><br>&nbsp;&nbsp;&nbsp;b.实例变量无法被覆盖的原因为:不需要。它们并没有定义特殊的行为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">父类:</span><br><span class="line">public class Doctor&#123;</span><br><span class="line">    boolean worksAtHospital;</span><br><span class="line">    void treatPatient()&#123;</span><br><span class="line">        //检查</span><br><span class="line">    &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">子类一:</span><br><span class="line">public class FamilyDoctor extends Doctor&#123;</span><br><span class="line">    boolean makesHouseCalls;</span><br><span class="line">    void giveAdvice();</span><br><span class="line">    //增加新的方法</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">子类二:</span><br><span class="line">public class Surgeon extends Doctor&#123;</span><br><span class="line">    void treatPaient() &#123;</span><br><span class="line">        //手术</span><br><span class="line">    &#125;;</span><br><span class="line">    //覆盖父类方法</span><br><span class="line">    </span><br><span class="line">    void makeIncision() &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>

<h2 id="3-继承设计的判断"><a href="#3-继承设计的判断" class="headerlink" title="3.继承设计的判断"></a>3.继承设计的判断</h2><p>1.IS-A:通过IS-A来判断某物是否一个继承另一物<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">三角形是一个多边形    T</span><br><span class="line">黄丫丫是一个人类      T</span><br><span class="line">苹果是香蕉            F</span><br><span class="line">水是水杯              F</span><br></pre></td></tr></table></figure></p>
<p>2.如果类X是继承类Y的,且类Y是继承类Z的,则X可以通过IS-A Z的测试。<br><br>//即继承具有传递性<br>3.<strong>继承概念下的IS-A是一个单向的概念</strong><br><br>&nbsp;&nbsp;&nbsp;&nbsp;三角形是一个多边形这个是符合的<br><br>&nbsp;&nbsp;&nbsp;&nbsp;多边形是一个三角形这个是不符合的<br></p>
<hr>

<h2 id="4-继承的权限限制"><a href="#4-继承的权限限制" class="headerlink" title="4.继承的权限限制"></a>4.继承的权限限制</h2><p>父类可以通过存取权限觉得子类是否能够继承某些特定的成员<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">以下4种权限:</span><br><span class="line">最限制  ————————&gt;  最公开</span><br><span class="line">private default protected public</span><br></pre></td></tr></table></figure></p>
<p>其中<strong>public</strong> 类型的成员会被继承<br><br><strong>private</strong> 类型的成员不会被继承<br></p>
<hr>

<h2 id="5-继承的意义"><a href="#5-继承的意义" class="headerlink" title="5.继承的意义"></a>5.继承的意义</h2><p>1.避免了<strong>重复的程序代码</strong><br><br>2.定义了<strong>共同的协议</strong><br><br>&nbsp;&nbsp;&nbsp;&nbsp;//共同协议:在父类中定义方法是,他们会被子类继承。这是在什么说所有继承的类都可以<br>执行这些方法，这里面也包括了<strong>方法的参数和返回类型</strong>。<br></p>
<hr>

<h2 id="6-多态与一般对象的区别"><a href="#6-多态与一般对象的区别" class="headerlink" title="6.多态与一般对象的区别"></a>6.多态与一般对象的区别</h2><p>1.一般的声明引用和创建对象的方法<br><br><code>Dog myDog = new Dog();</code><br><br>其中<strong>引用类型和对象类型必须相符</strong>,例子中两者都是Dog<br><br>2.多态下的声明引用和创建对象的方法<br><br><code>Animal myDog = new Dog();</code><br><br>其中<strong>多态下引用类型和对象类型可以不相符</strong>,例子中引用类型为Animal,对象类型为Dog。<br></p>
<hr>

<h2 id="7-多态的运用范围"><a href="#7-多态的运用范围" class="headerlink" title="7.多态的运用范围"></a>7.多态的运用范围</h2><p>1.运用多态时,引用类型可以是<strong>实际对象类的父类</strong>(即继承树上方的类可以引用下方的子类)<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Animal[] animals = new Animal[2];</span><br><span class="line"></span><br><span class="line">animals [0] = new Dog();</span><br><span class="line">animals [1] = new Cat();</span><br><span class="line">//可以用animal 引用任何Animal的子类对象</span><br><span class="line"></span><br><span class="line">for(int i=0; i&lt;animals.length; i++)&#123;</span><br><span class="line">    animals[i].eat();</span><br><span class="line">    //当i为0是会调用Dog的eat();</span><br><span class="line">    //当i为1是会调用Cat的eat();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>2.<strong>返回类型</strong>和<strong>参数</strong>也可以多态<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Vet&#123;</span><br><span class="line">    public void giveShot(Animal a)&#123;</span><br><span class="line">    //参数可以是任何一种Animal下面的子类的类型对象</span><br><span class="line">        a.makeNoise();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class PetOwner&#123;</span><br><span class="line">    public void start()&#123;</span><br><span class="line">        Vet v = new Vet();</span><br><span class="line">        Dog d = new Dog();</span><br><span class="line">        Hippo h = new Hippo();</span><br><span class="line">        v.giveShot(d);</span><br><span class="line">        //执行Dog的makeNoise方法</span><br><span class="line">        v.giveShot(h);</span><br><span class="line">        //执行Hippo的makeNoise方法</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>

<h2 id="8-覆盖的规则与方法的重载"><a href="#8-覆盖的规则与方法的重载" class="headerlink" title="8.覆盖的规则与方法的重载"></a>8.覆盖的规则与方法的重载</h2><p>1.覆盖的规则<br><br>&nbsp;&nbsp;&nbsp;&nbsp;a.<strong>参数</strong>必须<strong>一样</strong>，且<strong>返回类型必须兼容</strong>。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;父类中的方法使用了哪种参数,覆盖此方法的子类也一定要<strong>使用相同的参数</strong>。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;而无论父类中的方法声明的返回类型是什么,子类必须声明返回<strong>一样的类型</strong>或者<strong>该类型的子类</strong>。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;b.<strong>不能降低</strong>方法的<strong>存取权限</strong>(即权限必须相同,或者更加公开)<br><br><br><br>2.方法的重载<br><br>&nbsp;&nbsp;&nbsp;&nbsp;a.重载与多态毫无关系。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;重载可以有<strong>同一方法</strong>的<strong>多个不同参数版本</strong>以方便调用。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;重载只是刚好有<strong>相同名字的方法</strong>,它与多态和继承没有关系。<strong>重载的方法和覆盖的方法不一样</strong>。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;b.重载的返回类型可以不同<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以任意的<strong>改变</strong>重载方法的<strong>返回类型</strong>,只要所有的<strong>覆盖</strong>使用<strong>不同的参数</strong>即可。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;c.重载不能只改变返回类型<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果<strong>只有返回类型不同</strong>,<strong>参数是一样的</strong>。这样是无法通过编译的。重载的条件是<strong>使用不同的参数</strong>。<br><br>&nbsp;&nbsp;&nbsp;&nbsp;d.重载可以<strong>更改存取权限</strong></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/570911275/570911275.github.io/2019/05/26/java-继承与多态小结/" data-id="cjwhhp0y5000izctnuw1bqkuu" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java-基础/">java_基础</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">下一页 &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/java-基础/">java_基础</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/java-基础/" style="font-size: 10px;">java_基础</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">六月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">五月 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/06/04/java-图形用户接口之下小结/">java_图形用户接口之下小结</a>
          </li>
        
          <li>
            <a href="/2019/06/03/java-图形用户接口之中小结/">java_图形用户接口之中小结</a>
          </li>
        
          <li>
            <a href="/2019/06/02/java-图形用户接口之上小结/">java_图形用户接口之上小结</a>
          </li>
        
          <li>
            <a href="/2019/06/01/java-异常处理小结/">java_异常处理小结</a>
          </li>
        
          <li>
            <a href="/2019/05/31/java-数字与静态之下小结/">java_数字与静态之下小结</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>
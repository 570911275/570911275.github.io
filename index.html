<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="https://github.com/570911275/570911275.github.io/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://github.com/570911275/570911275.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-新文档8888" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/31/新文档8888/" class="article-date">
  <time datetime="2019-07-31T13:24:17.469Z" itemprop="datePublished">2019-07-31</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="SpringMVC"><a href="#SpringMVC" class="headerlink" title="SpringMVC"></a>SpringMVC</h2><h3 id="SpringMVC的基本概念"><a href="#SpringMVC的基本概念" class="headerlink" title="SpringMVC的基本概念"></a>SpringMVC的基本概念</h3><pre><code>1. SpringMVC是什么：
     * SpringMVC是一种基于Java的实现MVC设计模型的请求驱动类型的轻量级Web框架。
     * SpringMVC通过一套注解，让一个简单的Java类成为处理请求的控制器，而无须实现任何接口。同时它还支持RESTful编程风格的请求。

2. 环境搭建：
     * 导入jar包
     * 搭建前端控制器
     * 搭建服务器

3. 入门案例总结：
     1. 启动服务器，加载一些配置文件
          * DispatchherServlet对象创建
          * springmvc.xml被加载了
          * HelloController创建成对象
     2. 发送请求，后台处理请求
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">          项目名称(/hello)</span><br><span class="line">       &lt;a href=&quot;hello&quot;&gt;入门程序&lt;/a&gt; </span><br><span class="line">                |                          6</span><br><span class="line">            1   |   |———————————————————————————————————————————————— |                        </span><br><span class="line">               \|  \|/                                                |    </span><br><span class="line">       7  控制中心、指挥中心   4         视图解析器对象          5      /|\</span><br><span class="line">结果 &lt;————DispatcherServlet ————&gt;InternalResourceViewResolver————&gt;success.jsp</span><br><span class="line">                |   |\</span><br><span class="line">            2   |   |   3</span><br><span class="line">               \|   |</span><br><span class="line">          @RequestMapping(path=&quot;/hello&quot;)</span><br><span class="line">public String sayHello()&#123;</span><br><span class="line">    System.out.println(&quot;hello StringMVC&quot;);</span><br><span class="line">    return &quot;success&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre><code>3. 入门案组件小结：
     1. DispatcherServlet：前端控制器 
          * 用户请求到达前端控制器，它就相当于 mvc 模式中的 c，dispatcherServlet 是整个流程控制的中心，由 它调用其它组件处理用户的请求，dispatcherServlet 的存在降低了组件之间的耦合性 

     2. HandlerMapping：处理器映射器
          * HandlerMapping 负责根据用户请求找到 Handler 即处理器，SpringMVC 提供了不同的映射器实现不同的 映射方式，例如：配置文件方式，实现接口方式，注解方式等。

     3. Handler：处理器 
          * 它就是我们开发中要编写的具体业务控制器。由 DispatcherServlet 把用户请求转发到 Handler。由 Handler 对具体的用户请求进行处理。

     4. HandlAdapter：处理器适配器 
          * 通过 HandlerAdapter 对处理器进行执行，这是适配器模式的应用，通过扩展适配器可以对更多类型的处理 器进行执行。 

     5. View Resolver：视图解析器 
          * View Resolver 负责将处理结果生成 View 视图，View Resolver 首先根据逻辑视图名解析成物理视图名 即具体的页面地址，再生成 View 视图对象，最后对 View 进行渲染将处理结果通过页面展示给用户

     6. View：视图 
          * SpringMVC 框架提供了很多的 View 视图类型的支持，包括：jstlView、freemarkerView、pdfView 等。我们最常用的视图就是 jsp。 一般情况下需要通过页面标签或页面模版技术将模型数据通过页面展示给用户，需要由程序员根据业务需求开发具体的页面

     7. &lt;mvc:annotation-driven&gt;说明
          * 在 SpringMVC 的各个组件中，处理器映射器、处理器适配器、视图解析器称为 SpringMVC 的三大组件。 
          * 使用&lt;mvc:annotation-driven&gt; 自动加载 RequestMappingHandlerMapping （处理映射器）和 RequestMappingHandlerAdapter （ 处 理 适 配 器 ） ， 
          * 可 用 在 SpringMVC.xml 配 置 文 件 中 使 用 &lt;mvc:annotation-driven&gt;替代注解处理器和适配器的配置。
          *  它就相当于在 xml 中配置了：
          *   &lt;!-- 上面的标签相当于 如下配置--&gt;
          *   &lt;!-- Begin --&gt;
          *   &lt;!-- HandlerMapping --&gt;
          *   &lt;bean

4. RequestMapping的作用：
      * 用于建立请求 URL 和处理请求方法之间的对应关系。
      * 出现位置：
            1. 类上：请求 URL 的第一级访问目录。此处不写的话，就相当于应用的根目录。写的话需要以/开头。它出现的目的是为了使我们的 URL 可以按照模块化管理
            2. 方法上：请求 URL 的第二级访问目录
</code></pre><pre><code>   账户模块：
     /account/add
     /account/update 
     /account/delete 
* account：是在类上
* add、update、delete：是在方法上 
</code></pre><pre><code>5. RequestMapping的属性：
       1. value：用于指定请求的URL。它和path属性的作用是一样的。
       2. method：用于指定请求的方式。
       3.   params：用于指定限制请求参数的条件。它支持简单的表达式。要求请求参数的 key 和 value 必须和 配置的一模一样。
</code></pre><p><code>例如：     params = {&quot;accountName&quot;}，表示请求参数必须有 accountName     params = {&quot;moeny!100&quot;}，表示请求参数中 money 不能是 100。</code>  </p>
<pre><code>4. headers：用于指定限制请求消息头的条件。
* 注意：   以上四个属性只要出现 2 个或以上时，他们的关系是与的关系。
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/570911275/570911275.github.io/2019/07/31/新文档8888/" data-id="cjytwd15d0000bwtnuzsr38hr" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-JavaEE之Spring快速入门之下小结" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/31/JavaEE之Spring快速入门之下小结/" class="article-date">
  <time datetime="2019-07-31T02:38:15.275Z" itemprop="datePublished">2019-07-31</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h2><h3 id="第五章————高级装配"><a href="#第五章————高级装配" class="headerlink" title="第五章————高级装配"></a>第五章————高级装配</h3><pre><code>1. Spring中的单例Bean
    1. 无论我们是否去主动获取bean对象，Spring上下文一加载就会创建bean对象
    2. 无论获取多少次，拿到的都是同一个对象
    3. 无论我们是否去主动获取或注入bean对象，Spring上下文一加载就会创建bean对象
    4. 无论注入多少次，拿到的都是同一个对象

2. bean的作用域
    1. 单例(sinleton)：
        * 在整个应用程序中，只创建bean的一个实例
    2. 原形(prototype)：
        * 每次注入或通过Spring上下文获取的时候，都会创建一个新的bean实例
    3. 会话(session)：
        * 在web应用中，为每个会话创建一个bean实例
    4. 请求(request)：
        * 在web应用中，为每个请求创建一个bean实例
    5. 单例与原形的区别：
          1. 单例：
              * scope=&quot;singleton&quot;
              * 1.无论我们是否去主动获取或注入bean对象，Spring上下文一加载就会创建bean对象
              * 2.无论注入多少次，拿到的都是同一个对象
          2. 原形：
              * scope=&quot;prototype&quot;
              * 1.Spring上下文加载的时候不会创建bean对象
              * 2.每次注入，都会拿到不同的bean对象

3. 自动装配中定义bean的作用域
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/570911275/570911275.github.io/2019/07/31/JavaEE之Spring快速入门之下小结/" data-id="cjyr8j4vh001ew8tn7w0g55tj" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-JavaEE之Spring快速入门之中小结" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/26/JavaEE之Spring快速入门之中小结/" class="article-date">
  <time datetime="2019-07-26T06:03:21.000Z" itemprop="datePublished">2019-07-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/26/JavaEE之Spring快速入门之中小结/">JavaEE之Spring快速入门之中小结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h2><h3 id="第三章————Java装配"><a href="#第三章————Java装配" class="headerlink" title="第三章————Java装配"></a>第三章————Java装配</h3><pre><code>1. 当我们想将第三方库中的组件装配到应用程序中，则没有办法在类上添加@Compenent和@Autowired等注解

2. 解决方案：显示配置
      * java中进行显示的配置(本章)
      * xml中进行显示的配置(第四章)

3. JavaConfig
     * 不同于自动装配的地方：
         * 无需在实现类标注注解：@Component
         * 无需在AppConfig出标注注解@ComponentScan

     * @Configuration
         * 同自动装配一样，同样需要给AppConfig文件标注此注解；
         * 表示其为配置文件（为JavaConfig的关键）

     * @Bean
         * 说明spring程序启动时会读取到Configuration注解
         * 而Configuration注解会将当前的类当成基础配置类
         * 并且会寻找有没有被标注为Bean的方法，如果有则此方法会在程序启动时自动调用
         * 由Bean标注的方法为单例的
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">AppConfig：</span><br><span class="line"></span><br><span class="line">@Configuration</span><br><span class="line">public class AppConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    //说明spring程序启动时会读取到Configuration注解</span><br><span class="line">    //而Configuration注解会将当前的类当成基础配置类</span><br><span class="line">    //并且会寻找有没有被标注为Bean的方法，如果有则此方法会在程序启动时自动调用</span><br><span class="line">    public UserDao userDaoNormal()&#123;</span><br><span class="line">        System.out.println(&quot;创建UserDao对象&quot;);</span><br><span class="line">        return new UserDaoNormal();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre><code>4. 依赖注入
     * 构造函数
        * 在类中定义构造函数(无参)与有参
        * 有参构造函数将UserDao和UserService关联起来
        * 自动装配时，需要在类名上标注注解@Component;在变量上标注注解@Autowired

     * Bean方法中使用参数
        * 由于实际情况中，在调用new被Bean标记的对象的方法时无新的对象产生
        * 而是之前便存在的。所以可采取不使用new方法

     * setter
        * 通过使用setter方法，进行依赖注入
     * 任意方法
        * 同setter一样，只是改一个方法名
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">1. 自动装配的情况下：</span><br><span class="line">@Service</span><br><span class="line">public class UserServiceNormal implements UserService &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private UserDao userDao;</span><br><span class="line">    public void add() &#123;</span><br><span class="line">        userDao.add();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2.1 带有构造函数的UserServiceNormal类：</span><br><span class="line">public class UserServiceNormal implements UserService &#123;</span><br><span class="line"></span><br><span class="line">    private UserDao userDao;</span><br><span class="line"></span><br><span class="line">    //构造函数注入</span><br><span class="line">    //无参构造函数</span><br><span class="line">    public UserServiceNormal() &#123;</span><br><span class="line">        super();</span><br><span class="line">    &#125;</span><br><span class="line">    //有参构造函数</span><br><span class="line">    //将UserDao和UserService关联起来</span><br><span class="line">    public UserServiceNormal(UserDao userDao) &#123;</span><br><span class="line">        this.userDao = userDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void add() &#123;</span><br><span class="line">        userDao.add();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">2.2 构造函数的情况下：</span><br><span class="line">@Configuration</span><br><span class="line">public class AppConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public UserDao userDaoNormal()&#123;</span><br><span class="line">        System.out.println(&quot;创建UserDao对象&quot;);</span><br><span class="line">        return new UserDaoNormal();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public UserService userServiceNormal()&#123;</span><br><span class="line">        System.out.println(&quot;创建UserService对象&quot;);</span><br><span class="line">        UserDao userDao = userDaoNormal();</span><br><span class="line">        return new UserServiceNormal(userDao);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">3. Bean方法中使用参数</span><br><span class="line">    @Bean</span><br><span class="line">    public UserService userServiceNormal(UserDao userDao)&#123;</span><br><span class="line">        System.out.println(&quot;创建UserService对象&quot;);</span><br><span class="line">        return new UserServiceNormal(userDao);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">4.1 set方法</span><br><span class="line">    public void setUserDao(UserDao userDao) &#123;</span><br><span class="line">        this.userDao = userDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">4.2 setter方法依赖注入</span><br><span class="line">    @Bean</span><br><span class="line">    public UserService userServiceNormal(UserDao userDao)&#123;</span><br><span class="line">        System.out.println(&quot;创建UserService对象&quot;);</span><br><span class="line">        UserServiceNormal userService = new UserServiceNormal();</span><br><span class="line">        userService.setUserDao(userDao);</span><br><span class="line">        return userService;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<pre><code>5. 装配过程的歧义性
     1. 当接口下的多个实现类被标注了Bean注解时将发生歧义性

     2. 同自动装配中使用的方法差不多
           * 首选Bean(@Primary)
              * 调用被标注了注解为@Primary的方法
              * 同样只能有一个@Primary

           * 使用限定符
              * 使用限定符，为每一个Bean标注Qualifier
              * 在使用时，参数位置处的Qualifier需要标注在括号内；而不是类外。

           * 使用限定符和bean id
              * 使用Bean id 同限定符的作用一样
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">1. 首选Bean：</span><br><span class="line">    @Bean</span><br><span class="line">    @Primary</span><br><span class="line">    public UserDao userDaoCache()&#123;...&#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public UserService userServiceNormal(UserDao userDao)&#123;...&#125;</span><br><span class="line"></span><br><span class="line">2. 使用限定符</span><br><span class="line">    @Bean</span><br><span class="line">    @Qualifier(&quot;cache&quot;)</span><br><span class="line">    public UserDao userDaoCache()&#123;...&#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    @Qualifier(&quot;normal&quot;)</span><br><span class="line">    public UserDao userDaoNormal()&#123;...&#125;</span><br><span class="line"></span><br><span class="line">调用方：</span><br><span class="line">    @Bean</span><br><span class="line">    public UserService userServiceNormal(@Qualifier(&quot;normal&quot;)UserDao userDao)&#123;...&#125;</span><br><span class="line">    @Bean</span><br><span class="line">    public UserService userServiceNormal(@Qualifier(&quot;normal&quot;)UserDao userDao)&#123;</span><br><span class="line">        System.out.println(&quot;创建UserService对象&quot;);</span><br><span class="line">        UserServiceNormal userService = new UserServiceNormal();</span><br><span class="line">        userService.prepare(userDao);</span><br><span class="line">        return userService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">3. 使用限定符和Bean id</span><br><span class="line">    @Bean(&quot;cache&quot;)</span><br><span class="line">    public UserDao userDaoCache()&#123;...&#125; </span><br><span class="line"></span><br><span class="line">    @Bean(&quot;normal&quot;)</span><br><span class="line">    public UserDao userDaoNormal()&#123;...&#125;</span><br><span class="line"></span><br><span class="line">调用方：</span><br><span class="line">    @Bean</span><br><span class="line">    public UserService userServiceNormal(@Qualifier(&quot;normal&quot;)UserDao userDao)&#123;...&#125;</span><br></pre></td></tr></table></figure>
<h3 id="第四章————XML装配"><a href="#第四章————XML装配" class="headerlink" title="第四章————XML装配"></a>第四章————XML装配</h3><pre><code>1. 创建Bean对象
    1. 配置applicationContext.xml文件
        * 添加&lt;bean class=&quot;com.qfedu.demo.soundsystem.CompactDisc&quot;/&gt;语句
        * 此语句中的class为bean对象所在的类

    2. 配置文件中存在多个相同Bean对象时，编译器将无法识别是使用哪一个Bean对象
        * 此时需要为Bean对象赋予id
        * &lt;bean  id=&quot;compactDisc1&quot; class=&quot;com.qfedu.demo.soundsystem.CompactDisc&quot;/&gt;
        * &lt;bean  id=&quot;compactDisc2&quot; class=&quot;com.qfedu.demo.soundsystem.CompactDisc&quot;/&gt;

    3. id和name属性
        1. id属性为唯一的，不可重复
        2. name的作用是和id一样的
            * 当有多个name时，可通过空格、分号、逗号进行分割
            * name=&quot;compactDisc1 compacDisc12&quot;
        3. name中Bean对象可以有多个别名，id中Bean只能有一个别名
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">    &lt;bean id=&quot;compactDisc1&quot; class=&quot;com.qfedu.demo.soundsystem.CompactDisc&quot;/&gt;</span><br><span class="line">    &lt;bean id=&quot;compactDisc2&quot; class=&quot;com.qfedu.demo.soundsystem.CompactDisc&quot;/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean name=&quot;compactDisc1 compactDisc12&quot; class=&quot;com.qfedu.demo.soundsystem.CompactDisc&quot;/&gt;</span><br><span class="line">    &lt;bean name=&quot;compactDisc2&quot; class=&quot;com.qfedu.demo.soundsystem.CompactDisc&quot;/&gt;</span><br><span class="line">```             </span><br><span class="line"></span><br><span class="line">           4. 通过构造函数依赖注入</span><br><span class="line">               1. &lt;constructor-arg&gt;元素</span><br><span class="line">                   * 将其他对象作为参数传入此对象中</span><br><span class="line">               2. c-名称空间</span><br><span class="line">                   * 使用C名称空间，声明构造函数的参数；作为了Bean元素的一个属性</span><br><span class="line">                   * c:cd-ref</span><br><span class="line">                        * c: ——&gt;c名称空间的前缀</span><br><span class="line">                        * cd ——&gt;构造函数的参数名称</span><br><span class="line">                        * -ref——&gt;表示我们注入的是另一个Bean对象的引用</span><br></pre></td></tr></table></figure>
<ol>
<li><p><constructor-arg></constructor-arg></p>
 <bean id="CDPlayer1" class="com.qfedu.demo.soundsystem.CDPlayer"><br>     <constructor-arg ref="compactDisc1"><br> </constructor-arg></bean>
</li>
<li><p>c名称空间<br> <bean id="cdPlayer2" class="com.qfedu.demo.soundsystem.CDPlayer" c:cd-ref="compactDisc2"></bean></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">5. 简单类型的注入</span><br><span class="line">     1. 通过&lt;constructor-arg&gt;</span><br><span class="line">          * 默认情况下按照顺序逐个赋值传入对象</span><br><span class="line">     2. c-名称空间</span><br><span class="line">          * c:变量名=“值”</span><br></pre></td></tr></table></figure>
</li>
<li><p><constructor-arg></constructor-arg></p>
 <bean id="compactDisc1" class="com.qfedu.demo.soundsystem.CompactDisc"><br>     <constructor-arg index="0" value="I DO"><br>     <constructor-arg index="1" value="陈奕迅"><br> </constructor-arg></constructor-arg></bean><br> <bean id="compactDisc1" class="com.qfedu.demo.soundsystem.CompactDisc"><br>     <constructor-arg name="title" value="I DO"><br>     <constructor-arg name="artist" value="陈奕迅"><br> </constructor-arg></constructor-arg></bean>
</li>
<li><p>c-名称空间<br> <bean id="compactDisc2" class="com.qfedu.demo.soundsystem.CompactDisc" c:title="周杰伦的床边故事" c:artist="周杰伦"><br> <bean id="compactDisc3" class="com.qfedu.demo.soundsystem.CompactDisc" c:_0="周杰伦的床边故事" c:_1="周杰伦"></bean></bean></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">6. 注入list与数组类型</span><br><span class="line">     1. 简单数据类型的List</span><br><span class="line">            * 使用value</span><br><span class="line">     2. 对象类型的List </span><br><span class="line">            * 先使用Bean创建对象</span><br><span class="line">            * 再使用ref</span><br><span class="line">     3. 数组：只需将list标签改为array即可</span><br></pre></td></tr></table></figure>
</li>
<li><p>简单数据类型</p>
 <bean id="compactDisc1" class="com.qfedu.demo.soundsystem.CompactDisc"><br>     <constructor-arg name="title" value="I DO"><br>     <constructor-arg name="artist" value="陈奕迅"><br>     <constructor-arg name="tracks"><br>         <list><br>             <value>I DO 1</value><br>             <value>I DO 2</value><br>             <value>I DO 3</value><br>         </list><br>     </constructor-arg><br> </constructor-arg></constructor-arg></bean>
</li>
<li><p>对象类型<br>2.1 创建对象<br> <bean id="music1" class="com.qfedu.demo.soundsystem.Music"></bean></p>
<pre><code>&lt;constructor-arg value=&quot;I Do 1&quot;/&gt;
&lt;constructor-arg value=&quot;270&quot;/&gt;
</code></pre><p> <br> <bean id="music2" class="com.qfedu.demo.soundsystem.Music"></bean></p>
<pre><code>&lt;constructor-arg value=&quot;I Do 2&quot;/&gt;
&lt;constructor-arg value=&quot;90&quot;/&gt;
</code></pre><p> <br>2.2 使用ref<br> <bean id="compactDisc1" class="com.qfedu.demo.soundsystem.CompactDisc"></bean></p>
<pre><code>&lt;constructor-arg  name=&quot;title&quot; value=&quot;I DO&quot;/&gt;
&lt;constructor-arg  name=&quot;artist&quot; value=&quot;陈奕迅&quot;/&gt;
&lt;constructor-arg  name=&quot;tracks&quot;&gt;
    &lt;list&gt;
        &lt;ref bean=&quot;music1&quot;/&gt;
        &lt;ref bean=&quot;music2&quot;/&gt;
    &lt;/list&gt;
&lt;/constructor-arg&gt;
</code></pre><p> </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">7. 注入set与数组类型</span><br><span class="line">    1. 用法：同list一样；只需将list标签改为set即可</span><br><span class="line"> </span><br><span class="line">    </span><br><span class="line">    2. 与list的区别：set中不可出现重复的内容；重复的内容将不会再处理 </span><br><span class="line">    </span><br><span class="line">    3. 底层使用的是ListHashSet：使得顺序可以得到保证</span><br><span class="line"></span><br><span class="line">8. 注入map类型</span><br><span class="line">    1. 用法：同list一样；只需改动标签</span><br><span class="line">    </span><br><span class="line">    2. 与list的区别：</span><br><span class="line">         1. 遍历的时候，是遍历key；随后根据key来得到key和value</span><br><span class="line">         2. 在配置文件中的标签要使用&lt;entry &gt;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>遍历：<br>        for (String key : tracks.keySet()) {<br>            System.out.println(“key: “+key);<br>            Music music = tracks.get(key);<br>            System.out.println(“音乐：”+music.getTitle()+”时长：”+music.getDuration());<br>        }</p>
<p>配置文件：<br>    <bean id="compactDisc1" class="com.qfedu.demo.soundsystem.CompactDisc"><br>        <constructor-arg name="title" value="I DO"><br>        <constructor-arg name="artist" value="陈奕迅"><br>        <constructor-arg name="tracks"><br>            <map><br>                <entry key="m1" value-ref="music1"><br>                <entry key="m2" value-ref="music2"><br>                <entry key="m3" value-ref="music3"><br>            </entry></entry></entry></map><br>        </constructor-arg><br>    </constructor-arg></constructor-arg></bean><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">9. 属性注入：</span><br><span class="line">   * 即使用set方法进行依赖注入</span><br><span class="line">    1. 在配置文件中进行Bean对象的依赖注入</span><br><span class="line">         1. 使用property标签</span><br><span class="line">         2. 用name表示属性名</span><br><span class="line">         3. 简单数据用value;引用使用ref</span><br><span class="line">         4. 在配置文件中进行Bean对象的依赖注入后</span><br><span class="line">         *  只要标有注解ContextConfiguration即可自动加载出Bean</span><br></pre></td></tr></table></figure></p>
<p>两个Bean对象的依赖注入：</p>
<pre><code>&lt;bean id=&quot;music1&quot; class=&quot;com.qfedu.demo.soundsystem.Music&quot;&gt;
    &lt;property name=&quot;title&quot; value=&quot;告白气球&quot;/&gt;
    &lt;property name=&quot;duration&quot; value=&quot;215&quot;/&gt;
&lt;/bean&gt;

&lt;bean id=&quot;music2&quot; class=&quot;com.qfedu.demo.soundsystem.Music&quot;&gt;
    &lt;property name=&quot;title&quot; value=&quot;爱情废材&quot;/&gt;
    &lt;property name=&quot;duration&quot; value=&quot;305&quot;/&gt;
&lt;/bean&gt;
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">10. 属性中注入列表和数组：</span><br></pre></td></tr></table></figure>
<pre><code>&lt;bean id=&quot;CompactDisc1&quot; class=&quot;com.qfedu.demo.soundsystem.CompactDisc&quot;&gt;
    &lt;property name=&quot;title&quot; value=&quot;周杰伦的床边故事&quot;/&gt;
    &lt;property name=&quot;artist&quot; value=&quot;周杰伦&quot;/&gt;
    &lt;property name=&quot;tracks&quot;&gt;
        &lt;array&gt;
            &lt;ref bean=&quot;music1&quot;/&gt;
            &lt;ref bean=&quot;music2&quot;/&gt;
        &lt;/array&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">11. 属性中注入对象和引用：</span><br><span class="line">      * 需要配置set方法</span><br><span class="line">      * 随后在配置文件中使用set方法进行依赖注入</span><br></pre></td></tr></table></figure>
<pre><code>public void setCd(CompactDisc cd) {
    this.cd = cd;
    System.out.println(&quot;--在&quot;+this.toString()+&quot;中注入cd&quot;);
}
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">12. p名称空间：</span><br><span class="line">     1. 首先在开头的网站中引入p名称空间</span><br><span class="line">          * xmlns:p=&quot;http://www.springframework.org/schema/p&quot;</span><br><span class="line">     </span><br><span class="line">     2. p名称空间的使用</span><br><span class="line">          * 使用P：属性名=&quot;值&quot;的形式</span><br><span class="line">          * 缺点：无法代替数组、集合等形式</span><br></pre></td></tr></table></figure>
<p>p名称空间的使用</p>
<ol>
<li>简单类型 <bean id="music2" class="com.qfedu.demo.soundsystem.Music" p:title="爱情废柴" p:duration="305"></bean></li>
<li><p>对象的引用<br> &lt;bean id=”CDPlayer1” class=”com.qfedu.demo.soundsystem.CDPlayer”</p>
<pre><code>p:cd-ref=&quot;CompactDisc1&quot;/&gt;
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">13. util名称空间：</span><br><span class="line">      1. 可以处理p无法处理的数组与集合等形式</span><br><span class="line">     </span><br><span class="line">      2. 与c和p的不同：</span><br><span class="line">           * c和p的使用位置是位于元素属性位置</span><br><span class="line">           * util的使用位置是位于元素前缀位置</span><br><span class="line">          </span><br><span class="line">      3. util名称空间的使用：</span><br><span class="line">           1. 在元素前缀加上&lt;util:list&gt;&lt;/util:list&gt;标签。则在网址处将自动添加3个网址</span><br><span class="line">           2. list：可表示list与数组</span><br><span class="line">              map:表示map</span><br><span class="line">              set:表示set</span><br></pre></td></tr></table></figure>
<p> &lt;util:list id=”trackList”&gt;</p>
<pre><code>&lt;ref bean=&quot;music1&quot;/&gt;
&lt;ref bean=&quot;music2&quot;/&gt;
</code></pre><p> &lt;/util:list&gt;<br> &lt;bean id=”CompactDisc1” class=”com.qfedu.demo.soundsystem.CompactDisc”</p>
<pre><code>p:title=&quot;周杰伦的床边故事&quot;
p:artist=&quot;周杰伦&quot;
p:tracks-ref=&quot;trackList&quot;&gt;
</code></pre><p> <br><code>`</code></p>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/570911275/570911275.github.io/2019/07/26/JavaEE之Spring快速入门之中小结/" data-id="cjyr8j4za003dw8tnphm1wyqz" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/javaEE-基础/">javaEE_基础</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-JavaEE之Spring快速入门之上小结" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/26/JavaEE之Spring快速入门之上小结/" class="article-date">
  <time datetime="2019-07-26T01:57:41.000Z" itemprop="datePublished">2019-07-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/26/JavaEE之Spring快速入门之上小结/">JavaEE之Spring快速入门之上小结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h2><h3 id="第一章————入门"><a href="#第一章————入门" class="headerlink" title="第一章————入门"></a>第一章————入门</h3><pre><code>1. 概念：
   * Spring是一个非常活跃的开源框架
   * 由Rod Johnson开发
   * 帮助分离项目组件之间的依赖关系
   * 它的主要目的是简化企业开发

2. 核心概念：
   1. IOC
       * Inversion of Control
       * 控制反转
       * 对象创建以及对象之间的依赖关系的维护交给Spring
   2. DI
       * Dependency Injection
       * 依赖注入
       * 对象和对象之间的依赖关系的创建
   3. AOP
       * Aspect Oriented Programming
       * 面向切面编程

3. log4j日志
       * 导入依赖
       * *导入配置文件
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">配置文件：</span><br><span class="line"></span><br><span class="line">log4j.rootCategory=INFO, stdout</span><br><span class="line"></span><br><span class="line">log4j.appender.stdout=org.apache.log4j.ConsoleAppender</span><br><span class="line">log4j.appender.stdout.layout=org.apache.log4j.PatternLayout</span><br><span class="line">log4j.appender.stdout.layout.ConversionPattern=%d&#123;ABSOLUTE&#125; %5p %t %c&#123;2&#125;:%L - %m%n</span><br><span class="line"></span><br><span class="line">log4j.category.org.springframework.beans.factory=DEBUG</span><br><span class="line"></span><br><span class="line">导入依赖</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;log4j&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;log4j&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.2.17&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<pre><code>4. 入门程序的应用
     1. 注解方式的使用
          1. @Component
              * 此注解的作用为通知spring容器，
              * 我们应用程序的对象——此例子中为MessageService
              * 未来将通过Spring容器进行创建；无需人工new创建
          2. @ComponentScan
              * 基于注解的方式来初始化Spring容器
              * 主键扫描注解
              * 即扫描一切有注解Component的类
          3. @Autowired
              * 表示调用MessagePrinter类时，将会自动调用此方法
              * 即自动关联起MessagePrinter和MessageService的关系
     2. xml文件配置方式的使用
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--</span><br><span class="line">   bean元素：描述当前的对象需要由spring容器管理</span><br><span class="line">   id属性：标识对象，未来在应用程序中可以根据id获取对象</span><br><span class="line">   class：被管理对象的类全名</span><br><span class="line"> --&gt;</span><br><span class="line">&lt;bean id=&quot;service&quot; class=&quot;hello.MessageService&quot;&gt;&lt;/bean&gt;</span><br><span class="line">&lt;bean id=&quot;printer&quot; class=&quot;hello.MessagePrinter&quot;&gt;</span><br><span class="line">    &lt;!--name属性的值：与MessagePrinter中的service属性对应</span><br><span class="line">        ref：表示name属性指向的对象；在此例中，此对象为id=service的bean对象--&gt;</span><br><span class="line">    &lt;property name=&quot;service&quot; ref=&quot;service&quot;&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>
<h3 id="第二章————自动装配"><a href="#第二章————自动装配" class="headerlink" title="第二章————自动装配"></a>第二章————自动装配</h3><pre><code>1. bean对象的装配：
    1. 依赖注入的概念：
       * 通过Spring来管理对象和对象之间的依赖关系
    2. java中的对象称为bean对象
       * 把在java中创建bean对象和为这个对象注入依赖的过程称为装配bean或bean的装配

2. 装配bean的三种方式
     * 隐式的bean发现机制和自动装配
     * 在java中进行显示的配置
     * 在xml中进行显示的配置

3. 自动装配中的注解：
    1. 组件扫描：
         * @Component：表示这个类需要在应用程序中被创建
         * @ComponentScan：自动发现应用程序中创建的类
    2. 自动装配：
         * @Autowired：自动满足bean之间的依赖
    3. 定义配置类：
         * @Configuration：表示当前类是一个配置类
         * 作用：
             * 将ComponentScan注解与main主函数进行解耦
             * 使得在不存在main主函数时，可以在其他环境(web、安卓、iOS)下进行组件扫描

4. Junit4单元测试
     1. 引入依赖
           1. Maven：Junit、Spring-test
           2. @RunWith(SpringJUnit4ClassRunner.class)
              * 此注解为自动生成Spring的上下文环境
     2. 加载配置类
           1. @ContextConfiguration(classes=Appconfig.class)
              * 读取配置文件
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@RunWith(SpringJUnit4ClassRunner.class)</span><br><span class="line">////此注解为自动生成Spring的上下文环境</span><br><span class="line">@ContextConfiguration(classes=Appconfig.class)</span><br><span class="line">////读取配置文件</span><br><span class="line">public class AppTest &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private CDPlayer player;</span><br><span class="line">    @Test</span><br><span class="line">    public void testPlay()&#123;</span><br><span class="line">        player.play();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre><code>5. AutoWriter的应用场景
     1. 构造函数（*）
          * 自动将构造函数中的参数装配到当前类的bean对象中
          * *多个依赖的情况
          * 效率最高
     2. 用在成员变量上
          * 最便捷
     3. 用在setter方法上
     4. 用在任意方法上
     5. required属性
       *  应用场景：
          * @Autowired(required = false)[默认为true]
          * 表示注入的对象是可选的
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">1. 构造方法</span><br><span class="line">    @Autowired</span><br><span class="line">    public CDPlayer(CompactDisc cd, Power power) &#123;</span><br><span class="line">        this.cd = cd;</span><br><span class="line">        this.power = power;</span><br><span class="line">        System.out.println(&quot;CDPlayer的多参数构造函数&quot;);</span><br><span class="line"></span><br><span class="line">2. 成员变量</span><br><span class="line">    //@Autowired</span><br><span class="line">    private CompactDisc cd;</span><br><span class="line">    //@Autowired</span><br><span class="line">    private Power power;</span><br><span class="line"></span><br><span class="line">3. setter方法</span><br><span class="line">    @Autowired</span><br><span class="line">    public void setCd(CompactDisc cd) &#123;</span><br><span class="line">        this.cd = cd;</span><br><span class="line">        System.out.println(&quot;CD&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    @Autowired</span><br><span class="line">    public void setPower(Power power) &#123;</span><br><span class="line">        this.power = power;</span><br><span class="line">        System.out.println(&quot;POWER&quot;);</span><br><span class="line"></span><br><span class="line">4. 任意方法</span><br><span class="line">    @Autowired</span><br><span class="line">    public void prepare(CompactDisc cd ,Power power)&#123;</span><br><span class="line">        this.cd = cd;</span><br><span class="line">        this.power = power;</span><br><span class="line">        System.out.println(&quot;prepare&quot;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<pre><code>6. 使用接口
    1. 应用场景：
         * @Autowired(required = false)
         * 表示注入的对象是可选的
    2. 自动装配的歧义性
         * 当接口下有多个实现类且都使用了@Component注解
         * 所以当他们被扫描的时候能在Spring应用上下文里面的bean
         * 这时进行自动装配，将会发生歧义性
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class UserServiceFestival implements UserService &#123;...&#125;</span><br><span class="line"></span><br><span class="line">@Component</span><br><span class="line">public class UserServiceNormal implements UserService &#123;...&#125;</span><br></pre></td></tr></table></figure>
<pre><code>3. 自动装配的歧义性的解决方案
     1. 设置首选Bean(primary)
         * 在声明类的时候使用@Primary
         * 只能定义一个@Primary
         * 缺点：如果我们不止一个primary那么编译器将报错。则首选就没有办法解决歧义性
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">@Primary</span><br><span class="line">public class UserServiceNormal implements UserService &#123;...&#125;</span><br></pre></td></tr></table></figure>
<pre><code>2. 使用限定符(Qualifier)
    * 在声明的时候和装配的时候分别使用@Qualifier
    * 通过在实现类标识注解Qualifier，可使得调用接口时，让Spring确认是需要是需要传输该接口下的哪一个Bean对象
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">实现类：</span><br><span class="line">@Component</span><br><span class="line">@Qualifier(&quot;festival&quot;)</span><br><span class="line">public class UserServiceFestival implements UserService &#123;...&#125;</span><br><span class="line"></span><br><span class="line">@Component</span><br><span class="line">@Qualifier(&quot;normal&quot;)</span><br><span class="line">public class UserServiceNormal implements UserService &#123;...&#125;</span><br><span class="line"></span><br><span class="line">调用接口：</span><br><span class="line">@RunWith(SpringJUnit4ClassRunner.class)</span><br><span class="line">@ContextConfiguration(classes = AppConfig.class)</span><br><span class="line">public class UserServiceTest &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    @Qualifier(&quot;festival&quot;)</span><br><span class="line">    private UserService userService;</span><br><span class="line">    @Test</span><br><span class="line">    public void testAdd()&#123;</span><br><span class="line">        userService.add();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre><code>3. 使用类ID
     * 在声明的的时候指定bean的id（默认的id是首写字母小写的类名）
     * 在装配的时候使用@Qualifier
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">无默认时：</span><br><span class="line"></span><br><span class="line">实现类：</span><br><span class="line">@Component(&quot;festival&quot;)</span><br><span class="line">public class UserServiceFestival implements UserService &#123;...&#125;</span><br><span class="line">调用接口：</span><br><span class="line">public class UserServiceTest &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    @Qualifier(&quot;festival&quot;)</span><br><span class="line">    private UserService userService;</span><br><span class="line">    @Test</span><br><span class="line">    public void testAdd()&#123;</span><br><span class="line">        userService.add();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">默认时：</span><br><span class="line"></span><br><span class="line">实现类：</span><br><span class="line">@Component</span><br><span class="line">public class UserServiceFestival implements UserService &#123;...&#125;</span><br><span class="line">调用接口：</span><br><span class="line">public class UserServiceTest &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    @Qualifier(&quot;userServiceFestival&quot;)</span><br><span class="line">    private UserService userService;</span><br><span class="line">    @Test</span><br><span class="line">    public void testAdd()&#123;</span><br><span class="line">        userService.add();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre><code>4. 使用Java标准的解决方案(Resource)
     * 此方法并非Spring中的标准
     * 使用此方法可替代下边两个注解
         * @Autowired
         * @Qualifier
     * 用法同类ID
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/*    @Autowired</span><br><span class="line"> @Qualifier(&quot;festival&quot;)*/</span><br><span class="line"> @Resource(name=&quot;userServiceFestival&quot;)</span><br><span class="line"> private UserService userService;</span><br></pre></td></tr></table></figure>
<pre><code>7. 处理分层结构
    1. web程序的基本架构：
        浏览器——&gt;web层(controller)——&gt;业务层(service)——&gt;数据访问层(dao)——Data
           * 其中业务层(service)、数据访问层(dao)皆细分为接口与实现类
    2. 新的注解(Repository、service、controller)
        * Repository——dao层
        * service——service层
        * controller——web层
        * 这三个注解可替换掉@Component，更加明确的标注了此类是什么层次的类


8. 设置组件扫描的基础包
     1. 默认情况下@ComponentScan只可扫描其所在的包以及其子包下的类

     2. 解决方案：
         1. @ComponentScan(&quot;包名&quot;)
            * @ComponentScan(&quot;com.qfedu.demo&quot;)
              * 指定扫描的包名
         2. @ComponentScan(basePackages = {&quot;包名&quot;,&quot;包名&quot;,&quot;包名&quot;}) 
            * @ComponentScan(basePackages = {&quot;com.qfedu.demo.web&quot;,&quot;com.qfedu.demo.service&quot;,&quot;com.qfedu.demo.dao&quot;}) 
              * 可指定多个扫描的包名
         3. @ComponentScan(basePackagesClasses = {类名,类名,类名})
            * @ComponentScan(basePackagesClasses = {UserController.class,UserService.class,UserDao.class})
              * 可指定多个扫描的类名

     3. 通过xml启用组件扫描
         1. 配置applicationContext.xml文件(此文件的作用相当于注解@Configuration)
              * @Configuration的作用：表示该文件为配置文件

         2. 使用标签&lt;context:component-scan&gt;
              * &lt;context:component-scan base-package=&quot;com.qfedu.demo&quot;/&gt;
              * 此标签的作用相当于注解@ComponentScan(&quot;com.qfedu.demo&quot;)
              * 规划了扫描范围

         3. 使用时注解同样要发生变化
              * @ContextConfiguration(&quot;classpath:applicationContext.xml&quot;)
              * 代替了@ContextConfiguration(classes = AppConfig.class)
              * 使得其配置文件从Appconfig.class变化为applicationContext。xml配置文件

9. 小结
   1. 定义配置：
      * @Configuration
      * ComponentScan

   2. 定义组件
      * @Component
      * @Autowired
      * @Autowired(required = false)

   3. 自动装配歧义性
      * @Primary
      * @Qualifier
      * @Resource

   4. 分层架构中定义组件
      * Controller
      * Service

   5. Spring测试环境
      * RunWith
      * ContextConfiguration

   6. 使用xml启用组件扫描
      * &lt;context:component-scan base-package=&quot;...&quot;&gt;
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/570911275/570911275.github.io/2019/07/26/JavaEE之Spring快速入门之上小结/" data-id="cjyr8j4wr001pw8tno4n0offm" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/javaEE-基础/">javaEE_基础</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-JavaEE之MyBatis高级知识之下小结" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/25/JavaEE之MyBatis高级知识之下小结/" class="article-date">
  <time datetime="2019-07-25T10:52:11.000Z" itemprop="datePublished">2019-07-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/25/JavaEE之MyBatis高级知识之下小结/">JavaEE之MyBatis高级知识之下小结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="MyBatis"><a href="#MyBatis" class="headerlink" title="MyBatis"></a>MyBatis</h2><pre><code>1. 基础知识（重点，内容多）
    对原生态jdbc程序（单独使用jdbc开发）问题总结
    mybatis框架原理（掌握）
    mybatis入门程序
         用户的增删改查
    mybatis开发两种方法：
         原始dao开发方法（程序需要编写dao接口和dao实现类）（掌握）
         mybaits的mapper接口（相当于dao接口）代理开发方法（掌握）
    mybatis配置文件SqlMapConfig.xml
    mybatis核心：
         mybatis输入映射（掌握）
         mybatis输出映射（掌握）
    mybatis的动态SQL（掌握）

 2. 高级知识
    订单商品数据模型分析
    高级结果集映射（一对一，一对多，多对多）
    mybatis延迟加载
    mybatis查询缓冲（一级缓冲、二级缓冲）
    mybaits和spring进行整合（掌握）
    mybatis逆向工程
</code></pre><h3 id="一、高级知识"><a href="#一、高级知识" class="headerlink" title="一、高级知识"></a>一、高级知识</h3><h4 id="1-mybatis查询缓存（一级缓存、二级缓存）————mybatis整合ehcache："><a href="#1-mybatis查询缓存（一级缓存、二级缓存）————mybatis整合ehcache：" class="headerlink" title="1. mybatis查询缓存（一级缓存、二级缓存）————mybatis整合ehcache："></a>1. mybatis查询缓存（一级缓存、二级缓存）————mybatis整合ehcache：</h4><pre><code>1. ehcache:
    * ehcache是一个分布式缓存框架

2. 分布缓存：
    * 我们系统为了提高系统并发，性能、一般对系统进行分布式部署（集群部署方式）
    * 不使用分布缓存，缓存的数据在各各服务单独存储，不方便系统 开发。所以要使用分布式缓存对缓存数据进行集中管理。
    * 对缓存数据进行集中管理（redis集群）使用分布式缓存框架
       * 如：redis、memcached、ehcache。。。
    * mybatis无法实现分布式缓存，因此需要和其它分布式缓存框架进行整合。

3. 整合方法：
    1. 引入缓存的依赖包
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.ehcache&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;ehcache&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;3.8.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.mybatis.caches&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;mybatis-ehcache&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.1.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<pre><code>2. 引入缓存配置文件
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;ehcache xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">         xsi:noNamespaceSchemaLocation=&quot;http://ehcache.org/ehcache.xsd&quot;&gt;</span><br><span class="line">    &lt;diskStore path=&quot;D:\ehcache&quot;/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 默认缓存配置 --&gt;</span><br><span class="line">    &lt;defaultCache</span><br><span class="line">            maxElementsInMemory=&quot;10000&quot;</span><br><span class="line">            eternal=&quot;false&quot;</span><br><span class="line">            timeToIdleSeconds=&quot;120&quot;</span><br><span class="line">            timeToLiveSeconds=&quot;120&quot;</span><br><span class="line">            overflowToDisk=&quot;true&quot;</span><br><span class="line">    /&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;/ehcache&gt;</span><br></pre></td></tr></table></figure>
<pre><code>3. 引入xsd的url
   * 打开settings-&gt;languages&amp;frameworks-&gt;schemas and dtds ,添加地址 http://ehcache.org/ehcache.xsd

4. 开启ehcache缓存
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">修改mapper.xml文件，在cache中指定EhcacheCache。</span><br><span class="line">&lt;cache type=&quot;org.mybatis.caches.ehcache.EhcacheCache&quot;/&gt;</span><br><span class="line"></span><br><span class="line">根据需求调整缓存参数：</span><br><span class="line">&lt;cache type=&quot;org.mybatis.caches.ehcache.EhcacheCache&quot; &gt; </span><br><span class="line">        &lt;property name=&quot;timeToIdleSeconds&quot; value=&quot;3600&quot;/&gt;</span><br><span class="line">        &lt;property name=&quot;timeToLiveSeconds&quot; value=&quot;3600&quot;/&gt;</span><br><span class="line">        &lt;!-- 同ehcache参数maxElementsInMemory --&gt;</span><br><span class="line">		&lt;property name=&quot;maxEntriesLocalHeap&quot; value=&quot;1000&quot;/&gt;</span><br><span class="line">		&lt;!-- 同ehcache参数maxElementsOnDisk --&gt;</span><br><span class="line">        &lt;property name=&quot;maxEntriesLocalDisk&quot; value=&quot;10000000&quot;/&gt;</span><br><span class="line">        &lt;property name=&quot;memoryStoreEvictionPolicy&quot; value=&quot;LRU&quot;/&gt;</span><br><span class="line">    &lt;/cache&gt;</span><br></pre></td></tr></table></figure>
<h4 id="2-mybaits和spring进行整合（掌握）"><a href="#2-mybaits和spring进行整合（掌握）" class="headerlink" title="2. mybaits和spring进行整合（掌握）"></a>2. mybaits和spring进行整合（掌握）</h4><pre><code>1. 整合思路：
    1. 需要spring通过单例方式管理SqlSessionFactory
    2. spring和mybatis整合生成代理对象，使用SqlSessionFactory创建SqlSession。（Spring和mybatis整合自动完成）
    3. 持久层的mapper都需要由spring进行管理

2. 整合环境
    1. 导入jar包
        * mybatis
        * spring
        * mybatis_spring整合包
        * 此处为了方便，直接导入mybatis、spring、springMVC的整合

3. sqlSessionFactory
     1. 在applicationContext.xml配置sqlSessionFactory和数据源
     2. sqlSessionFactory在mybatis和spring的整合包下
</code></pre><pre><code>&lt;!-- 加载db.properties文件 --&gt;
&lt;context:property-placeholder location=&quot;classpath:db.properties&quot;/&gt;

   &lt;!-- 配置数据库连接池 --&gt;
   &lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt;
       &lt;property name=&quot;driverClassName&quot; value=&quot;${jdbc.driver}&quot;&gt;&lt;/property&gt;
       &lt;property name=&quot;url&quot; value=&quot;${jdbc.url}&quot;&gt;&lt;/property&gt;
       &lt;property name=&quot;username&quot; value=&quot;${jdbc.username}&quot;&gt;&lt;/property&gt;
       &lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot;&gt;&lt;/property&gt;
   &lt;/bean&gt;

   &lt;!--sqlSessionFactory--&gt;
   &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;
       &lt;!--加载mybatis的配置文件--&gt;
       &lt;property name=&quot;configLocation&quot; value=&quot;SqlMapConfig.xml&quot;/&gt;
       &lt;!--数据源--&gt;
       &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;
   &lt;/bean&gt;
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/570911275/570911275.github.io/2019/07/25/JavaEE之MyBatis高级知识之下小结/" data-id="cjyr8j4uy0014w8tn0mvupe2p" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/javaEE-基础/">javaEE_基础</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-JavaEE之MyBatis高级知识之中小结" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/25/JavaEE之MyBatis高级知识之中小结/" class="article-date">
  <time datetime="2019-07-25T06:06:16.000Z" itemprop="datePublished">2019-07-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/25/JavaEE之MyBatis高级知识之中小结/">JavaEE之MyBatis高级知识之中小结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="MyBatis"><a href="#MyBatis" class="headerlink" title="MyBatis"></a>MyBatis</h2><pre><code>1. 基础知识（重点，内容多）
    对原生态jdbc程序（单独使用jdbc开发）问题总结
    mybatis框架原理（掌握）
    mybatis入门程序
         用户的增删改查
    mybatis开发两种方法：
         原始dao开发方法（程序需要编写dao接口和dao实现类）（掌握）
         mybaits的mapper接口（相当于dao接口）代理开发方法（掌握）
    mybatis配置文件SqlMapConfig.xml
    mybatis核心：
         mybatis输入映射（掌握）
         mybatis输出映射（掌握）
    mybatis的动态SQL（掌握）

 2. 高级知识
    订单商品数据模型分析
    高级结果集映射（一对一，一对多，多对多）
    mybatis延迟加载
    mybatis查询缓冲（一级缓冲、二级缓冲）
    mybaits和spring进行整合（掌握）
    mybatis逆向工程
</code></pre><h3 id="一、高级知识"><a href="#一、高级知识" class="headerlink" title="一、高级知识"></a>一、高级知识</h3><h4 id="1-mybatis延迟加载："><a href="#1-mybatis延迟加载：" class="headerlink" title="1. mybatis延迟加载："></a>1. mybatis延迟加载：</h4><pre><code>1. 概念：
    * resultMap可以实现高级映射(使用association、collection实现一对一及一对多映射)，association、collection具备延迟加载功能。
    * 需求：
       * 如果查询订单并且关联查询用户信息。如果先查询订单信息即可满足要求，当我们需要查询用户信息时再查询用户信息。把对用户信息的按需去查询就是延迟加载
    * 延迟加载：先从单表查询，需要时再从关联表去关联查询，大大提高数据库性能，因为查询单表要比关联表查询多张表速度要快

2. 使用association实现延迟加载：
  * 查询订单并且关联查询用户信息
     1. mapper.xml
       * 需要定义两个mapper的方法对呀的statement
       1. 只查询订单信息
       SELECT * FROM orders
       在查询订单的statement中使用association去延迟加载（执行）下边的satatement关联查询用户信息
       2. 关联查询用户信息
           *通过上边查询到的订单信息中的user_id去关联查询用户信息

 2.1 定义延迟加载resultMap
      **使用association中的select指定延迟加载去执行的statement的id**
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;resultMap type=&quot;cn.itcast.po.Orders&quot; id=&quot;OrderUserLazyLoadingResultMap&quot;&gt;</span><br><span class="line">     &lt;!--对订单信息进行映射配置--&gt;</span><br><span class="line">     &lt;id column=&quot;id&quot; property=&quot;id&quot;/&gt;</span><br><span class="line">     &lt;result column=&quot;user_id&quot; property=&quot;userId&quot;/&gt;</span><br><span class="line">     &lt;result column=&quot;createtime&quot; property=&quot;createtime&quot;/&gt;</span><br><span class="line">     &lt;result column=&quot;note&quot; property=&quot;note&quot;/&gt;</span><br><span class="line">     &lt;result column=&quot;number&quot; property=&quot;number&quot;/&gt;</span><br><span class="line">     &lt;!--对用户信息进行延迟加载--&gt;</span><br><span class="line">     &lt;!--select：指定延迟加载需要执行的statement的id（是根据user_id去查询用户信息的statement）</span><br><span class="line">         要使用userMapper.xml中findUserById完成根据用户id(user_id)用户信息的查询</span><br><span class="line">         如果findUserById不在本mapper中，前面需要加namespace</span><br><span class="line">         column：订单的信息中关联用户信息查询的列，是user_id</span><br><span class="line">         关联查询的SQL理解为：</span><br><span class="line">             SELECT orders.*,</span><br><span class="line">            (SELECT username FROM USER WHERE orders.`user_id`=user.`id`)username,</span><br><span class="line">            (SELECT sex FROM USER WHERE orders.`user_id`=user.`id`)sex</span><br><span class="line">             FROM orders--&gt;</span><br><span class="line">     &lt;association property=&quot;user&quot; javaType=&quot;cn.itcast.po.User&quot; select=&quot;cn.itcast.mapper.UserMapper.findUserById&quot; column=&quot;user_id&quot;&gt;</span><br><span class="line"></span><br><span class="line">     &lt;/association&gt;</span><br><span class="line"> &lt;/resultMap&gt;</span><br></pre></td></tr></table></figure>
<pre><code>2.2 mapper.xml
  1. 只查询订单信息
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id=&quot;findOrderUserLazyLoading&quot; resultMap=&quot;OrderUserLazyLoadingResultMap&quot;&gt;</span><br><span class="line">    SELECT * FROM orders</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure>
<pre><code>2. 关联查询用户信息
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id=&quot;findUserById&quot; parameterType=&quot;int&quot; resultType=&quot;cn.itcast.po.User&quot;&gt;</span><br><span class="line">      SELECT * FROM USER WHERE id=#&#123;id&#125;</span><br><span class="line"> &lt;/select&gt;</span><br></pre></td></tr></table></figure>
<pre><code>  3. 思路：
      * 上边先去执行findOrdersUserLazyLoding,当需要去查询用户的时候再去执行findUserById，通过resultMap的定义将延迟加载配置起来

2.3 mapper.java
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//查询订单关联用户信息，用户信息使用延迟加载</span><br><span class="line">public List&lt;Orders&gt; findOrderUserLazyLoading() throws Exception;</span><br></pre></td></tr></table></figure>
<pre><code>2.4 测试思路：
    1. 执行上边mapper方法(findOrdersUserLazyLoading)，内部去调用cn.itcast.mapper.OrdersMapperCustom中的findOrdersUserLazyLoading,只查询orders信息（单表）
    2. 在程序汇总去遍历上一步查询出的List&lt;Orders&gt;，当我们调用Orders中的getUser方法时，开始进行延迟加载
    3. 延迟加载，去调用UserMapper.xml中的findUserbyId这个方法获取用户信息

2.5 延迟加载配置：
    * mybatis默认没有开启延迟加载，需要在SqlMapConfig.xml中setting配置
    *  设置项                      描述                           允许值          默认值
  lazyLoadingEnabled        全局性设置懒加载。如果设为‘false’， true | false      false
                            则所有相关联的都会被初始化加载。    

  aggressiveLazyLoading        当设置为‘true’的时候，             true | false      true
                            懒加载的对象可能被任何懒属性全部加载。
                            否则，每个属性都按需加载。    
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--全局配置参数，需要时再设置--&gt;</span><br><span class="line">&lt;settings&gt;</span><br><span class="line">    &lt;!--打开延迟加载的开关--&gt;</span><br><span class="line">    &lt;setting name=&quot;lazyLoadingEnabled&quot; value=&quot;true&quot;/&gt;</span><br><span class="line">    &lt;setting name=&quot;aggressiveLazyLoading&quot; value=&quot;false&quot;/&gt;</span><br><span class="line">&lt;/settings&gt;</span><br></pre></td></tr></table></figure>
<pre><code>2.5 测试类
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public void findOrderUserLazyLoading() throws Exception&#123;</span><br><span class="line">    //mybatis配置文件</span><br><span class="line">    String resource = &quot;SqlMapConfig.xml&quot;;</span><br><span class="line">    //得到配置文件流</span><br><span class="line">    InputStream inputStream = Resources.getResourceAsStream(resource);</span><br><span class="line">    //创建会话工厂,传入mybatis的配置文件信息</span><br><span class="line">    SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);</span><br><span class="line">    SqlSession sqlSession = sqlSessionFactory.openSession();</span><br><span class="line">    //创建OrdersMapperCustom对象，mybatis自动生成OrderMapperCustom代理对象</span><br><span class="line">    OrdersMapperCustom ordersMapperCustom = sqlSession.getMapper(OrdersMapperCustom.class);</span><br><span class="line"></span><br><span class="line">    //查询订单信息（单表）</span><br><span class="line">    List&lt;Orders&gt;  list = ordersMapperCustom.findOrderUserLazyLoading();</span><br><span class="line">    //遍历上边的订单列表</span><br><span class="line">    for (Orders orders : list) &#123;</span><br><span class="line">        //执行getUser()去查询用户信息，这里实现按需加载</span><br><span class="line">         User user = orders.getUser();</span><br><span class="line">        System.out.println(user);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    sqlSession.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre><code>2.6 延迟加载思考
   * 不使用mybatis提供的association及collection中的延迟加载功能如何实现延迟加载？
   * 实现方法：
       * 定义两个mapper方法：
          1. 查询订单列表
          2. 根据用户id查询用户信息
   * 实现思路：
       * 先去查询第一个mapper方法，获取订单信息列表
       * 在程序中（service），按需去调用第二个mapper方法去查询用户信息

2.7 延迟加载总结
   * 使用延迟加载方法，先去查询简单的SQL（最好单表，也可以关联查询），再去按需要加载关联查询的其他信息 
</code></pre><h4 id="2-mybatis查询缓存（一级缓存、二级缓存）————一级缓存："><a href="#2-mybatis查询缓存（一级缓存、二级缓存）————一级缓存：" class="headerlink" title="2. mybatis查询缓存（一级缓存、二级缓存）————一级缓存："></a>2. mybatis查询缓存（一级缓存、二级缓存）————一级缓存：</h4><pre><code>1. 一级缓存和二级缓存的定义：
     1. Mybatis一级缓存的作用域是同一个SqlSession，在同一个sqlSession中两次执行相同的sql语句，第一次执行完毕会将数据库中查询的数据写到缓存（内存），第二次会从缓存中获取数据将不再从数据库查询，从而提高查询效率。当一个sqlSession结束后该sqlSession中的一级缓存也就不存在了。Mybatis默认开启一级缓存。

     2. Mybatis二级缓存是多个SqlSession共享的，其作用域是mapper的同一个namespace，不同的sqlSession两次执行相同namespace下的sql语句且向sql中传递参数也相同即最终执行相同的sql语句，第一次执行完毕会将数据库中查询的数据写到缓存（内存），第二次会从缓存中获取数据将不再从数据库查询，从而提高查询效率。Mybatis默认没有开启二级缓存需要在setting全局参数中配置开启二级缓存。

2. 一级缓存的流程：
     1. 第一次发起查询用户id为1的用户信息，先去找缓存中是否有id为1的用户信息，如果没有从数据库查询用户信息得到用户信息，将用户信息存储到一级缓存中
     2. 如果SqlSession去执行commit操作（执行插入、更新、删除），情况SqlSession中的一级缓存，这样做的目的是让缓存中存储的是最      新的信息，避免脏读。
     3. 第二次发起查询用户id为1的用户信息，先去找缓存中是否有id为1的用户信息，缓存汇总有，直接从缓存中获取用户信息 

3. 一级缓存的测试：
     * mybatis默认支持一级缓存，不需要在配置文件中去配置
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">	public void testCache1() throws Exception&#123;</span><br><span class="line">		SqlSession sqlSession = sqlSessionFactory.openSession();//创建代理对象</span><br><span class="line">		UserMapper userMapper = sqlSession.getMapper(UserMapper.class);</span><br><span class="line">		</span><br><span class="line">		//下边查询使用一个SqlSession</span><br><span class="line">		//第一次发起请求，查询id为1的用户</span><br><span class="line">		User user1 = userMapper.findUserById(1);</span><br><span class="line">		System.out.println(user1);</span><br><span class="line">		</span><br><span class="line">//		如果sqlSession去执行commit操作（执行插入、更新、删除），清空SqlSession中的一级缓存，这样做的目的为了让缓存中存储的是最新的信息，避免脏读。</span><br><span class="line">		</span><br><span class="line">		//更新user1的信息</span><br><span class="line">		user1.setUsername(&quot;测试用户22&quot;);</span><br><span class="line">		userMapper.updateUser(user1);</span><br><span class="line">		//执行commit操作去清空缓存</span><br><span class="line">		sqlSession.commit();</span><br><span class="line">		</span><br><span class="line">		//第二次发起请求，查询id为1的用户</span><br><span class="line">		User user2 = userMapper.findUserById(1);</span><br><span class="line">		System.out.println(user2);</span><br><span class="line">		</span><br><span class="line">		sqlSession.close();</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<pre><code>3. 一级缓存的实际运用：
   * 正式开放：是将mybatis和spring进行整合开发，事务控制在service中。
   * 一个service方法中包括很多mapper方法调用
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">service&#123;</span><br><span class="line">    //开始执行时，开启事务，创建SqlSession对象</span><br><span class="line">    //第一次调用mapper的方法findUserById(1)</span><br><span class="line">  </span><br><span class="line">    //第二次调用mapper的方法findUserById(1)从一级缓存中取数据</span><br><span class="line">    //方法介绍，SqlSession关闭</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre><code>* 如果是执行两次service调用查询相同的用户信息，不走一级缓存，因为session方法结束，sqlSession就关闭，一级缓存就清空  
* 
</code></pre><h4 id="1-mybatis查询缓存（一级缓存、二级缓存）————二级缓存："><a href="#1-mybatis查询缓存（一级缓存、二级缓存）————二级缓存：" class="headerlink" title="1. mybatis查询缓存（一级缓存、二级缓存）————二级缓存："></a>1. mybatis查询缓存（一级缓存、二级缓存）————二级缓存：</h4><pre><code>1. 一级缓存和二级缓存的定义：
     1. Mybatis一级缓存的作用域是同一个SqlSession，在同一个sqlSession中两次执行相同的sql语句，第一次执行完毕会将数据库中查询的数据写到缓存（内存），第二次会从缓存中获取数据将不再从数据库查询，从而提高查询效率。当一个sqlSession结束后该sqlSession中的一级缓存也就不存在了。Mybatis默认开启一级缓存。

     2. Mybatis二级缓存是多个SqlSession共享的，其作用域是mapper的同一个namespace，不同的sqlSession两次执行相同namespace下的sql语句且向sql中传递参数也相同即最终执行相同的sql语句，第一次执行完毕会将数据库中查询的数据写到缓存（内存），第二次会从缓存中获取数据将不再从数据库查询，从而提高查询效率。Mybatis默认没有开启二级缓存需要在setting全局参数中配置开启二级缓存。

2. 二级缓存的流程：
     1. 首先开启mybatis的二级缓存
     2. sqlSession1去查询用户id为1的用户信息，查询到用户信息会将查询数据存储到二级缓存中
     3. sqlSession2去查询用户id为1的用户信息，去缓存中找是否存在数据，如果存在直接从缓存中取出数据
     4. 如果sqlSession3去执行相同mapper下的SQL，执行commit提交，清空该mapper下的二级缓存区域的数据
     5. 二级缓存和一级缓存区别：二级缓存的范围更大，多个sqlSession可以共享mapper的一个二级缓存
     * UserMapper有一个二级缓存区域(按namespace分)，其他mapper也有自己的二级缓存区域(按namespace分)
     * 每一个namespace的mapper有一个二级缓存区域。即：两个mapper的namespace如果相同，这两个mapper执行SQL查询到的数据将存在相同的二级缓存区域中

3. 二级缓存的开启
     * mybatis的二级缓存是mapper范围级别，除了在SqlMapper.xml设置二级缓存的总开关，还要在具体的mapper.xml中开启二级缓存
        * SqlMapper.xml中设置二级缓存的总开关
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--开启二级缓存--&gt;</span><br><span class="line">&lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&gt;</span><br></pre></td></tr></table></figure>
<pre><code>* 在UserMapper.xml中开启二级缓存，UserMapper.xml下的SQL执行完成会存储到它的缓存区域(HashMap)
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--开启本mapper的namespace下的二级缓存--&gt;</span><br><span class="line">&lt;cache/&gt;</span><br></pre></td></tr></table></figure>
<pre><code>4. 调用pojo类实现序列化接口
      * 为了将缓存数据取出执行反序列化操作，因为二级缓存数据存储介质多种多样，不一定在内存，可能在硬盘或者远程服务
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public class User implements Serializable &#123;</span><br></pre></td></tr></table></figure>
<pre><code>5. 二级缓存的测试方法
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">// 二级缓存测试</span><br><span class="line">	@Test</span><br><span class="line">	public void testCache2() throws Exception &#123;</span><br><span class="line">		SqlSession sqlSession1 = sqlSessionFactory.openSession();</span><br><span class="line">		SqlSession sqlSession2 = sqlSessionFactory.openSession();</span><br><span class="line">		SqlSession sqlSession3 = sqlSessionFactory.openSession();</span><br><span class="line">		// 创建代理对象</span><br><span class="line">		UserMapper userMapper1 = sqlSession1.getMapper(UserMapper.class);</span><br><span class="line">		// 第一次发起请求，查询id为1的用户</span><br><span class="line">		User user1 = userMapper1.findUserById(1);</span><br><span class="line">		System.out.println(user1);</span><br><span class="line">		</span><br><span class="line">		//这里执行关闭操作，将sqlsession中的数据写到二级缓存区域</span><br><span class="line">		sqlSession1.close();</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		//使用sqlSession3执行commit()操作</span><br><span class="line">		UserMapper userMapper3 = sqlSession3.getMapper(UserMapper.class);</span><br><span class="line">		User user  = userMapper3.findUserById(1);</span><br><span class="line">		user.setUsername(&quot;张明明&quot;);</span><br><span class="line">		userMapper3.updateUser(user);</span><br><span class="line">		//执行提交，清空UserMapper下边的二级缓存</span><br><span class="line">		sqlSession3.commit();</span><br><span class="line">		sqlSession3.close();</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line"></span><br><span class="line">		UserMapper userMapper2 = sqlSession2.getMapper(UserMapper.class);</span><br><span class="line">		// 第二次发起请求，查询id为1的用户</span><br><span class="line">		User user2 = userMapper2.findUserById(1);</span><br><span class="line">		System.out.println(user2);</span><br><span class="line"></span><br><span class="line">		sqlSession2.close();</span><br><span class="line"></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<pre><code>6. 二级缓存的useCache配置
    1. 在statement中设置useCache=false可以禁用当前select语句的二级缓存，即每次查询都会发出sql去查询，默认情况是true，即该sql使用二级缓存。
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id=&quot;findOrderListResultMap&quot; resultMap=&quot;ordersUserMap&quot; useCache=&quot;false&quot;&gt;</span><br></pre></td></tr></table></figure>
<pre><code>    * 总结：针对每次查询都需要最新的数据sql，要设置成useCache=false，禁用二级缓存。

7. 二级缓存的刷新缓存（就是清空缓存）
    1. 在mapper的同一个namespace中，如果有其它insert、update、delete操作数据后需要刷新缓存，如果不执行刷新缓存会出现脏读。

    2. 设置statement配置中的flushCache=&quot;true&quot; 属性，默认情况下为true即刷新缓存，如果改成false则不会刷新。使用缓存时如果手动修改数据库表中的查询数据会出现脏读。
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">如下：</span><br><span class="line">&lt;insert id=&quot;insertUser&quot; parameterType=&quot;cn.itcast.mybatis.po.User&quot; flushCache=&quot;true&quot;&gt;</span><br></pre></td></tr></table></figure>
<pre><code>   * 总结：一般下执行完commit操作都需要刷新缓存，flushCache=true表示刷新缓存，这样可以避免数据库脏读。

8.    应用场景
    1. 对于访问多的查询请求且用户对查询结果实时性要求不高，此时可采用mybatis二级缓存技术降低数据库访问量，提高访问速度，业务场景比如：耗时较高的统计分析sql、电话账单查询sql等。

    2. 实现方法如下：通过设置刷新间隔时间，由mybatis每隔一段时间自动清空缓存，根据数据变化频率设置缓存刷新间隔flushInterval，比如设置为30分钟、60分钟、24小时等，根据需求而定。


9.    局限性
    1. mybatis二级缓存对细粒度的数据级别的缓存实现不好，
    2. 比如如下需求：对商品信息进行缓存，由于商品信息查询访问量大，但是要求用户每次都能查询最新的商品信息，此时如果使用mybatis的二级缓存就无法实现当一个商品变化时只刷新该商品的缓存信息而不刷新其它商品的信息，
    3. 因为mybaits的二级缓存区域以mapper为单位划分，当一个商品信息变化会将所有商品信息的缓存数据全部清空。解决此类问题需要在业务层根据需求对数据有针对性缓存。
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/570911275/570911275.github.io/2019/07/25/JavaEE之MyBatis高级知识之中小结/" data-id="cjyr8j4zl003kw8tnqgdtkf23" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/javaEE-基础/">javaEE_基础</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-JavaEE之MyBatis高级知识之上小结" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/25/JavaEE之MyBatis高级知识之上小结/" class="article-date">
  <time datetime="2019-07-25T02:42:26.000Z" itemprop="datePublished">2019-07-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/25/JavaEE之MyBatis高级知识之上小结/">JavaEE之MyBatis高级知识之上小结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="MyBatis"><a href="#MyBatis" class="headerlink" title="MyBatis"></a>MyBatis</h2><pre><code>1. 基础知识（重点，内容多）
    对原生态jdbc程序（单独使用jdbc开发）问题总结
    mybatis框架原理（掌握）
    mybatis入门程序
         用户的增删改查
    mybatis开发两种方法：
         原始dao开发方法（程序需要编写dao接口和dao实现类）（掌握）
         mybaits的mapper接口（相当于dao接口）代理开发方法（掌握）
    mybatis配置文件SqlMapConfig.xml
    mybatis核心：
         mybatis输入映射（掌握）
         mybatis输出映射（掌握）
    mybatis的动态SQL（掌握）

 2. 高级知识
    订单商品数据模型分析
    高级结果集映射（一对一，一对多，多对多）
    mybatis延迟加载
    mybatis查询缓冲（一级缓冲、二级缓冲）
    mybaits和spring进行整合（掌握）
    mybatis逆向工程
</code></pre><h3 id="一、高级知识"><a href="#一、高级知识" class="headerlink" title="一、高级知识"></a>一、高级知识</h3><h4 id="1-订单商品数据模型分析"><a href="#1-订单商品数据模型分析" class="headerlink" title="1. 订单商品数据模型分析"></a>1. 订单商品数据模型分析</h4><pre><code>1.1 数据模型分析思路：
     1. 每张表记录的数据内容：
          * 分模块对每张表记录的内容进行熟悉，相当于你学习系统需求（功能）的过程
     2. 每张表重要的字段设置：
          * 非空字段、外键字段
     3. 数据库级别表与表之间的关系
          * 外键关系
     4. 表与表之间的业务关系
          * 在分析表与表之间的业务关系时一定要建立在某个业务意义基础上去分析 
</code></pre><h4 id="2-高级结果集映射（一对一，一对多，多对多）"><a href="#2-高级结果集映射（一对一，一对多，多对多）" class="headerlink" title="2. 高级结果集映射（一对一，一对多，多对多）"></a>2. 高级结果集映射（一对一，一对多，多对多）</h4><pre><code>2.1 一对一查询：
     * 查询订单信息，关联查询创建订单的用户信息
  2.1.1 resultType
    2.1.1.1 SQL语句
           1. 确定查询的主表：订单表
           2. 确定查询的关联表：用户表
               * 关联查询使用内连接还是外连接
                    * 由于orders表中有一个外键（user_id），通过外键关联查询用户表只能查询出来一条记录
                    * 因此可以内连接
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">SQL语句：</span><br><span class="line"></span><br><span class="line">SELECT </span><br><span class="line">       orders.*,</span><br><span class="line">       user.`sex`,</span><br><span class="line">       user.`address`,</span><br><span class="line">       user.`birthday`,</span><br><span class="line">       user.`username`     </span><br><span class="line">FROM</span><br><span class="line"> orders,USER </span><br><span class="line"> WHERE orders.`user_id`=user.`id`</span><br></pre></td></tr></table></figure>
<pre><code>2.1.1.2 创建pojo
        1. 将上边SQL查询的结果映射到pojo中，pojo中必须包含所有的查询列名
            * 原始的Order.java不能映射全部字段，需要新创建的pojo
            * 解决方法：创建一个pojo继承包括查询字段较多的po类

2.1.1.3 mapper.xml
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--查询订单关联用户信息--&gt;</span><br><span class="line">&lt;select id=&quot;findOrderUser&quot;  resultMap=&quot;cn.itcast.po.OrdersCustom&quot;&gt;</span><br><span class="line">    SELECT</span><br><span class="line">   orders.*,</span><br><span class="line">   user.`sex`,</span><br><span class="line">   user.`address`,</span><br><span class="line">   user.`birthday`,</span><br><span class="line">   user.`username`</span><br><span class="line">   FROM</span><br><span class="line">   orders,USER</span><br><span class="line">   WHERE orders.`user_id`=user.`id`</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure>
<pre><code>2.1.1.4 mapper.java
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public interface OrdersMapperCustom &#123;</span><br><span class="line">    //查询订单关联用户信息</span><br><span class="line">    public List&lt;OrdersCustom&gt; findOrdersUser() throws Exception;</span><br><span class="line">&#125;</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">         2.1.2 resultMap</span><br><span class="line">           2.1.2.1 SQL语句</span><br><span class="line">               * 同resultType一样</span><br><span class="line">           2.1.2.2 定义resultMap</span><br></pre></td></tr></table></figure>
<pre><code>&lt;!--订单查询关联用户的resultMap
    将整个查询的结果映射额到cn.itcast.po.Orders中
    --&gt;
&lt;resultMap type=&quot;cn.itcast.po.Orders&quot; id=&quot;OrdersUserResultMap&quot;&gt;
        &lt;!--配置映射的订单信息--&gt;
        &lt;!--id:指定查询列中的唯一标识，订单信息中的唯一标识，如果有多个列组成唯一标识，配置多个id
            column：订单信息的唯一标识列
            property：订单信息的唯一标识列所映射到Orders中的哪一个属性
            --&gt;
    &lt;id column=&quot;id&quot; property=&quot;id&quot;/&gt;
    &lt;result column=&quot;user_id&quot; property=&quot;userId&quot;/&gt;
    &lt;result column=&quot;number&quot; property=&quot;number&quot;/&gt;
    &lt;result column=&quot;createtime&quot; property=&quot;createtime&quot;/&gt;
    &lt;result column=&quot;note&quot; property=&quot;note&quot;/&gt;

    &lt;!--配置映射的关联的用户信息--&gt;
    &lt;!--association:用于映射关联查询单个对象的信息
        property:要将关联查询的用户信息映射到Orders中的哪一个属性--&gt;
    &lt;association property=&quot;user&quot; javaType=&quot;cn.itcast.po.User&quot; &gt;
        &lt;!--id:关联用户的唯一标识
            column：指定唯一标识用户信息的列
            JavaType：映射到user的哪一个属性--&gt;
        &lt;id column=&quot;user_id&quot; property=&quot;id&quot;/&gt;
        &lt;result column=&quot;usernmae&quot; property=&quot;username&quot;/&gt;
        &lt;result column=&quot;address&quot; property=&quot;address&quot;/&gt;
        &lt;result column=&quot;birthday&quot; property=&quot;birthday&quot;/&gt;
        &lt;result column=&quot;sex&quot; property=&quot;sex&quot;/&gt;
    &lt;/association&gt;
&lt;/resultMap&gt;
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2.1.2.3 mapper.xml</span><br></pre></td></tr></table></figure>
<pre><code>&lt;select id=&quot;findOrdersUserResultMap&quot;  resultMap=&quot;OrdersUserResultMap&quot;&gt;
    SELECT
   orders.*,
   user.`sex`,
   user.`address`,
   user.`birthday`,
   user.`username`
   FROM
   orders,USER
   WHERE orders.`user_id`=user.`id`
&lt;/select&gt;
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2.1.2.3 mapper.java</span><br></pre></td></tr></table></figure>
<pre><code>//查询订单关联用户信息使用resultMap
public List&lt;Orders&gt; findOrdersUserResultMap() throws Exception;
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2.1.2.3 Orders.java</span><br></pre></td></tr></table></figure>
<pre><code>private User user;
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">     </span><br><span class="line">    </span><br><span class="line">  2.1.3 resultType和resultMap实现一对一查询小结</span><br><span class="line">        * resultType:使用resultType实现较为简单，如果pojo中没有包括查询出来的列名。需要增加列名对应的属性，即可完成映射</span><br><span class="line">        * 如果没有查询结果的特殊要求建议使用resultType</span><br><span class="line"></span><br><span class="line">        * resultMap：需要单独定义resultMap,实现有点麻烦，如果对查询结果有特殊要求，使用resultMap可以完成将关联查询映射pojo的属性中</span><br><span class="line"></span><br><span class="line">        * resultMap可以实现延迟加载，resultType无法实现延迟加载</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2.2 一对多查询</span><br><span class="line">   * 查询订单及订单明细的信息</span><br><span class="line">  2.2.1 SQL语句</span><br><span class="line">      * 确定主查询表：订单表</span><br><span class="line">      * 确定关联查询表：订单明细  </span><br><span class="line">      * 在一对以查询继承上添加订单明细表关联即可   </span><br><span class="line">      * **在此处对orderDetails.id设置别名，避免与orders.id发送冲突**</span><br></pre></td></tr></table></figure>
<p>SQL语句：<br>        SELECT<br>       orders.*,<br>       orderdetail.<code>id</code> orderdetail_id,<br>       orderdetail.<code>orders_id</code>,<br>       orderdetail.<code>items_id</code>,<br>       orderdetail.<code>items_num</code>,<br>       user.<code>sex</code>,<br>       user.<code>address</code>,<br>       user.<code>birthday</code>,<br>       user.<code>username</code></p>
<pre><code>FROM
orders,USER,orderdetail
WHERE orders.`user_id`=user.`id` AND orderdetail.`orders_id`=orders.`id`
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">2.2.2 分析：</span><br><span class="line">   * 使用resultType将上边的查询结果映射到pojo中，订单信息就是重复</span><br><span class="line">   * 要求：</span><br><span class="line">       * 对orders映射不能出现重复记录</span><br><span class="line">   * 方法：</span><br><span class="line">       * 在orders.java类中添加List&lt;orderDetail&gt;orderDetails属性</span><br><span class="line">       * 最终会将订单信息映射到orders中，订单所对应的订单明细映射到orders中的orderDetails属性中。</span><br><span class="line">       * 映射成的orders记录数为两条(orders信息不重复)</span><br><span class="line">       * 每个orders中的orderDetails属性存储了该订单过对应的订单明细</span><br><span class="line"></span><br><span class="line">2.2.3 在orders.java类中添加List&lt;orderDetail&gt;orderDetails属性</span><br></pre></td></tr></table></figure>
<pre><code>//订单明细
private List&lt;Orderdetail&gt; orderdetails;
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">2.2.4 定义resultMap</span><br><span class="line">       * 使用了继承</span><br></pre></td></tr></table></figure>
<pre><code>&lt;!--订单及订单明细的resultMap--&gt;
&lt;!--使用extends继承，不用在中配置订单信息和用户信息的映射--&gt;
&lt;resultMap type=&quot;cn.itcast.po.Orders&quot; id=&quot;findOrdersAndOrderDetailResultMap&quot; extends=&quot;OrdersUserResultMap&quot;&gt;
    &lt;!--订单信息--&gt;
    &lt;!--用户信息--&gt;
    &lt;!--使用extends继承，不用在中配置订单信息和用户信息的映射--&gt;
    &lt;!--订单明细信息--&gt;
    &lt;!--一个订单关联查询出来多条明细，要使用collection进行映射
        collection：对关联查询到多条记录映射到集合对象中
        association:用于映射关联查询单个对象的信息
        一个多个，一个单个
        property:要将关联查询的多条记录映射到Orders中的哪一个属性
        ofType:指定映射到list集合属性中pojo的类型--&gt;
    &lt;collection property=&quot;orderdetails&quot; ofType=&quot;cn.itcast.po.Orderdetail&quot;&gt;
        &lt;!--id:订单明细的唯一标识
            property:要将订单明细中的唯一标识映射到Orderdetail的哪一个属性--&gt;
        &lt;id column=&quot;orderdetail_id&quot; property=&quot;id&quot;/&gt;
        &lt;result column=&quot;orders_id&quot; property=&quot;ordersId&quot;/&gt;
        &lt;result column=&quot;items_id&quot; property=&quot;itemsId&quot;/&gt;
        &lt;result column=&quot;items_num&quot; property=&quot;itemsNum&quot;/&gt;
    &lt;/collection&gt;
&lt;/resultMap&gt;
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">2.2.5 mapper.xml</span><br></pre></td></tr></table></figure>
<pre><code>&lt;!--查询订单关联用户信息以及订单明细，使用resultMap--&gt;
&lt;select id=&quot;findOrdersAndOrderDetailResultMap&quot;  resultMap=&quot;findOrdersAndOrderDetailResultMap&quot;&gt;
   SELECT
   orders.*,
   orderdetail.id orderdetail_id,
   orderdetail.`orders_id`,
   orderdetail.`items_id`,
   orderdetail.`items_num`,
   user.`sex`,
   user.`address`,
   user.`username`

   FROM
   orders,USER,orderdetail
   WHERE orders.`user_id`=user.`id` AND orderdetail.`orders_id`=orders.`id`
&lt;/select&gt;
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2.2.6 mapper.java</span><br></pre></td></tr></table></figure>
<pre><code>//查询订单(关联用户)及订单明细
public List&lt;Orders&gt; findOrdersAndOrderDetailResultMap() throws  Exception;
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2.2.7 测试类</span><br></pre></td></tr></table></figure>
<pre><code>public void findOrdersAndOrderDetailResultMap() throws Exception {
    //mybatis配置文件
    String resource = &quot;SqlMapConfig.xml&quot;;
    //得到配置文件流
    InputStream inputStream = Resources.getResourceAsStream(resource);
    //创建会话工厂,传入mybatis的配置文件信息
    SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);
    SqlSession sqlSession = sqlSessionFactory.openSession();
    //创建OrdersMapperCustom对象，mybatis自动生成OrderMapperCustom代理对象
    OrdersMapperCustom ordersMapperCustom = sqlSession.getMapper(OrdersMapperCustom.class);

    List&lt;Orders&gt; list = ordersMapperCustom.findOrdersAndOrderDetailResultMap();

    System.out.println(list);

    sqlSession.close();

}
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  2.2.8 小结</span><br><span class="line">      * mybatis使用resultMap的collection对关联查询的多条记录映射到一个list集合属性汇总。</span><br><span class="line">      * 使用resultType实现：</span><br><span class="line">           * 将订单明细映射到orders中的orderdetails中，需要自己处理，使用双重循环遍历，去掉重复记录，将订单明细放在orderdetails中</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2.3 多对多查询</span><br><span class="line">   * 查询用户及用户购买商品信息</span><br><span class="line"></span><br><span class="line">  2.3.1 SQL语句</span><br><span class="line">     * 查询主表是：用户表</span><br><span class="line">     * 关联表：由于用户和商品没有直接关联，通过订单和订单明细进行关联</span><br><span class="line">     * 所以关联表是：orders、orderdetails、items</span><br></pre></td></tr></table></figure>
<pre><code> SELECT
orders.*,
items.`id` items_id,
items.`name` items_name,
items.`detail` items_detail,
items.`price` items_price,
orderdetail.`id` orderdetail_id,
orderdetail.`orders_id`,
orderdetail.`items_id`,
orderdetail.`items_num`,
user.`sex`,
user.`address`,
user.`birthday`,
user.`username`

FROM
orders,USER,orderdetail,items
WHERE orders.`user_id`=user.`id`
 AND orderdetail.`orders_id`=orders.`id`
 AND orderdetail.`items_id`=items.`id`
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">2.3.2 映射思路 </span><br><span class="line">   * 将用户信息映射到user中</span><br><span class="line">   * 在user类中添加订单列表属性List&lt;Orders&gt;ordersList，将用户创建的订单映射到ordersList</span><br><span class="line">   * 在Orders中添加订单明细列表属性List&lt;OrderDetail&gt;orderdetail,将订单的明细映射到orderdetail</span><br><span class="line">   * 在OrderDetail中添加items属性，将订单明细所对应的商品映射到items</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2.3.3 定义resultMap</span><br><span class="line">   * 无法使用继承</span><br><span class="line">   * 通过表与表之间的对应关系，进行连接</span><br></pre></td></tr></table></figure>
<pre><code>&lt;!--查询订单关联用户信息与商品信息的resultMap--&gt;
&lt;resultMap type=&quot;cn.itcast.po.User&quot;   id=&quot;findUserAndItemsResultMap&quot; &gt;
    &lt;!--用户信息--&gt;
    &lt;id column=&quot;user_id&quot; property=&quot;id&quot;/&gt;
    &lt;result column=&quot;username&quot; property=&quot;username&quot;/&gt;
    &lt;result column=&quot;address&quot; property=&quot;address&quot;/&gt;
    &lt;result column=&quot;sex&quot; property=&quot;sex&quot;/&gt;

    &lt;!--订单信息--&gt;
    &lt;!--一个用户对应多个订单--&gt;
    &lt;collection property=&quot;ordersList&quot; ofType=&quot;cn.itcast.po.Orders&quot; &gt;
        &lt;id column=&quot;id&quot; property=&quot;id&quot;/&gt;
        &lt;result column=&quot;user_id&quot; property=&quot;userId&quot;/&gt;
        &lt;result column=&quot;number&quot; property=&quot;number&quot;/&gt;
        &lt;result column=&quot;createtime&quot; property=&quot;createtime&quot;/&gt;
        &lt;result column=&quot;note&quot; property=&quot;note&quot;/&gt;


            &lt;!--订单明细--&gt;
            &lt;!--一个订单对应多个订单明细--&gt;
            &lt;collection property=&quot;orderdetails&quot; ofType=&quot;cn.itcast.po.Orderdetail&quot; &gt;
                &lt;id column=&quot;orderdetail_id&quot; property=&quot;id&quot;/&gt;
                &lt;result column=&quot;orders_id&quot; property=&quot;ordersId&quot;/&gt;
                &lt;result column=&quot;items_id&quot; property=&quot;itemsId&quot;/&gt;
                &lt;result column=&quot;items_num&quot; property=&quot;itemsNum&quot;/&gt;

                    &lt;!--商品信息--&gt;
                    &lt;!--一个订单明细对呀一个商品信息--&gt;
                    &lt;association property=&quot;items&quot; javaType=&quot;cn.itcast.po.Items&quot;&gt;
                        &lt;id  column=&quot;items_id&quot; property=&quot;id&quot;/&gt;
                        &lt;result column=&quot;items_name&quot; property=&quot;name&quot;/&gt;
                        &lt;result column=&quot;items_detail&quot; property=&quot;detail&quot;/&gt;
                        &lt;result column=&quot;items_price&quot; property=&quot;price&quot;/&gt;

                    &lt;/association&gt;

            &lt;/collection&gt;

    &lt;/collection&gt;

&lt;/resultMap&gt;
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">2.3.4 mapper.xml</span><br></pre></td></tr></table></figure>
<pre><code>&lt;select id=&quot;findUserAndItemsResultMap&quot;  resultMap=&quot;findUserAndItemsResultMap&quot;&gt;
    SELECT
   orders.*,
   items.`id` items_id,
   items.`name` items_name,
   items.`detail` items_detail,
   items.`price` items_price,
   orderdetail.`id` orderdetail_id,
   orderdetail.`orders_id`,
   orderdetail.`items_id`,
   orderdetail.`items_num`,
   user.`sex`,
   user.`address`,
   user.`birthday`,
   user.`username`

   FROM
   orders,USER,orderdetail,items
   WHERE orders.`user_id`=user.`id`
    AND orderdetail.`orders_id`=orders.`id`
    AND orderdetail.`items_id`=items.`id`
&lt;/select&gt;
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">2.3.5 mapper.java</span><br></pre></td></tr></table></figure>
<pre><code>//查询用户以及购买的商品信息
public List&lt;User&gt; findUserAndItemsResultMap() throws Exception;
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2.3.6 测试类</span><br></pre></td></tr></table></figure>
<pre><code>List&lt;User&gt; list = ordersMapperCustom.findUserAndItemsResultMap();
</code></pre><p><code>`</code><br>         2.3.7 小结</p>
<pre><code>       * 将查询用户购买的商品信息明细清单，(用户名、用户地址、购买商品名称、购买商品时间、购买商品数量)
       * 针对上边的需求就使用resultType将查询到的记录映射到一个扩展的pojo中，很简单师兄明细清单的功能

3.高级结果集映射（一对一，一对多，多对多）小结
    * 一对多是多对多的特例，如下需求：
        查询用户购买的商品信息，用户和商品的关系是多对多关系。
          需求1：
            查询字段：用户账号、用户名称、用户性别、商品名称、商品价格(最常见)
            企业开发中常见明细列表，用户购买商品明细列表，
            使用resultType将上边查询列映射到pojo输出。

          需求2：
            查询字段：用户账号、用户名称、购买商品数量、商品明细（鼠标移上显示明细）
            使用resultMap将用户购买的商品明细列表映射到user对象中。
    * 对查询结果映射有特殊要求的使用resultMap，比如要求映射成list中包含多个list

4.resultType与resultMap小结
    1. resultType：
        作用：
            将查询结果按照sql列名pojo属性名一致性映射到pojo中。
        场合：
            常见一些明细记录的展示，比如用户购买商品明细，将关联查询信息全部展示在页面时，此时可直接使用resultType将每一条记录映射到pojo中，在前端页面遍历list（list中是pojo）即可。

    2. resultMap：
        使用association和collection完成一对一和一对多高级映射（对结果有特殊的映射要求）。

        1. association：
        作用：
            将关联查询信息映射到一个pojo对象中。
        场合：
            为了方便查询关联信息可以使用association将关联订单信息映射为用户对象的pojo属性中，比如：查询订单及关联用户信息。
            使用resultType无法将查询结果映射到pojo对象的pojo属性中，根据对结果集查询遍历的需要选择使用resultType还是resultMap。

        2. collection：
        作用：
            将关联查询信息映射到一个list集合中。
        场合：
            为了方便查询遍历关联信息可以使用collection将关联信息映射到list集合中，比如：查询用户权限范围模块及模块下的菜单，可使用collection将模块映射到模块list中，将菜单列表映射到模块对象的菜单list属性中，这样的作的目的也是方便对查询结果集进行遍历查询。
            如果使用resultType无法将查询结果映射到list集合中。
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/570911275/570911275.github.io/2019/07/25/JavaEE之MyBatis高级知识之上小结/" data-id="cjyr8j4zi003iw8tnvw05a6ii" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/javaEE-基础/">javaEE_基础</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-JavaEE之MyBatis基础知识之下小结" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/24/JavaEE之MyBatis基础知识之下小结/" class="article-date">
  <time datetime="2019-07-24T09:58:56.000Z" itemprop="datePublished">2019-07-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/24/JavaEE之MyBatis基础知识之下小结/">JavaEE之MyBatis基础知识之下小结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="MyBatis"><a href="#MyBatis" class="headerlink" title="MyBatis"></a>MyBatis</h2><pre><code>1. 基础知识（重点，内容多）
    对原生态jdbc程序（单独使用jdbc开发）问题总结√
    mybatis框架原理（掌握）√
    mybatis入门程序:√
         用户的增删改查√
    mybatis开发两种方法：
         原始dao开发方法（程序需要编写dao接口和dao实现类）（掌握）√
         mybaits的mapper接口（相当于dao接口）代理开发方法（掌握）√
    mybatis配置文件SqlMapConfig.xml√
    mybatis核心：
         mybatis输入映射（掌握）
         mybatis输出映射（掌握）
    mybatis的动态SQL（掌握）

 2. 高级知识
    订单商品数据模型分析
    高级结果集映射（一对一，一对多，多对多）
    mybatis延迟加载
    mybatis查询缓冲（一级缓冲、二级缓冲）
    mybaits和spring进行整合（掌握）
    mybatis逆向工程
</code></pre><h3 id="一、基础知识"><a href="#一、基础知识" class="headerlink" title="一、基础知识"></a>一、基础知识</h3><pre><code>1. 输入映射(*)
     * 通过parameterType指定输入参数的类型，类型可以是简单类型、hashmap、pojo的包装类型
     * 核心：传递pojo的包装对象
           * 当传入查询监听很复杂（可能包括用户信息、其他信息、比如商品、订单）为完成用户信息的综合查询，建议使用自定义的包装类型的pojo。
    1.1 传递pojo包装对象
       1. 定义包装对象：
           * 定义包装对象将查询条件(pojo)以类组合的方式包装起来
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class UserQueryVo &#123;</span><br><span class="line">    //在这里包装所需要的查询条件</span><br><span class="line">    //用户查询条件</span><br><span class="line">    private UserCustom userCustom;</span><br><span class="line"></span><br><span class="line">    public UserCustom getUserCustom() &#123;</span><br><span class="line">        return userCustom;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setUserCustom(UserCustom userCustom) &#123;</span><br><span class="line">        this.userCustom = userCustom;</span><br><span class="line">    &#125;</span><br><span class="line">    //可以包装其他的查询条件，订单，商品</span><br><span class="line">    //....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre><code>2. 定义用户的扩展类：
     * 定义一个扩展类，未来建立多表关联时使用
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public class UserCustom extends User &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre><code>3. UserMapper.xml(映射文件)
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--用户信息的综合查询</span><br><span class="line">     #&#123;userCustom.sex&#125;:取出pojo包装对象中性别值</span><br><span class="line">     $&#123;userCustom.username&#125;:取出pojo包装对象中用户的名称--&gt;</span><br><span class="line">&lt;select id=&quot;findUserList&quot; parameterType=&quot;cn.itcast.po.UserQueryVo&quot;</span><br><span class="line">                          resultType=&quot;cn.itcast.po.UserCustom&quot;&gt;</span><br><span class="line">    select * from user where user.sex= #&#123;userCustom.sex&#125; and user.username like &apos;%$&#123;userCustom.username&#125;%&apos;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure>
<pre><code>4. 测试类
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public void findUserList() throws Exception &#123;</span><br><span class="line">    //mybatis配置文件</span><br><span class="line">    String resource = &quot;SqlMapConfig.xml&quot;;</span><br><span class="line">    //得到配置文件流</span><br><span class="line">    InputStream inputStream = Resources.getResourceAsStream(resource);</span><br><span class="line">    //创建会话工厂,传入mybatis的配置文件信息</span><br><span class="line">    SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);</span><br><span class="line">    SqlSession sqlSession = sqlSessionFactory.openSession();</span><br><span class="line">    //创建UserMapper对象，mybatis自动生成mapper代理对象</span><br><span class="line">    UserMapper userMapper = sqlSession.getMapper(UserMapper.class);</span><br><span class="line">    //创建包装对象，设置查询条件</span><br><span class="line">    UserQueryVo userQueryVo = new UserQueryVo();</span><br><span class="line">    UserCustom userCustom = new UserCustom();</span><br><span class="line">    userCustom.setSex(&quot;1&quot;);</span><br><span class="line">    userCustom.setUsername(&quot;小明&quot;);</span><br><span class="line">    userQueryVo.setUserCustom(userCustom);</span><br><span class="line"></span><br><span class="line">    //调用userMapper的方法</span><br><span class="line">    List&lt;UserCustom&gt; list = userMapper.findUserList(userQueryVo);</span><br><span class="line">    System.out.println(list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre><code>2. 输出映射(*)
  1. resultType：
      使用resultType进行输出映射，只有查询出来的列名和pojo的属性名一致，该列才可以映射成功。
      如果查询出来的列名和pojo中的属性名全部不一致，没有创建pojo对象
      只要查询出来的列名和pojo中的属性有一个不一致，就会创建pojo对象
  2. resultMap：
      mybatis中使用resultMap完成高级输出结果映射
      如果查询出来的列名和pojo的属性名不一致，通过定义一个resultMap对列名和pojo属性名之间作一个映射关系
     2.1 使用步骤：
         1. 定义resultMap
         2. 使用resultMap作为statement的输出映射类型
     2.2 练习需求将下边的SQL使用UserCustom完成映射  
           * select id id_,username username_ from user where id=#{value}
           * user类中属性名和上边查询列名不一致
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">UserMapper.xml</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;!--定义resultMap</span><br><span class="line">        将SELECT id id_,username username_ FROM USER 和 User类中的属性作一个映射关系</span><br><span class="line">        type:resultMap最终映射的java对象类型，可以使用别名</span><br><span class="line">        id：对resultMap的唯一标识</span><br><span class="line">        --&gt;</span><br><span class="line"></span><br><span class="line">    &lt;resultMap type=&quot;user&quot; id=&quot;userResultMap&quot;&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!--id标识查询结果集中唯一标识</span><br><span class="line">            column：查询出来的列名</span><br><span class="line">            property：type指定的pojo类型中的属性名</span><br><span class="line">            最终resultMap对column和property作一个映射关系(对应关系)--&gt;</span><br><span class="line"></span><br><span class="line">        &lt;id column=&quot;id_&quot; property=&quot;id&quot;/&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!--result:对普通名映射定义</span><br><span class="line">            column:查询出来的列名</span><br><span class="line">            property：type指定的pojo类型中的属性名</span><br><span class="line">            最终resultMap对column和property作一个映射关系(对应关系)--&gt;</span><br><span class="line"></span><br><span class="line">        &lt;result column=&quot;username_&quot; property=&quot;username&quot;/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/resultMap&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--使用resultMap进行输出映射</span><br><span class="line">        resultMap:指定定义的resultMap的id，如果这个resultMap在其它的mapper文件，前边需要加namespace</span><br><span class="line">    --&gt;</span><br><span class="line"></span><br><span class="line">    &lt;select id=&quot;findUserByIdResultMap&quot; parameterType=&quot;int&quot; resultMap=&quot;userResultMap&quot;&gt;</span><br><span class="line">        select id id_,username username_ from user where id=#&#123;value&#125;</span><br><span class="line">    &lt;/select&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">测试类</span><br><span class="line"></span><br><span class="line">    public void findUserByIdRsultMap() throws Exception &#123;</span><br><span class="line">        //mybatis配置文件</span><br><span class="line">        String resource = &quot;SqlMapConfig.xml&quot;;</span><br><span class="line">        //得到配置文件流</span><br><span class="line">        InputStream inputStream = Resources.getResourceAsStream(resource);</span><br><span class="line">        //创建会话工厂,传入mybatis的配置文件信息</span><br><span class="line">        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);</span><br><span class="line">        SqlSession sqlSession = sqlSessionFactory.openSession();</span><br><span class="line">        //创建UserMapper对象，mybatis自动生成mapper代理对象</span><br><span class="line">        UserMapper userMapper = sqlSession.getMapper(UserMapper.class);</span><br><span class="line">        //调用userMapper的方法</span><br><span class="line">        User user = userMapper.findUserByIdResultMap(1);</span><br><span class="line">        System.out.println(user);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">UserMapper</span><br><span class="line"></span><br><span class="line">        //6.根据id查询用户信息使用resultMap输出</span><br><span class="line">        public User findUserByIdResultMap(int id) throws Exception;</span><br></pre></td></tr></table></figure>
<pre><code>     2.3 小结：
        * 使用resultType进行输出映射，只有查询出来的列名和pojo中的属性名一致，该列才可以映射成功。
        * 如果查询出来的列名和pojo的属性名不一致，通过定义搞一个resultMap对列名和pojo属性名之间做一个映射关系



3. 动态SQL
   3.1 概念：
       * mybatis核心对SQL语句进行灵活操作，通过表达式进行判断，对SQL进行灵活拼接、组装
   3.2 练习需求：
       * 用户信息综合查询列表和用户信息列表总数这两个statement的定义使用动态SQL 
            * 对查询条件进行判断，如果输入参数不为空，才进行查询条件的拼接
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">原sql:</span><br><span class="line"></span><br><span class="line">&lt;!--    &lt;select id=&quot;findUserList&quot; parameterType=&quot;cn.itcast.po.UserQueryVo&quot;--&gt;</span><br><span class="line">&lt;!--                              resultType=&quot;cn.itcast.po.UserCustom&quot;&gt;--&gt;</span><br><span class="line">&lt;!--        select * from user where user.sex= #&#123;userCustom.sex&#125; and user.username like &apos;%$&#123;userCustom.username&#125;%&apos;--&gt;</span><br><span class="line">&lt;!--    &lt;/select&gt;--&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">动态SQL：</span><br><span class="line"></span><br><span class="line">    &lt;select id=&quot;findUserCount&quot; parameterType=&quot;cn.itcast.po.UserQueryVo&quot;</span><br><span class="line">                               resultType=&quot;int&quot;&gt;</span><br><span class="line">         select count(*) from user</span><br><span class="line">        &lt;where&gt;</span><br><span class="line">            &lt;if test=&quot;userCustom!=null&quot;&gt;</span><br><span class="line">                &lt;if test=&quot;userCustom.sex!=null and userCustom.sex!=&apos;&apos;&quot;&gt;</span><br><span class="line">                    user.sex= #&#123;userCustom.sex&#125;</span><br><span class="line">                &lt;/if&gt;</span><br><span class="line">                &lt;if test=&quot;userCustom.username!=null and userCustom.username!=&apos;&apos;&quot;&gt;</span><br><span class="line">                    and user.username like &apos;%$&#123;userCustom.username&#125;%&apos;</span><br><span class="line">                &lt;/if&gt;</span><br><span class="line">            &lt;/if&gt;</span><br><span class="line">        &lt;/where&gt;</span><br><span class="line">    &lt;/select&gt;</span><br></pre></td></tr></table></figure>
<pre><code>3.3 SQL片段：
    * 练习需求：
         * 将上边实现的SQL判断代码块抽取出来，组成一个SQL片段。其他的statement中就可以引用SQL片段。
         * 方便程序员开发
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">sql片段</span><br><span class="line">    &lt;!--定义SQL片段--&gt;</span><br><span class="line">    &lt;!--id：SQL片段的唯一标识</span><br><span class="line">        使用include标签引用SQL片段的id,如果refid指定的id不在本map文件中，需要在前边加namespace</span><br><span class="line">        经验：是基于单表来定义SQL片段你，这样的话SQL片段的可重用性才高</span><br><span class="line">              在SQL片段中不要包括where--&gt;</span><br><span class="line">    &lt;sql id=&quot;query_user_where&quot;&gt;</span><br><span class="line">        &lt;if test=&quot;userCustom!=null&quot;&gt;</span><br><span class="line">            &lt;if test=&quot;userCustom.sex!=null and userCustom.sex!=&apos;&apos;&quot;&gt;</span><br><span class="line">                user.sex= #&#123;userCustom.sex&#125;</span><br><span class="line">            &lt;/if&gt;</span><br><span class="line">            &lt;if test=&quot;userCustom.username!=null and userCustom.username!=&apos;&apos;&quot;&gt;</span><br><span class="line">                and user.username like &apos;%$&#123;userCustom.username&#125;%&apos;</span><br><span class="line">            &lt;/if&gt;</span><br><span class="line">        &lt;/if&gt;</span><br><span class="line">    &lt;/sql&gt;</span><br><span class="line"></span><br><span class="line">引用</span><br><span class="line">           &lt;where&gt;</span><br><span class="line">                  &lt;include refid=&quot;query_user_where&quot;&gt;&lt;/include&gt;</span><br><span class="line">                  &lt;!--使用include标签引用SQL片段的id,如果refid指定的id不在本map文件中，需要在前边加namespace--&gt;</span><br><span class="line">                  &lt;!--在这里还要引用其他的SQL片段--&gt;</span><br><span class="line">           &lt;/where&gt;</span><br></pre></td></tr></table></figure>
<pre><code>3.4 foreach：
  1. 向SQL传递数组或list，mybatis使用foreach解析
  2. 练习需求
     * 在用户查询列表和查询总数的statement中增加多个id输入查询
     * SQL语句：
         * SELECT * FROM USER WHERE id=1 OR id=10 OR id=16
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">UserMapper.xnl</span><br><span class="line"></span><br><span class="line">    &lt;sql id=&quot;query_user_where&quot;&gt;</span><br><span class="line">        &lt;if test=&quot;userCustom!=null&quot;&gt;</span><br><span class="line">            &lt;if test=&quot;userCustom.sex!=null and userCustom.sex!=&apos;&apos;&quot;&gt;</span><br><span class="line">                user.sex= #&#123;userCustom.sex&#125;</span><br><span class="line">            &lt;/if&gt;</span><br><span class="line">            &lt;if test=&quot;userCustom.username!=null and userCustom.username!=&apos;&apos;&quot;&gt;</span><br><span class="line">                and user.username like &apos;%$&#123;userCustom.username&#125;%&apos;</span><br><span class="line">            &lt;/if&gt;</span><br><span class="line">            &lt;if test=&quot;ids!=null&quot;&gt;</span><br><span class="line">                &lt;!--使用foreach遍历IDS</span><br><span class="line">                    collection：指定输入对象中集合属性</span><br><span class="line">                    item：每个遍历生成对象名</span><br><span class="line">                    open：开始遍历时拼接的字符串</span><br><span class="line">                    close：结束遍历时拼接的字符串</span><br><span class="line">                    separator：遍历两个对象中需要拼接的字符串--&gt;</span><br><span class="line">                &lt;!--使用实现下边的SQL拼接</span><br><span class="line">                    AND (id=1 OR id=10 OR id=16)--&gt;</span><br><span class="line">                &lt;foreach collection=&quot;ids&quot; item=&quot;user_id&quot; open=&quot;AND(&quot; close=&quot;)&quot; separator=&quot;OR&quot;&gt;</span><br><span class="line">                  &lt;!--每次遍历需要拼接的字符串--&gt;</span><br><span class="line">                  id = #&#123;user_id&#125;</span><br><span class="line">                &lt;/foreach&gt;</span><br><span class="line">            &lt;/if&gt;</span><br><span class="line"></span><br><span class="line">        &lt;/if&gt;</span><br><span class="line">    &lt;/sql&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">测试类</span><br><span class="line"></span><br><span class="line">        //传入多个id</span><br><span class="line">        List&lt;Integer&gt; ids = new ArrayList&lt;Integer&gt;();</span><br><span class="line">        ids.add(1);</span><br><span class="line">        ids.add(10);</span><br><span class="line">        ids.add(16);</span><br><span class="line">        userQueryVo.setIds(ids);</span><br><span class="line">        userQueryVo.setUserCustom(userCustom);</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">UserMapper</span><br><span class="line"></span><br><span class="line">    //传入多个id</span><br><span class="line">    private List&lt;Integer&gt; ids;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/570911275/570911275.github.io/2019/07/24/JavaEE之MyBatis基础知识之下小结/" data-id="cjyr8j4wi001kw8tndd3wjw3i" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/javaEE-基础/">javaEE_基础</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-JavaEE之MyBatis基础知识之中小结" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/24/JavaEE之MyBatis基础知识之中小结/" class="article-date">
  <time datetime="2019-07-24T08:38:36.000Z" itemprop="datePublished">2019-07-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/24/JavaEE之MyBatis基础知识之中小结/">JavaEE之MyBatis基础知识之中小结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="MyBatis"><a href="#MyBatis" class="headerlink" title="MyBatis"></a>MyBatis</h2><pre><code>1. 基础知识（重点，内容多）
    对原生态jdbc程序（单独使用jdbc开发）问题总结√
    mybatis框架原理（掌握）√
    mybatis入门程序:√
         用户的增删改查√
    mybatis开发两种方法：
         原始dao开发方法（程序需要编写dao接口和dao实现类）（掌握）
         mybaits的mapper接口（相当于dao接口）代理开发方法（掌握）
    mybatis配置文件SqlMapConfig.xml
    mybatis核心：
         mybatis输入映射（掌握）
         mybatis输出映射（掌握）
    mybatis的动态SQL（掌握）

 2. 高级知识
    订单商品数据模型分析
    高级结果集映射（一对一，一对多，多对多）
    mybatis延迟加载
    mybatis查询缓冲（一级缓冲、二级缓冲）
    mybaits和spring进行整合（掌握）
    mybatis逆向工程
</code></pre><h3 id="一、基础知识"><a href="#一、基础知识" class="headerlink" title="一、基础知识"></a>一、基础知识</h3><pre><code>1. mybatis和hibernate本质区别和应用场景
  1.1：hibernate：是一个标准的ORM框架（对象关系映射）。入门门槛较高的，不需要程序写SQL，SQL语句自动生成了。对SQL语句进行优化、修改比较困难的。
       应用场景：适用于需求变化不多的中小型项目，比如：后台管理系统：erp、orm、oa...
  1.2：mybatis：专注的是SQL本身，需要程序员自己编写SQL语句，SQL修改、优化比较方便。mybatis是一个不完全的orm框架，虽然程序员自己写SQL，mybatis也可以实现映射（输入映射、输出映射）
       应用场景：使用于需求变化较多的项目，比如互联网项目
2. SqlSession的作用范围
  2.1：SqlSessionFactoryBuilder：
         * 通过SqlSessionFactoryBuilder创建会话工厂SqlSessionFactoury
         * 将SqlSessionFactoryBuilder当成一个工具类使用即可，不需要使用单例管理SqlSessionFactoryBuilder
         * 在创建SqlSessionFactory时候，只需要new一此SqlSessionFactoryBuilder即可

  2.2：SqlSessionFactory：
         * 通过SqlSessionFactory创建SqlSessio
         * 使用单例模式guanliSqlSessionFactory（工厂一旦创建，使用一个实例）
         * 将来mybatis和spring整合后，使用单例模式管理SqlSessionFactory

  2.3：SqlSession：
         * SqlSession是一个面向用户（程序员）的接口
         * SqlSession中提供了很多操作数据库的方法：如：selectOne(返回单个对象)、selectList(返回单个或多个对象)
         * SqlSession是线程不安全的，在SqlSession实现类中除了有接口中的方法(操作数据库的方法)，还有数据域属性
         * SqlSession最佳应用场合在方法体内，定义成局部变量使用，这样可以避免内部变量被读写的同时又被修改。

3. 原始Dao开发方法（程序员需要写dao接口和dao实现类
  3.1：思路：
         * 程序员需要写dao接口和dao实现类
         * 需要向dao实现类中注入SqlSessionFacctory，在方法体内通过SqlSessionFactory创建SqlSession

  3.2：dao接口：
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public interface UserDao &#123;</span><br><span class="line">    //1.根据id查询用户信息，得到一条记录结果</span><br><span class="line">    public User findUserById(int id) throws Exception;</span><br><span class="line">    //2.添加用户</span><br><span class="line">    public void insertUser(User user) throws Exception;</span><br><span class="line">    //3.删除用户</span><br><span class="line">    public void deleteUser(int id) throws Exception;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre><code>3.3：dao实现类：
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">//需要向dao实现类中注入SqlSessionFacctory，</span><br><span class="line">// 在方法体内通过SqlSessionFactory创建SqlSession</span><br><span class="line">public class UserDaoImpl implements UserDao &#123;</span><br><span class="line">    private SqlSessionFactory sqlSessionFactory;</span><br><span class="line">    //通过构造函数注入SqlSessionFacctory</span><br><span class="line">    public UserDaoImpl(SqlSessionFactory sqlSessionFactory) throws IOException &#123;</span><br><span class="line">        SqlSession sqlSession = null;</span><br><span class="line">        //mybatis配置文件</span><br><span class="line">        String resource = &quot;SqlMapConfig.xml&quot;;</span><br><span class="line">        //得到配置文件流</span><br><span class="line">        InputStream inputStream = Resources.getResourceAsStream(resource);</span><br><span class="line">        //创建会话工厂,传入mybatis的配置文件信息</span><br><span class="line">        sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);</span><br><span class="line">        this.sqlSessionFactory = sqlSessionFactory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public User findUserById(int id) throws Exception &#123;</span><br><span class="line">        SqlSession sqlSession = sqlSessionFactory.openSession();</span><br><span class="line">        User user = sqlSession.selectOne(&quot;test.findUserById&quot;,1);</span><br><span class="line">        sqlSession.close();</span><br><span class="line">        return user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void insertUser(User user) throws Exception &#123;</span><br><span class="line">        SqlSession sqlSession = sqlSessionFactory.openSession();</span><br><span class="line">        sqlSession.insert(&quot;test.insertUser&quot;,user);</span><br><span class="line">        sqlSession.commit();</span><br><span class="line">        sqlSession.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void deleteUser(int id) throws Exception &#123;</span><br><span class="line">        SqlSession sqlSession = sqlSessionFactory.openSession();</span><br><span class="line">        sqlSession.delete(&quot;test.deleteUser&quot;,id);</span><br><span class="line">        sqlSession.commit();</span><br><span class="line">        sqlSession.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre><code>4. 原始dao开发问题
  4.1：dao接口实现类方法中存在大量模版方法，摄像能否将这些代码提取出来，大大减轻程序员的工作量

  4.2：调用sqlsession方法时将statement的id硬编码了

  4.3：调用sqlsession方法时传入的变量，由于sqlsession方法使用泛型，即使变量类型传入错误，在编译阶段也不报错，不利于程序员开发

5. mapper代理开发方法
  5.1：思路：
       * 程序员需要编写mapper.xml映射文件（如同前者原始的dao开发的user.xml不过多了开发规范）
       * 程序员编写mapper接口(相当于dao接口)需要遵循一些开发规范，mabatis就可以自动生成mapper接口实现类代理对象。

  5.2：开发规范：
       * 在mapper.xml中namespace等于mapper接口地址
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;mapper namespace=&quot;cn.itcast.mapper.UserMapper&quot;&gt;</span><br><span class="line">``` </span><br><span class="line">            * mapper.java接口中的方法名和mapper.xml中的statement的id一致</span><br><span class="line">            * </span><br><span class="line">            * mapper.java接口中的方法输入参数类型和mapper.xml中的parameterType指定的类型一致</span><br><span class="line">            * </span><br><span class="line">            * mapper.java接口中的方法返回值类型和mapper.xml中的statement的resultType指定的类型一致</span><br></pre></td></tr></table></figure>
<p>public User findUserById(int id) throws Exception;</p>
<p><select id="findUserById" parametertype="int" resulttype="cn.itcast.po.User"><br>//1.方法名为findUserById<br>//1.statement的id为findUserById<br>mapper.java接口中的方法名和mapper.xml中的statement的id两者相等</select></p>
<p>//2.输入参数类型为int<br>//2.paramenterType指定的类型为int<br>mapper.java接口中的方法输入参数类型和mapper.xml中的parameterType指定的类型两者相等</p>
<p>//3.返回值类型为User<br>//3.resultType指定的类型为cn.itcast.po.User<br>mapper.java接口中的方法返回值类型和mapper.xml中的statement的resultType指定的类型两者相等<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* 以上的开发规范主要是对下面的代码进行统一生成：</span><br></pre></td></tr></table></figure></p>
<p>sqlSession.insert(“test.updateUser”, user);<br>sqlSession.delete(“deleteUser”,40);<br>sqlSession.update(“test.updateUser”, user);<br>List<user> list = sqlSession.selectList(“test.findUserByName”, “小明”);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5.3：代码实现</span><br></pre></td></tr></table></figure></user></p>
<p>SqlMapConfig.xml：<br>添加语句<br>    <mappers><br>        <mapper resource="User.xml"><br>      <strong><mapper resource="UserMapper.xml"></mapper></strong><br>    </mapper></mappers></p>
<p>userMapper.xml：<br>与User.xml相比，改动地点为：<br>在mapper.xml中namespace等于mapper接口地址</p>
<mapper namespace="cn.itcast.mapper.UserMapper">

<p>UserMapper.java<br>相当于dao中的接口层<br>public interface UserMapper {<br>        //1.根据id查询用户信息，得到一条记录结果<br>        public User findUserById(int id) throws Exception;<br>        //2.添加用户<br>        public void insertUser(User user) throws Exception;<br>        //3.删除用户<br>        public void deleteUser(int id) throws Exception;<br>}</p>
<p>测试类：<br>public class userMapperTest {<br>    @Test<br>    public void findUserById() throws Exception {<br>        //mybatis配置文件<br>        String resource = “SqlMapConfig.xml”;<br>        //得到配置文件流<br>        InputStream inputStream = Resources.getResourceAsStream(resource);<br>        //创建会话工厂,传入mybatis的配置文件信息<br>        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);<br>        SqlSession sqlSession = sqlSessionFactory.openSession();<br>        //创建UserMapper对象，mybatis自动生成mapper代理对象<br>        UserMapper userMapper = sqlSession.getMapper(UserMapper.class);<br>        //调用userMapper的方法<br>        User user = userMapper.findUserById(1);<br>        System.out.println(user);<br>    }</p>
<p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">    5.4：总结</span><br><span class="line">  	 1. selectOne和selectList：</span><br><span class="line">      动态代理对象调用sqlSession.selectOne()和sqlSession.selectList()是根据mapper接口方法的返回值决定，如果返回list则调用selectList方法，如果返回单个对象则调用selectOne方法。</span><br><span class="line"></span><br><span class="line">   2. namespace：</span><br><span class="line">      mybatis官方推荐使用mapper代理方法开发mapper接口，程序员不用编写mapper接口实现类，使用mapper代理方法时，输入参数可以使用pojo包装对象或map对象，保证dao的通用性。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   6. mybatis配置文件SqlMapConfig.xml</span><br><span class="line">       SqlMapConfig.xml中配置的内容和顺序如下：</span><br><span class="line">*properties（属性）</span><br><span class="line">*settings（全局配置参数）</span><br><span class="line">*typeAliases（类型别名）</span><br><span class="line">*typeHandlers（类型处理器）</span><br><span class="line">*objectFactory（对象工厂）</span><br><span class="line">*plugins（插件）</span><br><span class="line">*environments（环境集合属性对象）</span><br><span class="line">*environment（环境子属性对象）</span><br><span class="line">*transactionManager（事务管理）</span><br><span class="line">*dataSource（数据源）</span><br><span class="line">*mappers（映射器）</span><br><span class="line"></span><br><span class="line">     6.1 properties（属性）：</span><br><span class="line">          * 注意： MyBatis 将按照下面的顺序来加载属性：</span><br><span class="line">	 在 properties 元素体内定义的属性首先被读取。 </span><br><span class="line">	 然后会读取properties 元素中resource或 url 加载的属性，它会覆盖已读取的同名属性。 </span><br><span class="line">	 最后读取parameterType传递的属性，它会覆盖已读取的同名属性。</span><br><span class="line"></span><br><span class="line">          * 因此，通过parameterType传递的属性具有最高优先级，</span><br><span class="line">              resource或 url 加载的属性次之，</span><br><span class="line">              最低优先级的是 properties 元素体内定义的属性。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     6.2 settings（全局配置参数）：</span><br><span class="line">          * mybatis框架在运行时可以调整一些运行参数</span><br><span class="line">            比如：开启二级缓存，开启延迟加载。。</span><br><span class="line">          * 全局参数将会影响mybatis的运行行为</span><br><span class="line">          * 详情参考E:\BaiduNetdiskDownload\Mybatis资料\mybatis资料\mybatis\day01\res\mybatis学习资料\mybatis-settings.xlsx</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     6.3 typeAliases（类型别名）(*):</span><br><span class="line">          * mybatis默认的别名</span><br></pre></td></tr></table></figure>
<p>别名    映射的类型<br>_byte     byte<br>_long     long<br>_short     short<br>_int     int<br>_integer     int<br>_double     double<br>_float     float<br>_boolean     boolean<br>string     String<br>byte     Byte<br>long     Long<br>short     Short<br>int     Integer<br>integer     Integer<br>double     Double<br>float     Float<br>boolean     Boolean<br>date     Date<br>decimal     BigDecimal<br>bigdecimal     BigDecimal<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">* 自定义别名</span><br><span class="line">   1. 针对单个别名定义</span><br><span class="line">      type：类型的路径</span><br><span class="line">      alias:别名--&gt;</span><br></pre></td></tr></table></figure></p>
<p><typealias type="cn.itcast.po.User" alias="user"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2. 批量别名定义(常用)</span><br><span class="line">   指定包名，mybatis自动扫描包中的po类</span><br><span class="line">   自动定义别名，别名就是类名（首字母大写或小写都可以）</span><br></pre></td></tr></table></figure></typealias></p>
<p><package name="cn.itcast.po"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">        6.4 typeHandlers（类型处理器）:</span><br><span class="line">类型处理器用于java类型和jdbc类型映射，如下：</span><br></pre></td></tr></table></figure></package></p>
<p><select id="findUserById" parametertype="int" resulttype="user"><br>        select * from user where id = #{id}<br></select><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mybatis自带的类型处理器基本上满足日常需求，不需要单独定义。</span><br><span class="line"></span><br><span class="line">mybatis支持类型处理器：</span><br></pre></td></tr></table></figure></p>
<p>类型处理器                    Java类型                         JDBC类型<br>BooleanTypeHandler             Boolean，boolean         任何兼容的布尔值<br>ByteTypeHandler             Byte，byte                 任何兼容的数字或字节类型<br>ShortTypeHandler             Short，short             任何兼容的数字或短整型<br>IntegerTypeHandler             Integer，int             任何兼容的数字和整型<br>LongTypeHandler             Long，long                 任何兼容的数字或长整型<br>FloatTypeHandler             Float，float             任何兼容的数字或单精度浮点型<br>DoubleTypeHandler             Double，double             任何兼容的数字或双精度浮点型<br>BigDecimalTypeHandler         BigDecimal                 任何兼容的数字或十进制小数类型<br>StringTypeHandler             String                     CHAR和VARCHAR类型<br>ClobTypeHandler             String                     CLOB和LONGVARCHAR类型<br>NStringTypeHandler             String                     NVARCHAR和NCHAR类型<br>NClobTypeHandler             String                     NCLOB类型<br>ByteArrayTypeHandler         byte[]                     任何兼容的字节流类型<br>BlobTypeHandler             byte[]                     BLOB和LONGVARBINARY类型<br>DateTypeHandler             Date（java.util）        TIMESTAMP类型<br>DateOnlyTypeHandler         Date（java.util）        DATE类型<br>TimeOnlyTypeHandler         Date（java.util）        TIME类型<br>SqlTimestampTypeHandler     Timestamp（java.sql）    TIMESTAMP类型<br>SqlDateTypeHandler             Date（java.sql）            DATE类型<br>SqlTimeTypeHandler             Time（java.sql）            TIME类型<br>ObjectTypeHandler             任意                        其他或未指定类型<br>EnumTypeHandler             Enumeration类型            VARCHAR-任何兼容的字符串类型，作为代码存储（而不是索引）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">6.5 mappers（映射器）自动代理</span><br><span class="line">    1.单个加载mapper</span><br><span class="line">     通过mapper接口加载映射文件</span><br><span class="line">     需要将mapper接口类名和mapper.xml映射文件名称保持一致</span><br><span class="line">     且在一个目录中</span><br><span class="line">     上边规范的前提是：使用的是mapper代理的方法</span><br></pre></td></tr></table></figure></p>
<p><mapper class="cn.itcast.mapper.UserMapper"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2.批量加载mapper</span><br><span class="line">  指定mapper接口的报名，mybatis自动扫描包下边所有mapper接口进行加载</span><br><span class="line">  需要将mapper接口类名和mapper.xml映射文件名称保持一致</span><br><span class="line">  且在一个目录中</span><br><span class="line">  上边规范的前提是：使用的是mapper代理的方法</span><br></pre></td></tr></table></figure></mapper></p>
<p><package name="cn.itcast.mapper"><br><code>`</code><br>        6.6 mappers（映射器）自动代理的常用语句<br>6.6.1    <mapper resource=" "><br>使用相对于类路径的资源<br>如：<mapper resource="sqlmap/User.xml"></mapper></mapper></package></p>
<p>6.6.2    <mapper url=" "><br>使用完全限定路径<br>如：<mapper url="file:///D:\workspace_spingmvc\mybatis_01\config\sqlmap\User.xml"></mapper></mapper></p>
<p>6.6.3    <mapper class=" "><br>使用mapper接口类路径<br>如：<mapper class="cn.itcast.mybatis.mapper.UserMapper"></mapper></mapper></p>
<p>注意：此种方法要求mapper接口名称和mapper映射文件名称相同，且放在同一个目录中。</p>
<p>6.6.4    <package name><br>注册指定包下的所有mapper接口<br>如：<package name="cn.itcast.mybatis.mapper"><br>注意：此种方法要求mapper接口名称和mapper映射文件名称相同，且放在同一个目录中。</package></package></p>
</mapper>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/570911275/570911275.github.io/2019/07/24/JavaEE之MyBatis基础知识之中小结/" data-id="cjyr8j4wl001lw8tndjdrj4i6" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/javaEE-基础/">javaEE_基础</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-JavaEE之MyBatis基础知识之上小结" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/24/JavaEE之MyBatis基础知识之上小结/" class="article-date">
  <time datetime="2019-07-24T07:34:16.000Z" itemprop="datePublished">2019-07-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/24/JavaEE之MyBatis基础知识之上小结/">JavaEE之MyBatis基础知识之上小结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="MyBatis"><a href="#MyBatis" class="headerlink" title="MyBatis"></a>MyBatis</h2><pre><code>1. 基础知识（重点，内容多）
    对原生态jdbc程序（单独使用jdbc开发）问题总结
    mybatis框架原理（掌握）
    mybatis入门程序
         用户的增删改查
    mybatis开发两种方法：
         原始dao开发方法（程序需要编写dao接口和dao实现类）（掌握）
         mybaits的mapper接口（相当于dao接口）代理开发方法（掌握）
    mybatis配置文件SqlMapConfig.xml
    mybatis核心：
         mybatis输入映射（掌握）
         mybatis输出映射（掌握）
    mybatis的动态SQL（掌握）

 2. 高级知识
    订单商品数据模型分析
    高级结果集映射（一对一，一对多，多对多）
    mybatis延迟加载
    mybatis查询缓冲（一级缓冲、二级缓冲）
    mybaits和spring进行整合（掌握）
    mybatis逆向工程
</code></pre><h3 id="一、基础知识"><a href="#一、基础知识" class="headerlink" title="一、基础知识"></a>一、基础知识</h3><h4 id="1-对原生jdbc程序问题总结"><a href="#1-对原生jdbc程序问题总结" class="headerlink" title="1. 对原生jdbc程序问题总结"></a>1. 对原生jdbc程序问题总结</h4><pre><code>1.1 环境搭建：
     * java环境：jdk
     * 数据库环境：mysql
     * 集成开发环境：idea

1.2 创建mysql数据库
     * sql_data.sql：记录表结构
     * sql_table.sql：记录测试数据，在实际企业开发中，最后提供一个初始化数据脚本

1.3 jdbc程序
     * 使用jdbc程序查询mysql数据库中用户表的记录
         * 创建java工程
         * 导入jar包（数据库驱动包）
         * 编写java程序代码

1.4 问题总结
     1. 数据库连接使用时就创建，不使用立即释放，对数据库进行频繁连接开启和关闭，造成数据库资源浪费影响数据库性能
         * 解决方案：
             * 使用数据库连接池管理数据库连接

     2. 将SQL语句硬编码（SQL语句在java代码中写死）到java中，如果SQL语句修改，需要重新编译java代码，不利于系统维护
         * 解决方案：
              * 将SQL语句配置在xml配置文件中，即使SQL变化，不需要对java代码进行重新编译

     3. 向preparedStatement中设置参数，对占位符位置和设置参数值，硬编码在java代码中，不利于系统维护
         * 解决方案：
              * 将SQL语句以及占位符合和参数全部配置在xml文件中

     4. 从resutSet中遍历结果集数据时，存在硬编码，将获取表的字段进行硬编码，不利于系统卫华
         * 解决方案：
              * 将查询的结果集，自动映射成java对象   
</code></pre><h4 id="2-mybatis框架"><a href="#2-mybatis框架" class="headerlink" title="2.mybatis框架"></a>2.mybatis框架</h4><pre><code>2.1 mybatis是什么
     * mybatis是一个持久层的框架，是Apache下的顶级项目
     * mybatis托管到goolecode下，再后来托管到github下
     * mybatis让程序员将主要精力放在SQL上，通过mybatis提供的映射方式，自由灵活生成（半自动化，大部分需要程序员编写SQL）满足SQL语句
     * mybatis可以将向preparedStatement中的输入参数自动输入映射，将查询结果集灵活映射出java对象（输出映射）

2.2 mybatis框架
        —————————————————————————————————————————————————————————————————           
        | * SqlMapConfig.xml(是mybatis的全局配置文件，名称不固定的)         
        | * 配置了数据源、事务等mybatis运行环境                             
        | * 配置映射文件（配置SQL语句）                                     
        |      * 配置在mapper.xml(映射文件)、mapper.xml\mapper.xml....中    
        |                                                                 
        ——————————————————————————————————————————————————————————————————
                                 ||
                                 ||
                                 \/
       ————————————————————————————————————————————————————————————————————
       |  * SqlSessionFactory(会话工厂)【根据配置文件创建工程】
       |     * 作用：创建SqlSession
       —————————————————————————————————————————————————————————————————————
                                 ||
                                 ||
                                 \/
      ————————————————————————————————————————————————————————————————————————
     |   * SqlSession（会话）【面向用户（程序员）的接口】
     |     * 作用：操作数据库（发出SQL增、删、改、查）
      _________________________________________________________________________
                                 ||
                                 ||
                                 \/
      —————————————————————————————————————————————————————————————————————————— 
     |   * Executor(执行器)【是一个接口(基本执行器，缓冲执行器)】
     |      * 作用：SqlSession内部通过执行器操作数据库
      ———————————————————————————————————————————————————————————————————————————   
                                 ||
                                 ||
                                 \/
      ————————————                                                            ——————————
     *|  输入参数  |                                                          |  输出结果
     *|  类型      |    ————————————————————————————————————————————————      |  类型
      |            |   |  * mapped ststement(底层封装对象)               |     |
     *|  java简单  |——&gt; |         * 作用：对操作数据库存储封装，包括SQL语句 |——&gt;  | java简单
     *|  类型      |    |             **输入参数、输出结果类型**          |     | 类型 
     *|  hashmap   |    ————————————————————————————————————————————————     |  hashmap 
      |            |                 ||                                      |
     *|  pojo自定义 |                 ||                                     | polo自定义 
      —————————————                 \  /                                       ——————————————
                                 ——————————————        
     *                          | mysql数据库 
     *                          ————————————————
</code></pre><h4 id="3-入门程序"><a href="#3-入门程序" class="headerlink" title="3.入门程序"></a>3.入门程序</h4><h5 id="3-1-需求"><a href="#3-1-需求" class="headerlink" title="3.1 需求"></a>3.1 需求</h5><pre><code>* 根据用户id（主键）查询用户信息
* 根据用户名称模糊查询用户信息
* 添加用户
* 删除用户
* 更新用户
</code></pre><h5 id="3-2-环境"><a href="#3-2-环境" class="headerlink" title="3.2 环境"></a>3.2 环境</h5><pre><code>* java环境：jdk
* 数据库环境：mysql
* 集成开发环境：idea
* mybatis运行环境：jar包
</code></pre><h5 id="3-3-根据用户id查询用户信息"><a href="#3-3-根据用户id查询用户信息" class="headerlink" title="3.3 根据用户id查询用户信息"></a>3.3 根据用户id查询用户信息</h5><pre><code>1. 映射文件命名：
    Userxml（原始ibatis命名），mapper代理开发映射文件名称叫xxxMapper.xml，比如：UserMapper.xml
2. 在映射文件中配置SQL语句
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">**测试类**</span><br><span class="line"></span><br><span class="line">package cn.itcast.first;</span><br><span class="line"></span><br><span class="line">import cn.itcast.po.User;</span><br><span class="line">import org.apache.ibatis.io.Resources;</span><br><span class="line">import org.apache.ibatis.session.*;</span><br><span class="line">import org.junit.Test;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.InputStream;</span><br><span class="line"></span><br><span class="line">public class myBatisFirst &#123;</span><br><span class="line">    //1.根据id查询用户信息，得到一条记录结果</span><br><span class="line">    @Test</span><br><span class="line">    public void findUserByIdTest()  &#123;</span><br><span class="line">        User user = null;</span><br><span class="line">        SqlSession sqlSession = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            //mybatis配置文件</span><br><span class="line">            String resource = &quot;SqlMapConfig.xml&quot;;</span><br><span class="line">            //得到配置文件流</span><br><span class="line">            InputStream inputStream = Resources.getResourceAsStream(resource);</span><br><span class="line">            //创建会话工厂,传入mybatis的配置文件信息</span><br><span class="line">            SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);</span><br><span class="line">            //通过工厂得到SqlSession</span><br><span class="line">            sqlSession = sqlSessionFactory.openSession();</span><br><span class="line">            //通过SqlSession操作数据库</span><br><span class="line">            //第一个参数：映射文件中Statement的id,等于namespace+&quot;.&quot;+statement的id</span><br><span class="line">            //第二个参数：指定和映射文件中所匹配的paramenterType类型的参数</span><br><span class="line">            //sqlSession.selectOne结果是于映射文件中所匹配的resultType类型的对象</span><br><span class="line">            user = sqlSession.selectOne(&quot;test.findUserById&quot;,1);</span><br><span class="line">            System.out.println(user);</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">**SqlMapConfig.xml**</span><br><span class="line"></span><br><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;!DOCTYPE configuration</span><br><span class="line">        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span><br><span class="line">        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;</span><br><span class="line">&lt;configuration&gt;</span><br><span class="line">    &lt;!-- 和spring整合后 environments配置将废除--&gt;</span><br><span class="line">    &lt;environments default=&quot;development&quot;&gt;</span><br><span class="line">        &lt;environment id=&quot;development&quot;&gt;</span><br><span class="line">            &lt;!-- 使用jdbc事务管理，事务控制有mybatis控制--&gt;</span><br><span class="line">            &lt;transactionManager type=&quot;JDBC&quot; /&gt;</span><br><span class="line">            &lt;!-- 数据库连接池--&gt;</span><br><span class="line">            &lt;dataSource type=&quot;POOLED&quot;&gt;</span><br><span class="line">                &lt;property name=&quot;driver&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot; /&gt;</span><br><span class="line">                &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis?serverTimezone=UTC&quot; /&gt;</span><br><span class="line">                &lt;property name=&quot;username&quot; value=&quot;root&quot; /&gt;</span><br><span class="line">                &lt;property name=&quot;password&quot; value=&quot;a570911275&quot; /&gt;</span><br><span class="line">            &lt;/dataSource&gt;</span><br><span class="line">        &lt;/environment&gt;</span><br><span class="line">    &lt;/environments&gt;</span><br><span class="line">    &lt;!--加载映射文件--&gt;</span><br><span class="line">    &lt;mappers&gt;</span><br><span class="line">        &lt;mapper resource=&quot;User.xml&quot;/&gt;</span><br><span class="line">    &lt;/mappers&gt;</span><br><span class="line"></span><br><span class="line">&lt;/configuration&gt;</span><br><span class="line"></span><br><span class="line">**User.xml(映射文件)**</span><br><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;!DOCTYPE mapper</span><br><span class="line">        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span><br><span class="line">        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;</span><br><span class="line">&lt;!--namespce命名空间，作用就是对SQL进行分类化管理，SQL隔离--&gt;</span><br><span class="line">&lt;!--使用mapper代理开发，namespace有特殊的重要作用--&gt;</span><br><span class="line">&lt;mapper namespace=&quot;test&quot;&gt;</span><br><span class="line">    &lt;!--在映射文件中配置SQL语句--&gt;</span><br><span class="line">    &lt;!--通过select执行数据库查询--&gt;</span><br><span class="line">    &lt;!--id标识映射文件中的SQL，称为statement中的id--&gt;</span><br><span class="line">    &lt;!--将SQL语句封装到mappedStatement对象中--&gt;</span><br><span class="line">    &lt;!--#&#123;&#125;表示一个占位符--&gt;</span><br><span class="line">    &lt;!--parameterType指定输入参数的类型--&gt;</span><br><span class="line">    &lt;!--#&#123;id&#125;其中的id表示接受输入的参数，参数名称就是id，</span><br><span class="line">    如果输入参数是简单类型，#&#123;&#125;中的参数名可以任意--&gt;</span><br><span class="line">    &lt;!--resultType指定输出结果所映射的java对象类型，</span><br><span class="line">    select指定resultType表示将单条记录映射成java对象--&gt;</span><br><span class="line">    &lt;select id=&quot;findUserById&quot; parameterType=&quot;int&quot; resultType=&quot;cn.itcast.po.User&quot;&gt;</span><br><span class="line">         SELECT * FROM USER WHERE id=#&#123;id&#125;</span><br><span class="line">    &lt;/select&gt;</span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure>
<h5 id="3-4-根据用户名称模糊查询用户信息"><a href="#3-4-根据用户名称模糊查询用户信息" class="headerlink" title="3.4 根据用户名称模糊查询用户信息"></a>3.4 根据用户名称模糊查询用户信息</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">**测试类**</span><br><span class="line"></span><br><span class="line">前面创建会话过程同3.2一样</span><br><span class="line">//通过SqlSession操作数据库</span><br><span class="line">//第一个参数：映射文件中Statement的id,等于namespace+&quot;.&quot;+statement的id</span><br><span class="line">//第二个参数：指定和映射文件中所匹配的paramenterType类型的参数</span><br><span class="line">//sqlSession.selectOne结果是于映射文件中所匹配的resultType类型的对象</span><br><span class="line">List&lt;User&gt; list = sqlSession.selectList(&quot;test.findUserByName&quot;, &quot;小明&quot;);</span><br><span class="line">System.out.println(list);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">**User.xml(映射文件)**</span><br><span class="line">    &lt;!--根据用户名称模糊查询用户信息,可能返回多条</span><br><span class="line">        resultType：指定就是单条记录所映射的java对象类型</span><br><span class="line">        $&#123;&#125;：表示拼接SQL串，将接收到的参数内容不加任何修饰拼接在SQL中</span><br><span class="line">        使用$&#123;&#125;拼接SQL，引起SQL注入</span><br><span class="line">        $&#123;value&#125;：接收输入参数的内容，如果传入类型是简单类型的，$&#123;&#125;中只能使用value--&gt;</span><br><span class="line">    &lt;select id=&quot;findUserByName&quot; parameterType=&quot;java.lang.String&quot; resultType=&quot;cn.itcast.po.User&quot;&gt;</span><br><span class="line">        SELECT * FROM USER WHERE USERNAME LIKE &apos;%$&#123;value&#125;%&apos;</span><br><span class="line">    &lt;/select&gt;</span><br></pre></td></tr></table></figure>
<h5 id="3-5-添加用户"><a href="#3-5-添加用户" class="headerlink" title="3.5 添加用户"></a>3.5 添加用户</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">**测试类**</span><br><span class="line"></span><br><span class="line">            //创建User对象</span><br><span class="line">            User user = new User();</span><br><span class="line">            user.setUsername(&quot;黄二丫&quot;);</span><br><span class="line">            user.setBirthday(new Date());</span><br><span class="line">            user.setSex(&quot;1&quot;);</span><br><span class="line">            user.setAddress(&quot;广东陆丰&quot;);</span><br><span class="line">            sqlSession.insert(&quot;test.insertUser&quot;, user);</span><br><span class="line">            //提交事务</span><br><span class="line">            sqlSession.commit();</span><br><span class="line">            //获取用户信息主键</span><br><span class="line">            System.out.println(user.getId());</span><br><span class="line">            //关闭会话</span><br><span class="line">            sqlSession.close();</span><br><span class="line"></span><br><span class="line">**User.xml(映射文件)**</span><br><span class="line">    &lt;insert id=&quot;insertUser&quot; parameterType=&quot;cn.itcast.po.User&quot; &gt;</span><br><span class="line">        &lt;!--</span><br><span class="line">        将插入数据的主键返回，返回到user对象中</span><br><span class="line">        SELECT LAST_INSERT_ID():得到刚insert进去记录的主键值，只适用于自增主键</span><br><span class="line">        keyProperty：将查询到主键值设置到parameterType指定的对象的哪一个属性</span><br><span class="line">        order：SELECT LAST_INSERT_ID()执行顺序，相对于insert语句来说它的执行顺序</span><br><span class="line">        resultType：指定SELECT LAST_INSERT_ID()的结果类型</span><br><span class="line">        --&gt;</span><br><span class="line">        &lt;selectKey keyProperty=&quot;id&quot; order=&quot;AFTER&quot; resultType=&quot;java.lang.Integer&quot;&gt;</span><br><span class="line">            SELECT LAST_INSERT_ID()</span><br><span class="line">        &lt;/selectKey&gt;</span><br><span class="line">        insert into user(username,birthday,sex,address) values(#&#123;username&#125;,#&#123;birthday&#125;,#&#123;sex&#125;,#&#123;address&#125;)</span><br><span class="line">        &lt;!--</span><br><span class="line">        使用mysql的uuid()进行主键的返回（非自增主键）</span><br><span class="line">        执行思路：</span><br><span class="line">        先通过uuid()查询到主键，将主键设置到user对象中的id属性</span><br><span class="line">        在insert执行时，从user对象中取出id属性值</span><br><span class="line">        执行uuid()顺序相对于insert语句之前--&gt;</span><br><span class="line">        &lt;selectKey keyProperty=&quot;id&quot; order=&quot;AFTER&quot; resultType=&quot;java.lang.Integer&quot;&gt;</span><br><span class="line">            SELECT uuid()</span><br><span class="line">        &lt;/selectKey&gt;</span><br><span class="line">        insert into user(id,username,birthday,sex,address) values(#&#123;id&#125;,#&#123;username&#125;,#&#123;birthday&#125;,#&#123;sex&#125;,#&#123;address&#125;)</span><br><span class="line">    &lt;/insert&gt;</span><br></pre></td></tr></table></figure>
<h5 id="3-6-添加用户-返回主键"><a href="#3-6-添加用户-返回主键" class="headerlink" title="3.6 添加用户__返回主键"></a>3.6 添加用户__返回主键</h5><p>1.返回自增主键：<br>        将插入数据的主键返回，返回到user对象中<br>        SELECT LAST_INSERT_ID():得到刚insert进去记录的主键值，只适用于自增主键<br>        keyProperty：将查询到主键值设置到parameterType指定的对象的哪一个属性<br>        order：SELECT LAST_INSERT_ID()执行顺序，相对于insert语句来说它的执行顺序<br>        resultType：指定SELECT LAST_INSERT_ID()的结果类型<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">        &lt;selectKey keyProperty=&quot;id&quot; order=&quot;AFTER&quot; resultType=&quot;java.lang.Integer&quot;&gt;</span><br><span class="line">            SELECT LAST_INSERT_ID()</span><br><span class="line">        &lt;/selectKey&gt;</span><br><span class="line">``` </span><br><span class="line">2.返回非自增主键</span><br><span class="line">        使用mysql的uuid()进行主键的返回（非自增主键）</span><br><span class="line">        执行思路：</span><br><span class="line">        先通过uuid()查询到主键，将主键设置到user对象中的id属性</span><br><span class="line">        在insert执行时，从user对象中取出id属性值</span><br><span class="line">        执行uuid()顺序相对于insert语句之前</span><br></pre></td></tr></table></figure></p>
<pre><code>&lt;selectKey keyProperty=&quot;id&quot; order=&quot;AFTER&quot; resultType=&quot;java.lang.Integer&quot;&gt;
    SELECT uuid()
&lt;/selectKey&gt;
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">#####      3.7 删除用户</span><br></pre></td></tr></table></figure>
<p><strong>测试类</strong></p>
<pre><code>sqlSession.delete(&quot;deleteUser&quot;,40);
sqlSession.commit();
</code></pre><p><strong>User.xml(映射文件)</strong></p>
<pre><code>&lt;!--删除用户
    根据用户id删除用户--&gt;
&lt;delete id=&quot;deleteUser&quot; parameterType=&quot;java.lang.Integer&quot;&gt;
    delete from user where id = #{id}
&lt;/delete&gt;
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">#####      3.8 更新用户</span><br></pre></td></tr></table></figure>
<p><strong>测试类</strong></p>
<pre><code>User user = new User();
user.setId(41);
user.setUsername(&quot;黄三丫&quot;);
user.setBirthday(new Date());
user.setSex(&quot;1&quot;);
user.setAddress(&quot;广东陆丰&quot;);
sqlSession.insert(&quot;test.updateUser&quot;, user);
//提交事务
sqlSession.commit();
//获取用户信息主键
System.out.println(user.getId());
//关闭会话
sqlSession.close();
</code></pre><p><strong>User.xml</strong></p>
<pre><code>&lt;update id=&quot;updateUser&quot; parameterType=&quot;cn.itcast.po.User&quot;&gt;
    update user set username=#{username},birthday=#{birthday},sex=#{sex},address=#{address} where id=#{id}
&lt;/update&gt;
</code></pre><p><code>`</code></p>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><pre><code>1. parameterType：指定输入参数的类型
2. resultType   ：指定输出结果所映射的java对象类型
3. 如果输入参数是简单类型，#{}中的参数名可以任意
4. 如果传入类型是简单类型的，${}中只能使用value
5. 除了select查询语句之外，其他add，delete，update等增、删、改等语句皆需要提交
6. ${}：表示拼接SQL串，将接收到的参数内容不加任何修饰拼接在SQL中；使用${}拼接SQL，引起SQL注入
        ${}接收输入参数类型可以是简单类型、pojo、hashmap
        如果接收简单类型，${}中只能写成value
        ${}接收pojo对象值，通过OGNL读取对象中的属性值，通过属性.属性.属性...的方式获取对象属性值。
7. #{}：表示一个占位符，#{}接收输入参数类型可以是简单类型、pojo、hashmap
        如果接收简单类型，${}中可以写成value或其他名称
        ${}接收pojo对象值，通过OGNL读取对象中的属性值，通过属性.属性.属性...的方式获取对象属性值。                
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/570911275/570911275.github.io/2019/07/24/JavaEE之MyBatis基础知识之上小结/" data-id="cjyr8j4zf003gw8tnumksqbhq" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/javaEE-基础/">javaEE_基础</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/2/">下一页 &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/javaEE-基础/">javaEE_基础</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java-基础/">java_基础</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/javaEE-基础/" style="font-size: 20px;">javaEE_基础</a> <a href="/tags/java-基础/" style="font-size: 10px;">java_基础</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">七月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">六月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">五月 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/07/31/新文档8888/">(no title)</a>
          </li>
        
          <li>
            <a href="/2019/07/31/JavaEE之Spring快速入门之下小结/">(no title)</a>
          </li>
        
          <li>
            <a href="/2019/07/26/JavaEE之Spring快速入门之中小结/">JavaEE之Spring快速入门之中小结</a>
          </li>
        
          <li>
            <a href="/2019/07/26/JavaEE之Spring快速入门之上小结/">JavaEE之Spring快速入门之上小结</a>
          </li>
        
          <li>
            <a href="/2019/07/25/JavaEE之MyBatis高级知识之下小结/">JavaEE之MyBatis高级知识之下小结</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>
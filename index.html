<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="https://github.com/570911275/570911275.github.io/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://github.com/570911275/570911275.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-JavaEE之JSP入门学习小结" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/18/JavaEE之JSP入门学习小结/" class="article-date">
  <time datetime="2019-07-18T08:35:43.000Z" itemprop="datePublished">2019-07-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/18/JavaEE之JSP入门学习小结/">JavaEE之JSP入门学习小结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="JSP入门学习"><a href="#JSP入门学习" class="headerlink" title="JSP入门学习"></a>JSP入门学习</h2><pre><code>1. 概念：
   *Java Server Pages: java服务器端页面
     *可以理解为一个特殊的页面，其中既可以定义HTML标签，又可以定义java代码
     *用于简化书写！！！

 2. 原理：
    *JSP本质上就是一个Servlet

 3. JSP的的脚本：
       *JSP定义java代码的方式
       1.&lt;% 代码 %&gt;：定义的java代码，在service方法中。Service方法中可以定义什么，该脚本中就可以定义什么
       2.&lt;%! 代码 %&gt;： 定义的java代码，在jsp转换后的java类的成员位置。用的较少，尽量不要尽量成员变量，不然容易尝试线程错误
       3.&lt;&lt;%= 代码 %&gt;&gt;：定义的java代码，会输出到页面上，输出语句中可以定义什么，该脚本中就可以定义什么

 4. JSP的内置对象：
      *在JSP页面中不需要获取和创建，就可以直接使用的对象
      *在JSP中一共有9个内置对象
      *3个基本内置对象：
           *request：请求
           *response：响应
           *out：字符输出流对象。可以将数据输出到页面上。与response,getWriter()类似
               *response.getWriter()和out.write()的区别：
                  1.在Tomcat服务器真正给客户端做出响应之前，会先找response缓冲区数据，再找out缓冲区数据
                  2.response.getWriter（）数据永远在out.Write()之前
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/570911275/570911275.github.io/2019/07/18/JavaEE之JSP入门学习小结/" data-id="cjycpjxak000ehwtnmmts3bnl" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/javaEE-基础/">javaEE_基础</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-JavaEE之Cookie小结" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/18/JavaEE之Cookie小结/" class="article-date">
  <time datetime="2019-07-18T07:22:03.000Z" itemprop="datePublished">2019-07-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/18/JavaEE之Cookie小结/">JavaEE之Cookie小结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><pre><code>1.概念：客户端会话技术，将数据保存到客户端

2.快速入门：
    *使用步骤：
       1.创建Cookie对象，绑定数据
            *new Cookie(String name,String value)
       2.发送Cookie对象
            *response,addCookie(Cookie cookie)
       3.获取Cookie，拿到数据
            *Cookie[] request.getCookies()\

3.实现原理：
    *基于响应头set-cookie和请求头cookie实现

4.Cookie的细节：
     1.一次可不可以发送多个Cookie？
         *可以
         *可以创建多个Cookie对象，使用response调用多次addCookie方法发送Cookie即可。

     2.Cookie在浏览器中保存多长时间？
         1.默认情况下：当浏览器关闭后，Cookie数据被销毁
         2.持久化存储：
                *setMaxAge(int seconds)
                   1.正数：将Cookie数据写到硬盘的文件中。持久化存储。cookie存活时间
                   2.负数：默认值
                   3.零：删除Cookie信息

     3.Cookie能不能存中文？
          *在Tomcat8 之前 cookie中不能直接存储中文数据。
                 *需要将中文数据转码 ----一般采用URL编码(%)
          *在Tomcat8 之后 cookie支持中文数据。

     4.Cookie共享问题？
         1.*假设在一个Tomcat服务器中，部署了多个web项目，那么在这些web项目中cookie能不能共享？
              *默认情况下cookie不能共享

              *setPath（String path）:设置cookie的获取范围。默认情况下，设置当前的虚拟目录
              *如果要共享，则可以将path设置为“/” ；setPath（/）此情况下，可使得不同项目之间相互共享 

         2.不同的Tomcat服务器间cookie共享问题？
               *调用setDomain(String path//字符串的一个域名)：如果设置一级域名相同，那么多个服务器之间可以共享
                    *setDomain（“.baidu.com）；
                        那么tieba.baidu.com和news.baidu.com之间可以共享

 5. Cookie的特点和作用：
      1. cookie存储数据在客户端浏览器
              *存储在客户端的数据，相较不安全，易被串改获取

      2. 浏览器对于单个cookie的大小有限制（4k）以及对同一个域名下的总Cookie数量有所限制(一般在20个以内) 

      *作用：
          1.cookie一般用于存储少量的不太敏感的数据
          2.在不登录的情况下，完成服务器对客户端的身份识别
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/570911275/570911275.github.io/2019/07/18/JavaEE之Cookie小结/" data-id="cjycpjx9r0005hwtnf6zymbtw" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/javaEE-基础/">javaEE_基础</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-JavaEE之会话技术概念小结" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/18/JavaEE之会话技术概念小结/" class="article-date">
  <time datetime="2019-07-18T05:41:56.000Z" itemprop="datePublished">2019-07-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/18/JavaEE之会话技术概念小结/">JavaEE之会话技术概念小结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="会话技术："><a href="#会话技术：" class="headerlink" title="会话技术："></a>会话技术：</h2><pre><code>1. 会话：一次会话中包含多次请求和响应。
   *一次会话：浏览器第一次给服务器资源发送请求，会话建立，直到有一方断开为止。

2. 功能：在一次会话的范围内的多次请求间，共享数据

3. 方式：
     1.客户端会话技术:Cookie
          *将数据存在客户端
     2.服务器端会话技术：Session
          *将数据存在服务器端
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/570911275/570911275.github.io/2019/07/18/JavaEE之会话技术概念小结/" data-id="cjycpjxc7000whwtnowue5fiu" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/javaEE-基础/">javaEE_基础</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-JavaEE之ServletContext小结" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/18/JavaEE之ServletContext小结/" class="article-date">
  <time datetime="2019-07-18T03:38:26.000Z" itemprop="datePublished">2019-07-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/18/JavaEE之ServletContext小结/">JavaEE之ServletContext小结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="ServletContext对象"><a href="#ServletContext对象" class="headerlink" title="ServletContext对象"></a>ServletContext对象</h2><pre><code>1.概念：代表整个web应用，可以和程序的容器（服务器）来通信
2.获取：
    1.通过request对象获取
       request.getServletContext();
    2.通过HttpServlet获取
       this.getServletContext();
3.功能：
    1.获取MIME类型：
       *MIME类型：在互联网通信过程中定义的一种文件数据类型
          *格式：大类型/小类型 text/html  image/jpeg

    2.域对象：共享数据
        1.setAttribute(String name,Object value)
        2.getAttribute(String name)
        3.removeAttribute(String name)

        *ServletContex对象范围：所有用户请求的数据

    3.获取文件的真实(服务器)路径
        1.方法：String getRealPath(String path)
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//获取文件的真实路径</span><br><span class="line">String realPath = context.getRealPath(&quot;/WEB-INF/classes/b.text&quot;);//src目录下资源访问</span><br><span class="line">System.out.println(realPath);</span><br><span class="line">File file  = new File(realPath);</span><br><span class="line"></span><br><span class="line">//获取文件的真实路径</span><br><span class="line">String realPath2 = context.getRealPath(&quot;/WEB-INF/c.text&quot;);//WEB-INF目录下资源访问</span><br><span class="line">System.out.println(realPath2);</span><br><span class="line">File file2  = new File(realPath2);</span><br><span class="line"></span><br><span class="line">//获取文件的真实路径</span><br><span class="line">String realPath3 = context.getRealPath(&quot;a.text&quot;);//web目录下资源访问</span><br><span class="line">System.out.println(realPath3);</span><br><span class="line">File file3  = new File(realPath3);</span><br></pre></td></tr></table></figure>
<h2 id="案例："><a href="#案例：" class="headerlink" title="案例："></a>案例：</h2><pre><code>*文件下载需求：
   1.页面显示超链接
   2.点击超链接后弹出下载提示框
   3.完成图片文件下载

 *分析：
    1.超链接指向的资源如果能够被浏览器解析，则在浏览器中展示，如果不能解析，则弹出下载提示框。（不满足需求）
    2.任何资源的必须弹出下载提示框
    3.使用响应头设置资源的打开方式：
          *content-disposition:attachment;filename=xxx

  *步骤：
     1.定义页面，编辑超链接herf属性，指向Servlet，传递资源名称filename
     2.定义Servlet
         1.获取文件名称
         2.使用字节输入流加载文件进内存
         3.指定response的响应头：content-disposition:attachment;filename=xxx
         4.将数据写出到response输出流

  *问题：
    *中文文件问题：
        *解决思路：
            1.获取客户端使用的浏览器版本信息
            2.根据不同的版本信息，设置filename的编码方式不同
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/570911275/570911275.github.io/2019/07/18/JavaEE之ServletContext小结/" data-id="cjycpjxbg000mhwtn115hy1e7" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/javaEE-基础/">javaEE_基础</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-JavaEE之Response小结" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/17/JavaEE之Response小结/" class="article-date">
  <time datetime="2019-07-17T13:57:05.000Z" itemprop="datePublished">2019-07-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/17/JavaEE之Response小结/">JavaEE之Response小结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Response对象"><a href="#Response对象" class="headerlink" title="Response对象"></a>Response对象</h2><pre><code>*功能：设置响应消息
   1.设置响应行
       1.格式：HTTP、1.1 200 ok
       2.设置状态码：setStatus(int sc)

   2.设置响应头:setHeader(String name,String value)

   3.设置响应体:
       *使用步骤：
           1.获取输出流
                *字符输出流：PrintWriter getWriter()
                *字节输出流：ServletOutputStream getOutputStream()
           2.使用输出流将数据输出到客户端浏览器

*案例：
   1.完成重定向
      *重定向：资源跳转的方式

      *代码实现：
        //访问这个资源，会自动跳转到、responseDemo02资源
        //1.设置状态码为302
        response.setStatus(302);
        //设置响应头location
        response.setHeader(&quot;location&quot;,&quot;/day15/responseDemo02&quot;);

        //简单的重定向方法
        response.sendRedirect(&quot;/day15/responseDemo02&quot;);

       *重定向的特点：redirect
            1.地址栏路径发生变化
            2.重定向可以访问其他站点(服务器)下的资源
            3.重定向是两次请求，不能使用request对象来共享数据
       *转发的特点(转发也是资源跳转的方式)：forward
            1.转发地址栏路径不变
            2.转发只能访问当前服务器下的资源
            3.转发是一次请求，可以使用request对象来共享数据

       *forward和redirect的区别

       *路径写法：
           1.路径分类：
                1.相对路径：通过相对路径不可以确定唯一资源(jsp中不推荐使用)
                     *如：./index.html
                     *不以/开头，以.开头路径
                     *规则：确定当前资源和目标资源直接的相对位置关系
                        *./：当前目录
                        *../:后退一级目录

                2.绝对路径：通过绝对路径可以确定唯一资源  
                     *如：http://localhost:8080/day15/responseDemo02      简化：/day15/responseDemo02
                     *以/开头的路径
                     *规则：判断定义的路径是给谁用的？判断请求从哪儿发出
                        *给客户端浏览器使用：需要加虚拟目录（项目的访问路径）
                         (重定向是客户端使用，需要加虚拟目录)(建议动态获取)
                        *给服务器使用：不需要加虚拟目录
                        （转发是给服务器使用，可以不加虚拟目录）
                     *动态获取虚拟目录:
                         String contextPath = request.getContextPath();


   2.服务器输出字符数据到浏览器
       *步骤：
          1.获取字符输出流
          2.输出数据
       *乱码原因：编解码的字符集不一样
          1.字符集默认：GBK
          2.解决方法：
            1.PrintWriter pw = response.getWriter();获取的流的默认编码为ISO-8859-1
            2.设置该流的默认编码
            3.告诉浏览器响应体使用的编码
              //获取流对象之前，设置流的默认编码
              response.setCharacterEncoding(&quot;GBK&quot;);

              //告诉浏览器，服务器发送的消息的数据的编码，建议浏览器使用该编码解码
              //包含了上一步
              response.setHeader(&quot;content-type&quot;,&quot;text/html;charset=utf-8&quot;);

              //简单的形式，设置编码
              //为上一步的简化形式
              response.setContentType(&quot;text/html;charset=utf-8&quot;);


   3.服务器输出字节数据到浏览器
       *步骤：
          1.获取字符输出流
          2.输出数据
       *response.setContentType(&quot;text/html;charset=utf-8&quot;);同样要加上此句


   4.验证码
      1.本质：图片
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">    int width = 100;</span><br><span class="line">    int height = 50;</span><br><span class="line">    //1.创建一对象，在内存中图片(验证码图片对象)</span><br><span class="line">    BufferedImage image = new BufferedImage(width,height,BufferedImage.TYPE_INT_RGB);</span><br><span class="line"></span><br><span class="line">    //2.美化图片</span><br><span class="line">    //2.1填充背景色</span><br><span class="line">    Graphics gs = image.getGraphics();//画笔对象</span><br><span class="line">    gs.setColor(Color.PINK);</span><br><span class="line">    gs.fillRect(0,0,width,height);</span><br><span class="line">    //2.2</span><br><span class="line">    gs.setColor(Color.BLUE);</span><br><span class="line">    gs.drawRect(0,0,width-1,height-1);</span><br><span class="line">    //2.3写验证码</span><br><span class="line">    String str =&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789&quot;;</span><br><span class="line">    //生成随机角标</span><br><span class="line">    Random ran = new Random();</span><br><span class="line"></span><br><span class="line">    for(int i=0;i&lt;4;i++) &#123;</span><br><span class="line">        int index = ran.nextInt(str.length());</span><br><span class="line">        //获取字符</span><br><span class="line">        char ch = str.charAt(index);//随机字符</span><br><span class="line">        gs.drawString(ch+&quot;&quot;, width/5*i, height/2);</span><br><span class="line">    &#125;</span><br><span class="line">    //2.4画干扰线</span><br><span class="line">    gs.setColor(Color.GREEN);</span><br><span class="line">    //随机生成坐标点</span><br><span class="line">   for(int i=0;i&lt;10;i++)&#123;</span><br><span class="line">       int x1 = ran.nextInt(width);</span><br><span class="line">       int x2 = ran.nextInt(width);</span><br><span class="line">       int y1 = ran.nextInt(height);</span><br><span class="line">       int y2 = ran.nextInt(height);</span><br><span class="line">       gs.drawLine(x1,x2,y1,y2);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">    //3.将图片输出到页面展示</span><br><span class="line">    ImageIO.write(image,&quot;jpg&quot;,response.getOutputStream());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        window.onload = function()&#123;</span><br><span class="line">            //1.获取图片对象</span><br><span class="line">            var img = document.getElementById(&quot;checkCode&quot;);</span><br><span class="line">            //2.绑定单击事件</span><br><span class="line">            img.onclick = function()&#123;</span><br><span class="line">                //加时间戳</span><br><span class="line">                var date = new Date().getTime();</span><br><span class="line"></span><br><span class="line">                img.src = &quot;/day15/checkCodeServlet?&quot;+date;</span><br><span class="line">            &#125;</span><br><span class="line">            //1.获取图片对象</span><br><span class="line">            var path = document.getElementById(&quot;change&quot;);</span><br><span class="line">            //2.绑定单击事件</span><br><span class="line">            path.onclick = function()&#123;</span><br><span class="line">                //加时间戳</span><br><span class="line">                var date = new Date().getTime();</span><br><span class="line"></span><br><span class="line">                path.src = &quot;/day15/checkCodeServlet?&quot;+date;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">         &lt;img id=&quot;checkCode&quot; src=&quot;/day15/checkCodeServlet&quot;/&gt;</span><br><span class="line">         &lt;a id=&quot;change&quot; href=&quot;&quot;&gt;看不清换一张&lt;/a&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/570911275/570911275.github.io/2019/07/17/JavaEE之Response小结/" data-id="cjycpjxah000chwtnrwz1wx6i" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/javaEE-基础/">javaEE_基础</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-JavaEE之Http协议下小结" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/17/JavaEE之Http协议下小结/" class="article-date">
  <time datetime="2019-07-17T09:14:16.000Z" itemprop="datePublished">2019-07-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/17/JavaEE之Http协议下小结/">JavaEE之Http协议下小结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h2><pre><code>1.请求消息：客户端发送给服务器端的数据
    *数据格式：
       1.请求行
       2.请求头
       3.请求空行
       4.请求体
2.响应消息：服务器端发送给客户端的数据
     *数据格式：
        1.响应行：
             1.组成：协议、版本  响应状态码 状态码描述
             2.响应状态码：服务器告诉客户端浏览器本次请求和响应的一个状态
                 1.状态码都是3位数字
                 *分类：
                    1.1xx:服务器接受客户端消息，但没有接受完成，等待一段时间后，发送1xx多状态码
                    2.2xx:成功。代表：200
                    3.3xx:重定向。代表：302（重定向），304（访问缓冲）
                    4.4xx:客户端错误。代表：404（请求路劲没有对应的资源）405（请求方式没有对应的doxxx方法）
                    5.5xx:服务器端错误。代表：500（服务器内部出现异常）

        2.响应头：
            1.格式：头名称：值
            2.常见的响应头：
                1.Content-Type：服务器告诉客户端本次响应体数据格式以及编码格式
                2.Content-disposition：服务器告诉客户端以什么格式打开响应体数据
                     *值：
                       *in-line:默认值，在当前页面打开
                       *attachment；filename=xx：以附件形式打开响应体。文件下载中使用较多
        3.响应空行：
        4.响应体：传输的数据

     *响应字符串格式
        HTTP/1.1 200 OK
        Date: Sat, 20 Jul 2019 08:33:11 GMT
        Content-Type: image/png
        Transfer-Encoding: chunked
        Connection: keep-alive
        Expires: Sun, 01 Jul 2029 06:36:09 GMT
        Server: nginx
        Last-Modified: Wed, 17 Apr 2019 08:33:53 GMT
        ETag: W/&quot;5cb6e4f1-7da&quot;
        Cache-Control: max-age=315360000
        Content-Encoding: gzip
        Age: 1
        X-Via: 1.1 PSzjjxdx10tk79:7 (Cdn Cache Server V2.0), 1.1 zhj168:14 (Cdn Cache Server V2.0)
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/570911275/570911275.github.io/2019/07/17/JavaEE之Http协议下小结/" data-id="cjycpjx9n0004hwtn255ros6q" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/javaEE-基础/">javaEE_基础</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-JavaEE之Request小结" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/17/JavaEE之Request小结/" class="article-date">
  <time datetime="2019-07-17T06:22:39.000Z" itemprop="datePublished">2019-07-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/17/JavaEE之Request小结/">JavaEE之Request小结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Request"><a href="#Request" class="headerlink" title="Request:"></a>Request:</h2><pre><code>1.request对象和response对象的原理
    1.request和response对象是由服务器创建的，我们使用它们
    2.request对象是来获取请求信息，response对象是来设置响应消息


2.request的继承体系结构：
     ServletRequest  --  接口
            |  继承
     HTTPServletRequest  --  接口
            |  实现
     org.apache.catalina.connector.RequestFacade 类(Tomcat)


3.request功能：

   1.获取请求消息数据
       1.获取请求行数据
           *GET /day14/demo0\?name=zhangsan HTTP/1.1
           *方法：
       //1.获取请求方式：GET
       String method = request.getMethod();
   System.out.println(method);

       (*)//2.获取虚拟目录：/day14
       String ContestPath = request.getContextPath();
   System.out.println(ContestPath);

       //3.获取Servlet路径：/demo01
       String ServletPath = request.getServletPath();
   System.out.println(ServletPath);

       //4.获取get方式请求参数：name=zhangsan
       String Query = request.getQueryString();
   System.out.println(Query);

       (*)//5.获取请求URI：/day14、demo01
       String RequestURI = request.getRequestURI();   // /day14/demo01
   System.out.println(RequestURI);
       StringBuffer RequestURL = request.getRequestURL();  //http://localhost/day14/demo01

       //6.获取协议及版本：HTTP/1.1
       String Protocol = request.getProtocol();
   System.out.println(Protocol);

       //7.获取客户机的IP地址
       String Remote = request.getRemoteAddr();
   System.out.println(Remote);

       2.获取请求头数据
           *方法：
               *（*）String getHeader(String name);通过请求头的名称获取头的值
               *Enumeration&lt;String&gt; getHeaderNames();获取所有的请求名称
       3.获取请求体数据
               *请求体：只有POST请求方式，才有请求体，在请求体中封装了POST请求的请求参数
               *步骤：
                   1.获取流对象
                        *BufferedReader getReader();获取字符输入流，只能操作字符数据
                        *ServletInputStream getInputStream();获取字节数据，可以操作所有类型的数据

                   2.再从流对象中拿数据

   2.其他功能：
        1.获取请求参数通用方式
            1.String getParameter(String name):根据参数名称获取参数值   username=zs&amp;password=123
            2.String[] getParameterValues(String name):根据参数名称获取参数值的数组，多用于复选框  hobby=xx&amp;hobby=game
            3.EnUmeration&lt;String&gt; getParameterNames():获取所有请求的参数名称
            4.Map&lt;String,String[]&gt; getParameterMap():获取所有参数的map集合

                 *中文乱码问题：
                      *get方式：Tomcat8以上已经解决
                      *post方式：在获取参数钱，设置request的编码request.setCharacterEncoding(&quot;utf-8);
        2.请求转发：一种在服务器内部的资源跳转方式
             1.步骤：
                 1.通过request对象获取请求转发器对象 ：RequestDispatcher getRequestDispatcher(String path)
                 2.使用RequestDispatcher对象来进行转发：forWord(ServletRequest request，ServletResponse response)
             2.特点：
                 1.浏览器地址路径不发生变化
                 2.只能转发到当前服务器内部资源中
                 3.转发是一次请求
        3.共享数据：
             *域对象：一个有作用范围的对象，可以在范围内共享数据
             *request域：代表一次请求的范围，一般用于请求转发的多个资源中共享数据
             *方法：
                1.void setAttribute(String name,Object obj):存储数据
                2.Object getAttitude(String name:通过键获取值
                3.void removeAttribute(String name):通过键移除键值对
        4.获取ServletContest：
             *ServletContext getServletContext（）
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/570911275/570911275.github.io/2019/07/17/JavaEE之Request小结/" data-id="cjycpjxb4000jhwtn661phqws" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/javaEE-基础/">javaEE_基础</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-JavaEE之Http协议小结" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/16/JavaEE之Http协议小结/" class="article-date">
  <time datetime="2019-07-16T04:56:47.000Z" itemprop="datePublished">2019-07-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/16/JavaEE之Http协议小结/">JavaEE之Http协议小结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP:"></a>HTTP:</h2><pre><code>* 一、概念：Hyper Text Transfer Protocol 超文本传输协议
   * 传输协议：定义了。客户端和服务器端通信时，发送数据的格式
   * 特点：
      1、基于TCP/IP的高级协议
      2、默认端口号：80
      3、基于请求/响应模型的：一次请求对应一次响应
      4、无状态的：每次请求之间相互独立

    * 历史版本：
        *1.0：每一次请求响应都会建立新的连接
        *1.1：复用连接，对缓存的支持比较好

* 二、请求消息数据格式
        1、请求行
             请求方式 请求URL 请求协议、版本
             GET /login.html HTTP/1.1

             *请求方式：
                *HTTP协议中有7种请求方式，常用的有2种
                     *GET：
                        1、请求参数在请求行中，在URL后。
                        2、请求的URL长度是有限制的
                        3、不太安全
                     *POST：
                        1、请求参数在请求体中
                        2、请求的URL长度是没有限制的
                        3、相对安全
        2、请求头
             请求头名称：请求头值
               *常见的请求头：
                  1.User-Agent：浏览器告诉服务器，我访问你使用的浏览器版本信息
                     *可以在服务器端获取该头的信息，解决浏览器的兼容性问题

                  2.Referer：http://localhost/login.html
                     *告诉服务器我从哪里来
                        *作用:1.仿盗链
                              2.统计结果
        3、请求空行
             空行，用于分隔POST请求的请求头和请求体的
        4、请求体(正文)
           *封装POST请求消息的请求参数
             GET方式无请求体
             POST方式才有请求体：内容为填写内容

        5、字符串格式：
             GET http://localhost:8080/Demo03l HTTP/1.1
             Host: localhost:8080
             User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:68.0) Gecko/20100101 Firefox/68.0
             Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
             Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2
             Accept-Encoding: gzip, deflate
             Connection: keep-alive
             Cookie: Idea-2520cc41=1f0df48d-7b3a-401a-9a18-058a43909bb8
             Upgrade-Insecure-Requests: 1
             Cache-Control: max-age=0
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/570911275/570911275.github.io/2019/07/16/JavaEE之Http协议小结/" data-id="cjycpjxax000hhwtn7aw92ftk" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/javaEE-基础/">javaEE_基础</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-JavaEE之Servlit小结" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/16/JavaEE之Servlit小结/" class="article-date">
  <time datetime="2019-07-16T03:13:38.000Z" itemprop="datePublished">2019-07-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/16/JavaEE之Servlit小结/">JavaEE之Servlit小结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Servlet-server-applet"><a href="#Servlet-server-applet" class="headerlink" title="Servlet: server applet"></a>Servlet: server applet</h2><pre><code>* 一、概念：运行在服务器端的小程序
    * Servlet就是一个接口，定义了Java类被浏览器访问到(tomcat)识别的规则。
    * 将来我们自定义一个类，实现Servlet接口，复写方法


* 二、快速入门：
    1. 创建JavaEE项目
    2. 定义一个类，实现Servlet接口
    public class ServletDemo01 implements Servlet 
    3. 实现接口中的抽象方法
    4. 配置Serlet:在web.xml中配置
        &lt;!--配置Servlet--&gt;
        &lt;servlet&gt;
           &lt;servlet-name&gt;demo01&lt;/servlet-name&gt;
           &lt;servlet-class&gt;cn.itcast.web.servlet.ServletDemo01&lt;/servlet-class&gt;
        &lt;/servlet&gt;
        &lt;servlet-mapping&gt;
           &lt;servlet-name&gt;demo01&lt;/servlet-name&gt;
           &lt;url-pattern&gt;/demo01&lt;/url-pattern&gt;
        &lt;/servlet-mapping&gt;


 * 三、执行原理：
     1.当服务器接受到客户端浏览器的请求后，会解析请求URL路径，获取访问的Servlet的资源路径
     2.查找web.xml文件，是否有对应的&lt;url-pattern&gt;标签体内容。
     3.如果有，则在找到对应的&lt;servlet-class&gt;全类名
     4.Tomcat会将字节码文件加载进内存，并且创建其对象
     5.调用其方法


 * 四、Servlet中的生命周期：
     1. 被创建：执行init方法，只执行一次
         *Servlet什么时候被创建？
            *默认情况下，第一次被访问时，Servlet被创建
            *可以配置执行Servlet的创建时机。
               *在&lt;servlet&gt;标签下配置
                 1.第一次被访问时，创建
                     *&lt;load-on-startup&gt;的值为负数
                 2.在服务器启动时，创建
                     *&lt;load-on-startup&gt;的值为0或者正整数
         *Servlet的init方法，只执行一次，说明一个Servlet在内存中只存在一个对象，说明Servlet是单例的
            *多个用户同时访问时，可能存在线程安全问题
            *解决：尽量不要在Servlet中定义成员变量，即使定义了成员变量，也不要对其修改值(当有的线程在读取时，有的线程进行了修改，则会发生线程错误)；

     2. 提供服务：执行service方法，执行多次
         *每次访问Servlet时，Service方法都会被调用一次
     3. 被销毁：执行destroy方法，只执行一次
         *Servlet被销毁时执行。服务器关闭时，Servlet被销毁
         *只有服务器正常关闭时，才会执行destroy方法 
         *destroy方法在Servlet被销毁之前执行，一般用来释放资源


  * 五、Servlet3.0：
      *好处：
           *支持注解配置，可以不需要web.xml了
      *步骤：
         1. 创建JavaEE项目，选择Servlet的版本3.0以上，可以不创建web.xml
         2. 定义一个类，实现Servlet接口
         3. 复写方法
         4. 在类上使用@webServlet注解，进行配置
             *@WebServlet(&quot;Demo01//资源路径&quot;)


   * 六、Servlet的体系结构
      Servlet -- 接口
          |
      GenericServlet -- 抽象类
          |
      HttpServlet -- 抽象类

      *GenericServlet:将Servlet接口中其他的方法做了默认空实现，只将service（）方法作为抽象
         *将来定义Servlet类时，可以继承GenericServlet，实现service()方法即可  

      *HttpServlet:对http协议的一种封装，简化操作
         1.定义类继承HTTPServlet
         2.复写doGet/doPost方法
</code></pre><h2 id="IDEA和Tomcat的配置"><a href="#IDEA和Tomcat的配置" class="headerlink" title="IDEA和Tomcat的配置"></a>IDEA和Tomcat的配置</h2><pre><code>1.IDEA会为每一个Tomcat部署的项目单独建立一份配置文件
   *查看控制台的log：Using CATALINA_BASE:  &quot;C:\Users\fqy\.IntellijIdea2018.1\system.tomcat\_itcast&quot;
2.工作空间项目 和 Tomcat部署的web项目
   *Tomcat真正访问的是“Tomcat部署的web项目”，“Tomcat部署的web项目”对应着“工作空间项目”的web目录下的所有资源   
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/570911275/570911275.github.io/2019/07/16/JavaEE之Servlit小结/" data-id="cjycpjxbk000ohwtnmc7dishx" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/javaEE-基础/">javaEE_基础</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-IO之四大抽象类" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/10/IO之四大抽象类/" class="article-date">
  <time datetime="2019-07-10T11:18:43.000Z" itemprop="datePublished">2019-07-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/10/IO之四大抽象类/">java_IO_四大抽象类小结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="IO之四大抽象类"><a href="#IO之四大抽象类" class="headerlink" title="IO之四大抽象类"></a>IO之四大抽象类</h2><p>·InputStream</p>
<pre><code>此抽象类是表示字节输入流的所有类的父类。InputSteam是一个抽象类，它不可以实例化。 数据的读取需要由它的子类来实现。根据节点的不同，它派生了不同的节点流子类 。

继承自InputSteam的流都是用于向程序中输入数据，且数据的单位为字节(8 bit)。

常用方法：

int read()：读取一个字节的数据，并将字节的值作为int类型返回(0-255之间的一个值)。如果未读出字节则返回-1(返回值为-1表示读取结束)。

void close()：关闭输入流对象，释放相关系统资源。
</code></pre><p>· OutputStream</p>
<pre><code>此抽象类是表示字节输出流的所有类的父类。输出流接收输出字节并将这些字节发送到某个目的地。

常用方法：

void write(int n)：向目的地中写入一个字节。

void close()：关闭输出流对象，释放相关系统资源。
</code></pre><p>· Reader</p>
<pre><code>Reader用于读取的字符流抽象类，数据单位为字符。

int read(): 读取一个字符的数据，并将字符的值作为int类型返回(0-65535之间的一个值，即Unicode值)。如果未读出字符则返回-1(返回值为-1表示读取结束)。

void close() ： 关闭流对象，释放相关系统资源。
</code></pre><p>· Writer</p>
<pre><code>Writer用于写入的字符流抽象类，数据单位为字符。

void write(int n)： 向输出流中写入一个字符。

void close() ： 关闭输出流对象，释放相关系统资源。
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/570911275/570911275.github.io/2019/07/10/IO之四大抽象类/" data-id="cjycpjx9k0003hwtnlyqv8um4" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java-基础/">java_基础</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/">下一页 &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/javaEE-基础/">javaEE_基础</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java-基础/">java_基础</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/javaEE-基础/" style="font-size: 10px;">javaEE_基础</a> <a href="/tags/java-基础/" style="font-size: 20px;">java_基础</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">七月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">六月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">五月 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/07/18/JavaEE之JSP入门学习小结/">JavaEE之JSP入门学习小结</a>
          </li>
        
          <li>
            <a href="/2019/07/18/JavaEE之Cookie小结/">JavaEE之Cookie小结</a>
          </li>
        
          <li>
            <a href="/2019/07/18/JavaEE之会话技术概念小结/">JavaEE之会话技术概念小结</a>
          </li>
        
          <li>
            <a href="/2019/07/18/JavaEE之ServletContext小结/">JavaEE之ServletContext小结</a>
          </li>
        
          <li>
            <a href="/2019/07/17/JavaEE之Response小结/">JavaEE之Response小结</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>
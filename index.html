<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="https://github.com/570911275/570911275.github.io/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://github.com/570911275/570911275.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-SQL总结" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/08/16/SQL总结/" class="article-date">
  <time datetime="2019-08-16T00:16:30.340Z" itemprop="datePublished">2019-08-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="SQL题库总结"><a href="#SQL题库总结" class="headerlink" title="SQL题库总结"></a>SQL题库总结</h2><ol>
<li><p>175.组合两个表(简单):<br> 答案：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">正确答案：</span><br><span class="line">select Person.FirstName, Person.LastName, Address.City, Address.State from Person left join Address on Address.PersonId = Person.PersonId</span><br><span class="line"></span><br><span class="line">错误答案：</span><br><span class="line">select Person.FirstName, Person.LastName, Address.City, Address.State from Person, Address where Address.PersonId = Person.PersonId</span><br></pre></td></tr></table></figure>
<ul>
<li>关键点：<ol>
<li>使用left join … on … 左连接查询；确保左表数据可在右表无数据的情况下依旧被查询得出</li>
</ol>
</li>
</ul>
</li>
<li><p>176.第二高的薪水(简单)：<br> 答案：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">正确答案：</span><br><span class="line">select IFNULL((select distinct(Salary) </span><br><span class="line">from Employee </span><br><span class="line">order by Salary desc </span><br><span class="line">limit 1 offset 1), null) </span><br><span class="line">as SecondHighestSalary</span><br><span class="line"></span><br><span class="line">错误答案：</span><br><span class="line">select IFNULL (select distinct Salary </span><br><span class="line">from Employee </span><br><span class="line">Order By Salary desc limit (1,1),null) </span><br><span class="line">as SecondHighestSalary;</span><br></pre></td></tr></table></figure>
<ul>
<li>关键点：<ol>
<li>注意括号的使用，此处错误答案便为括号问题</li>
<li>使用ifnull(a,b)：此语句为如果a不为null的话，则返回a内容，如果a为null的话，则返回b内容。此题由于题目要求返回null，所以b处位置为null</li>
<li>使用distinct(a)：此语句为去掉重复的a字段，即若数据库中Salary字段中出现两次200；则只按1次处理</li>
</ol>
</li>
</ul>
</li>
<li><p>181.超过经理收入的员工(简单)：<br> 答案：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">改进答案：</span><br><span class="line">select E1.Name As Employee</span><br><span class="line">from Employee As E1, Employee As E2</span><br><span class="line">where E1.ManagerId is not null and </span><br><span class="line">E1.ManagerId = E2.Id and </span><br><span class="line">E1.Salary &gt; E2.Salary</span><br><span class="line"></span><br><span class="line">原先答案：</span><br><span class="line">select E1.Name Employee</span><br><span class="line">from Employee E1 , Employee E2 </span><br><span class="line">where E1.Salary &gt; E2.Salary and </span><br><span class="line">E1.ManagerId = E2.Id</span><br></pre></td></tr></table></figure>
<ul>
<li>关键点：<ol>
<li>原先未考虑E1(员工表)的ManagerId非空的判断语句；此语句在数据量大时可减少工作量</li>
<li>使用了两个表的关系查询；但无需如同 175.组合两个表 一样进行左连接left join … on …</li>
</ol>
</li>
</ul>
</li>
<li></li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/570911275/570911275.github.io/2019/08/16/SQL总结/" data-id="cjzdf847k0000ustn2judzdvt" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-新文档123" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/08/12/新文档123/" class="article-date">
  <time datetime="2019-08-12T11:44:04.354Z" itemprop="datePublished">2019-08-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="数学建模"><a href="#数学建模" class="headerlink" title="数学建模"></a>数学建模</h2><h3 id="初级建模"><a href="#初级建模" class="headerlink" title="初级建模"></a>初级建模</h3><ol>
<li>光盘的数据容量——近似值计算</li>
<li>核军备竞赛——</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/570911275/570911275.github.io/2019/08/12/新文档123/" data-id="cjzal4mr6002v18tnej1ks9wn" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-新文档8080" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/08/03/新文档8080/" class="article-date">
  <time datetime="2019-08-03T04:21:32.000Z" itemprop="datePublished">2019-08-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/08/03/新文档8080/">javaSSM之SpringMVC快速入门之中小结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="SpringMVC"><a href="#SpringMVC" class="headerlink" title="SpringMVC"></a>SpringMVC</h2><h3 id="SpringMVC的常用注解"><a href="#SpringMVC的常用注解" class="headerlink" title="SpringMVC的常用注解"></a>SpringMVC的常用注解</h3><pre><code>1. RequestParam注解
   1. 作用：吧请求中的指定名称的参数传递给控制器中的形参赋值
   2. 属性：
        1. value：请求参数中的名称
        2. required：请求参数中是否必须提供此参数，默认值是true，必须提供
   3. 示例代码：
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 接收请求</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">@RequestMapping(path=&quot;/hello&quot;)</span><br><span class="line">public String sayHello(@RequestParam(value=&quot;username&quot;,required=false)String name) &#123;</span><br><span class="line">    System.out.println(&quot;aaaa&quot;);</span><br><span class="line">    System.out.println(name);</span><br><span class="line">    return &quot;success&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre><code>2. RequestBody注解
   1. 作用：用于获取请求体的内容(注意：get方法不可以)
   2. 属性:
        1. required：是否必须有请求体，默认值是true
   3. 示例代码：
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 接收请求</span><br><span class="line"> * @return     </span><br><span class="line"> */</span><br><span class="line">@RequestMapping(path=&quot;/hello&quot;)</span><br><span class="line">public String sayHello(@RequestBody String body) &#123;</span><br><span class="line">    System.out.println(&quot;aaaa&quot;);</span><br><span class="line">    System.out.println(body);</span><br><span class="line">    return &quot;success&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre><code>3. PathVariable注解
   1. 作用：拥有绑定url汇总的占位符。如：url中有/delete{id}，{id}就是占位符
   2. 属性：
        1. value：指定url中的占位符名称
   3. Restful风格的URL：
        1. 请求路径一样，可以根据不同的请求方式去执行后台的不同方法
        2. restful风格的URL优点：
             1. 结构清晰
             2. 符合标准
             3. 易于理解
             4. 扩展方便
   4. 示例代码：
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">  &lt;a href=&quot;user/hello/1&quot;&gt;入门案例&lt;/a&gt;</span><br><span class="line">        /**     </span><br><span class="line">          * 接收请求     </span><br><span class="line">          * @return     </span><br><span class="line">          */</span><br><span class="line">    @RequestMapping(path=&quot;/hello/&#123;id&#125;&quot;)</span><br><span class="line">    public String sayHello(@PathVariable(value=&quot;id&quot;) String id) &#123;</span><br><span class="line">        System.out.println(id);</span><br><span class="line">        return &quot;success&quot;;</span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">``` </span><br><span class="line">       4. RequestHeader注解</span><br><span class="line">          1. 作用：获取指定请求头的值</span><br><span class="line">          2. 属性：</span><br><span class="line">               1. value：请求头的名称</span><br><span class="line">          3. 示例代码：</span><br></pre></td></tr></table></figure>
<p>@RequestMapping(path=”/hello”)<br>    public String sayHello(@RequestHeader(value=”Accept”) String header) {<br>        System.out.println(header);<br>        return “success”;<br>    }<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">5. CookieValue注解</span><br><span class="line">   1. 作用：用于获取指定Cookie的名称的值</span><br><span class="line">   2. 属性：</span><br><span class="line">        1. value：cookie的名称</span><br><span class="line">   3. 示例代码：</span><br></pre></td></tr></table></figure></p>
<pre><code>@RequestMapping(path=&quot;/hello&quot;)
public String sayHello(@CookieValue(value=&quot;JSESSIONID&quot;) String cookieValue) {
    System.out.println(cookieValue);
    return &quot;success&quot;;
}
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">       6. ModelAttribute注解</span><br><span class="line">          1. 作用：</span><br><span class="line">               1. 出现在方法上：表示当前方法会在控制器方法执行前执行</span><br><span class="line">               2. 出现在参数上：获取指定的数据给参数赋值</span><br><span class="line">          2. 应用场景：</span><br><span class="line">               1. 当提交表单数据不是完整的视图数据时，保证没有提交的字段使用数据库原来的数据</span><br><span class="line">          3. 示例代码：</span><br><span class="line">               1. 修饰的方法</span><br><span class="line">### SpringMVC的Json</span><br><span class="line">       1. SpringMVC设置静态资源不拦截</span><br><span class="line">          1. 方式一：在SpringMVC.xml中添加静态资源的映射</span><br></pre></td></tr></table></figure>
<p>location指的是本地的真实的物理路径 ，mapping指的是映射到的虚拟路径(比如前端请求的url地址)<br>    &lt;mvc:resources location=”/css/“ mapping=”/css/<strong>“/&gt;  <!-- 样式 --><br>    &lt;mvc:resources location=”/images/“ mapping=”/images/</strong>“/&gt;  <!-- 图片 --><br>    &lt;mvc:resources location=”/js/“ mapping=”/js/**”/&gt;  <!-- javascript --><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2. 方式二：在SpringMVC.xml中添加静态资源默认Servlet处理</span><br></pre></td></tr></table></figure></p>
<p><a href="mvc:default-servlet-handler/" target="_blank" rel="noopener">mvc:default-servlet-handler/</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3. 方式三：在web.xml中配置映射</span><br></pre></td></tr></table></figure></p>
<pre><code>&lt;servlet-mapping&gt;
    &lt;servlet-name&gt;default&lt;/servlet-name&gt;
    &lt;url-pattern&gt;*.js&lt;/url-pattern&gt;
    &lt;url-pattern&gt;*.css&lt;/url-pattern&gt;
    &lt;url-pattern&gt;*.ico&lt;/url-pattern&gt;
    &lt;url-pattern&gt;/img/*&lt;/url-pattern&gt;
    &lt;url-pattern&gt;/fonts/*&lt;/url-pattern&gt;
    &lt;url-pattern&gt;/font/*&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">2. 使用注解@RequestBody获取请求体数据</span><br></pre></td></tr></table></figure>
<p>response.jsp</p>
<pre><code>//页面加载，绑定单击事件
$(function () {
   $(&quot;#btn&quot;).click(function () {
       // alert(&quot;hello&quot;);
       //发送ajax请求
       $.ajax({
           //编写json格式，设置属性和值
           url:&quot;user/testAjax&quot;,
           contentType:&quot;application/json;charset=UTF-8&quot;,
           data:&apos;{&quot;username&quot;:&quot;haha&quot;,&quot;password&quot;:&quot;123&quot;,&quot;age&quot;:&quot;18&quot;}&apos;,
           dataType:&quot;json&quot;,
           type:&quot;post&quot;,
           success:function(data){
               //data服务器端响应的json的数据，进行解析
           }
       });
   });
});
</code></pre><p>获取请求体的数据UserController.class</p>
<pre><code>@RequestMapping(&quot;testAjax&quot;)
public void testAjax(@RequestBody String body){
    System.out.println(&quot;testAjax方法执行了&quot;);
    System.out.println(body);
}
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">3. 使用注解@RequestBody和@ResponseBody</span><br><span class="line">     * 使用@RequestBody注解把json的字符串转换成JavaBean的对象</span><br><span class="line">     * 使用@ResponseBody注解把JavaBean对象转换成json字符串，直接响应</span><br></pre></td></tr></table></figure>
<p>使用@RequestBody和@ResponseBody</p>
<pre><code>/**
 * 模拟异步请求响应
 *
 *当json的字符串的key值与JavaBean中的属性名相同
 *SpringMVC将会自动把数据封装到对象中
 * 此过程需要额外的jar包(jackson)——数据之间的转换
 */
@RequestMapping(&quot;testAjax&quot;)
public @ResponseBody User testAjax(@RequestBody User user){
    System.out.println(&quot;testAjax方法执行了&quot;);
    //客户端发送ajax的请求，传的是json字符串，后端把json字符串封装到user对象中
    System.out.println(user);
    //做响应，模拟查询数据库
    user.setUsername(&quot;haha&quot;);
    user.setAge(17);
    //做响应
    return user;
}
</code></pre><p>response.jsp</p>
<pre><code>//页面加载，绑定单击事件
$(function () {
   $(&quot;#btn&quot;).click(function () {
       // alert(&quot;hello&quot;);
       //发送ajax请求
       $.ajax({
           //编写json格式，设置属性和值
           url:&quot;user/testAjax&quot;,
           contentType:&quot;application/json;charset=UTF-8&quot;,
           data:&apos;{&quot;username&quot;:&quot;haha&quot;,&quot;password&quot;:&quot;123&quot;,&quot;age&quot;:&quot;18&quot;}&apos;,
           dataType:&quot;json&quot;,
           type:&quot;post&quot;,
           success:function(data){
               //data服务器端响应的json的数据，进行解析
               alert(data);
               alert(data.username);
               alert(data.password);
               alert(data.age);
           }
       });
   });
});
</code></pre><p><code>`</code></p>
<h3 id="SpringMVC的文件上传"><a href="#SpringMVC的文件上传" class="headerlink" title="SpringMVC的文件上传"></a>SpringMVC的文件上传</h3>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/570911275/570911275.github.io/2019/08/03/新文档8080/" data-id="cjzal4mrb003018tnjpi1gbrf" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/javaSSM-基础/">javaSSM_基础</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-javaSSM之SpringMVC快速入门之上小结" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/08/03/javaSSM之SpringMVC快速入门之上小结/" class="article-date">
  <time datetime="2019-08-03T00:01:42.000Z" itemprop="datePublished">2019-08-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/08/03/javaSSM之SpringMVC快速入门之上小结/">javaSSM之SpringMVC快速入门之上小结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="SpringMVC"><a href="#SpringMVC" class="headerlink" title="SpringMVC"></a>SpringMVC</h2><h3 id="一、SpringMVC的基本概念"><a href="#一、SpringMVC的基本概念" class="headerlink" title="一、SpringMVC的基本概念"></a>一、SpringMVC的基本概念</h3><pre><code>1. SpringMVC是什么：
     * SpringMVC是一种基于Java的实现MVC设计模型的请求驱动类型的轻量级Web框架。
     * SpringMVC通过一套注解，让一个简单的Java类成为处理请求的控制器，而无须实现任何接口。同时它还支持RESTful编程风格的请求。

2. 环境搭建：
     * 导入jar包
     * 搭建前端控制器
     * 编写SpringMVC.xml的配置文件
     * 搭建服务器
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">一、前端控制器(web.xml)</span><br><span class="line"></span><br><span class="line">    &lt;!-- SpringMVC的核心控制器 --&gt;</span><br><span class="line">    &lt;servlet&gt;</span><br><span class="line">        &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt;</span><br><span class="line">        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servletclass&gt;</span><br><span class="line">        &lt;!-- 配置Servlet的初始化参数，读取springmvc的配置文件，创建spring容器 --&gt;</span><br><span class="line">        &lt;init-param&gt;</span><br><span class="line">            &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;</span><br><span class="line">            &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt;</span><br><span class="line">        &lt;/init-param&gt;</span><br><span class="line">        &lt;!-- 配置servlet启动时加载对象 --&gt;</span><br><span class="line">        &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;</span><br><span class="line">    &lt;/servlet&gt;</span><br><span class="line">    &lt;servlet-mapping&gt;</span><br><span class="line">        &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt;</span><br><span class="line">        &lt;url-pattern&gt;/&lt;/url-pattern&gt;</span><br><span class="line">    &lt;/servlet-mapping&gt;</span><br><span class="line"></span><br><span class="line">二、SpringMVC.xml配置文件</span><br><span class="line"></span><br><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line"> &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">    xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;</span><br><span class="line">    xmlns:context=&quot;http://www.springframework.org/schema/context&quot;</span><br><span class="line">    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">    xsi:schemaLocation=&quot;</span><br><span class="line">        http://www.springframework.org/schema/beans</span><br><span class="line">        http://www.springframework.org/schema/beans/spring-beans.xsd</span><br><span class="line">        http://www.springframework.org/schema/mvc</span><br><span class="line">        http://www.springframework.org/schema/mvc/spring-mvc.xsd</span><br><span class="line">        http://www.springframework.org/schema/context</span><br><span class="line">        http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">            &lt;!-- 配置spring创建容器时要扫描的包 --&gt;</span><br><span class="line">    &lt;context:component-scan base-package=&quot;com.itheima&quot;&gt;&lt;/context:component-scan&gt;</span><br><span class="line"></span><br><span class="line">           &lt;!-- 配置视图解析器 --&gt;</span><br><span class="line">    &lt;bean id=&quot;viewResolver&quot;</span><br><span class="line"> class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/pages/&quot;&gt;&lt;/property&gt;</span><br><span class="line">        &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;&gt;&lt;/property&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!-- 配置spring开启注解mvc的支持</span><br><span class="line">     &lt;mvc:annotation-driven&gt;&lt;/mvc:annotation-driven&gt;--&gt;</span><br><span class="line"></span><br><span class="line"> &lt;/beans&gt;</span><br></pre></td></tr></table></figure>
<pre><code>3. 入门案例总结：
     1. 入门案例的执行流程
          * 启动服务器，由于配置了load-on-startup标签，使用会创建DispatherServlet对象，就会加载springmvc.xml配置文件
          * 开启注解扫描，所以HelloController(Controller)对象被创建
          * 从index.jsp发送请求，请求会先到达DispatcherServlet核心控制器(前端控制器)
          * 根据配置@RequestMapping注解找到执行的具体方法
          * 根据执行方法的返回值，再根据配置的视图解析器，去指定的目录下查找指定名称的JSP文件
          * Tomcat服务器渲染页面，做出响应

     2. 入门案例流程图
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">          项目名称(/hello)</span><br><span class="line">       &lt;a href=&quot;hello&quot;&gt;入门程序&lt;/a&gt; </span><br><span class="line">                |                          6</span><br><span class="line">            1   |   |———————————————————————————————————————————————— |                        </span><br><span class="line">               \|  \|/                                                |    </span><br><span class="line">       7  控制中心、指挥中心   4         视图解析器对象          5      /|\</span><br><span class="line">结果 &lt;————DispatcherServlet ————&gt;InternalResourceViewResolver————&gt;success.jsp</span><br><span class="line">                |   |\</span><br><span class="line">            2   |   |   3</span><br><span class="line">               \|   |</span><br><span class="line">          @RequestMapping(path=&quot;/hello&quot;)</span><br><span class="line">public String sayHello()&#123;</span><br><span class="line">    System.out.println(&quot;hello StringMVC&quot;);</span><br><span class="line">    return &quot;success&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre><code>3. 入门案组件小结：
     1. DispatcherServlet：前端控制器 
          * 用户请求到达前端控制器，它就相当于 mvc 模式中的 c，dispatcherServlet 是整个流程控制的中心，由 它调用其它组件处理用户的请求，dispatcherServlet 的存在降低了组件之间的耦合性 

     2. HandlerMapping：处理器映射器
          * HandlerMapping 负责根据用户请求找到 Handler 即处理器，SpringMVC 提供了不同的映射器实现不同的 映射方式，例如：配置文件方式，实现接口方式，注解方式等。

     3. Handler：处理器 
          * 它就是我们开发中要编写的具体业务控制器。由 DispatcherServlet 把用户请求转发到 Handler。由 Handler 对具体的用户请求进行处理。

     4. HandlAdapter：处理器适配器 
          * 通过 HandlerAdapter 对处理器进行执行，这是适配器模式的应用，通过扩展适配器可以对更多类型的处理 器进行执行。 

     5. View Resolver：视图解析器 
          * View Resolver 负责将处理结果生成 View 视图，View Resolver 首先根据逻辑视图名解析成物理视图名 即具体的页面地址，再生成 View 视图对象，最后对 View 进行渲染将处理结果通过页面展示给用户

     6. View：视图 
          * SpringMVC 框架提供了很多的 View 视图类型的支持，包括：jstlView、freemarkerView、pdfView 等。我们最常用的视图就是 jsp。 一般情况下需要通过页面标签或页面模版技术将模型数据通过页面展示给用户，需要由程序员根据业务需求开发具体的页面

     7. &lt;mvc:annotation-driven&gt;说明
          * 在 SpringMVC 的各个组件中，处理器映射器、处理器适配器、视图解析器称为 SpringMVC 的三大组件。 
          * 使用&lt;mvc:annotation-driven&gt; 自动加载 RequestMappingHandlerMapping （处理映射器）和 RequestMappingHandlerAdapter （ 处 理 适 配 器 ） ， 
          * 可 用 在 SpringMVC.xml 配 置 文 件 中 使 用 &lt;mvc:annotation-driven&gt;替代注解处理器和适配器的配置。
          *  它就相当于在 xml 中配置了：
          *   &lt;!-- 上面的标签相当于 如下配置--&gt;
          *   &lt;!-- Begin --&gt;
          *   &lt;!-- HandlerMapping --&gt;
          *   &lt;bean

4. RequestMapping的作用：
      * 用于建立请求 URL 和处理请求方法之间的对应关系。
      * 出现位置：
            1. 类上：请求 URL 的第一级访问目录。此处不写的话，就相当于应用的根目录。写的话需要以/开头。它出现的目的是为了使我们的 URL 可以按照模块化管理
            2. 方法上：请求 URL 的第二级访问目录
            3. 细节：${pageContext.request.contextPath}也可以省略不写，但是路径上不能写/
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">   账户模块：</span><br><span class="line">     /account/add</span><br><span class="line">     /account/update </span><br><span class="line">     /account/delete </span><br><span class="line">* account：是在类上</span><br><span class="line">* add、update、delete：是在方法上 </span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">      5. RequestMapping的属性：</span><br><span class="line">             1. path：指定请求路径的url</span><br><span class="line">             2. value：用于指定请求的URL。它和path属性的作用是一样的。</span><br><span class="line">             3. method：用于指定请求的方式。</span><br><span class="line">             4. params：用于指定限制请求参数的条件。它支持简单的表达式。要求请求参数的 key 和 value 必须和 配置的一模一样。</span><br><span class="line">`例如：     params = &#123;&quot;accountName&quot;&#125;，表示请求参数必须有 accountName     params = &#123;&quot;moeny!100&quot;&#125;，表示请求参数中 money 不能是 100。`  </span><br><span class="line">             5. headers：用于指定限制请求消息头的条件。</span><br><span class="line">             * 注意：   以上四个属性只要出现 2 个或以上时，他们的关系是与的关系。</span><br><span class="line">### 二、SpringMVC请求参数的绑定</span><br><span class="line">      1. 请求参数的绑定说明：</span><br><span class="line">             1. 绑定机制</span><br><span class="line">                   1. 表单提交的数据都是k=v格式的   username=haha&amp;password=123</span><br><span class="line">                   2. SpringMVC的参数绑定过程是把表单提交的请求参数，作为控制器中方法的参数进行绑定的</span><br><span class="line">                   3. 要求：提交表单的name和参数的名称是相同的</span><br><span class="line">                  </span><br><span class="line">             2. 支持的数据类型</span><br><span class="line">                   1. 基本数据类型和字符串类型</span><br><span class="line">                   2. 实体类型(JavaBean)</span><br><span class="line">                   3. 集合数据类型(List、map集合等) </span><br><span class="line">                  </span><br><span class="line">      2. 基本数据类型和字符串类型</span><br><span class="line">             1. 提交表单的name和参数的名称是相同的</span><br><span class="line">             2. 区分大小写</span><br><span class="line">           </span><br><span class="line">      3. 实体类型(JavaBean)</span><br><span class="line">             1. 提交表单的name和JavaBean中的属性名称需要一致</span><br><span class="line">             2. 如果一个JavaBean类中包含其他的引用类型，那么表单的name需要编写成对象.属性  如：address.name</span><br><span class="line">           </span><br><span class="line">      4. 集合属性类型封装</span><br><span class="line">             1. JSP页面编写方式:list[0].属性 </span><br><span class="line"></span><br><span class="line">      5. 请求参数中文乱码的解决</span><br><span class="line">             1. 在web.xml中配置Spring提供的过滤器</span><br></pre></td></tr></table></figure>
<pre><code>&lt;!-- 配置过滤器，解决中文乱码的问题 --&gt;
&lt;filter&gt;
    &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt;
    &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filterclass&gt;

    &lt;!-- 指定字符集 --&gt;
    &lt;init-param&gt;
        &lt;param-name&gt;encoding&lt;/param-name&gt;
        &lt;param-value&gt;UTF-8&lt;/param-value&gt;
    &lt;/init-param&gt;
&lt;/filter&gt;

&lt;filter-mapping&gt;
    &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt;
    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
&lt;/filter-mapping&gt;
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">6. 自定义类型转换器</span><br><span class="line">       1. 表单提交的任何数据类型全部都是字符串类型，但是后台定义Integer类型，数据也可以封装上，说明Spring框架内部会默认进行数据类型转换</span><br><span class="line">       2. 如果想自定义数据类型转换，可以实现Converter的接口</span><br></pre></td></tr></table></figure>
<p>一、自定义类型转换器</p>
<p>package cn.itcast.utils;</p>
<p>import java.text.DateFormat;<br>import java.text.SimpleDateFormat;<br>import java.util.Date;</p>
<p>import org.springframework.core.convert.converter.Converter;</p>
<p>/** </p>
<ul>
<li>把字符串转换成日期的转换器 </li>
<li><p>@author rt<br>*/<br>public class StringToDateConverter implements Converter&lt;String, Date&gt;{</p>
<p>  /**     </p>
<ul>
<li>进行类型转换的方法<br>*/<br>public Date convert(String source) {<br> // 判断<br> if(source == null) {<pre><code>throw new RuntimeException(&quot;参数不能为空&quot;);
</code></pre> }<br> try {            <pre><code>DateFormat df = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);
// 解析字符串
Date date = df.parse(source);
return date;
</code></pre> } catch (Exception e) {<pre><code>throw new RuntimeException(&quot;类型转换错误&quot;);
</code></pre> }<br>}<br>}</li>
</ul>
</li>
</ul>
<p>二、注册自定义类型转换器，在SpringMVC.xml配置文件中编写配置  </p>
<!-- 注册自定义类型转换器 -->
<pre><code>&lt;bean id=&quot;conversionService&quot;
</code></pre><p> class=”org.springframework.context.support.ConversionServiceFactoryBean”&gt;<br>        <property name="converters"><br>            <set><br>                <bean class="cn.itcast.utils.StringToDateConverter"><br>            </bean></set><br>        </property><br>    <br>        <!-- 开启Spring对MVC注解的支持 --><br>    &lt;mvc:annotation-driven conversion-service=”conversionService”/&gt;</p>
<p><code>`</code></p>
<pre><code>7. 在控制器中使用原生的ServletAPI对象
       1. 只需要在控制器的方法参数定义HttpServletRequest和HttpServletResponse对象 
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/570911275/570911275.github.io/2019/08/03/javaSSM之SpringMVC快速入门之上小结/" data-id="cjzal4msz003u18tn5nmmrd5q" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/javaSSM-基础/">javaSSM_基础</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-javaSSM之SpringMVC之Restful小结" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/08/02/javaSSM之SpringMVC之Restful小结/" class="article-date">
  <time datetime="2019-08-02T05:20:01.000Z" itemprop="datePublished">2019-08-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/08/02/javaSSM之SpringMVC之Restful小结/">javaSSM之SpringMVC之Restful小结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="SpringMVC之Restful小结"><a href="#SpringMVC之Restful小结" class="headerlink" title="SpringMVC之Restful小结"></a>SpringMVC之Restful小结</h2><h3 id="URL设计"><a href="#URL设计" class="headerlink" title="URL设计"></a>URL设计</h3><pre><code>1. 动词+宾语
    * Restful的核心思想就是，客户端发出的数据操作指令都是&quot;动词+宾语&quot;的结构。
    * 比如：GET/articles;GET是动词，/articles是宾语

2. 动词的种类
    * 动词通常就是五种HTTP方法，对应CRUD操作
    * 动词一律大写
        * GET: 读取(Read)
        * POST: 新建(Create)
        * PUT: 更新(Update)
        * PATCH: 更新(Update)——部分更新
        * DELETE: 删除(Delete)

3. 动词的覆盖与宾语必须是名词
     1.  有些客户端只能使用GET和POST这两种方法。服务器必须接受POST模拟其他三个方法（PUT、PATCH、DELETE）。这时，客户端发出的 HTTP 请求，要加上X-HTTP-Method-Override属性，告诉服务器应该使用哪一个动词，覆盖POST方法。
           * 在下列代码中：X-HTTP-Method-Override指定本次请求的方法是PUT，而不是POST。
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">POST /api/Person/4 HTTP/1.1  </span><br><span class="line">X-HTTP-Method-Override: PUT</span><br></pre></td></tr></table></figure>
<pre><code>2.  宾语就是 API 的 URL，是 HTTP 动词作用的对象。它应该是名词，不能是动词。比如，/articles这个 URL 就是正确的，而下面的 URL 不是名词，所以都是错误的。
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/getAllCars</span><br><span class="line">/createNewCar</span><br><span class="line">/deleteAllRedCars</span><br></pre></td></tr></table></figure>
<pre><code>4. URL的规范
      1. 复数URL：
            * 既然 URL 是名词，那么应该使用复数，还是单数？
            * 这没有统一的规定，但是常见的操作是读取一个集合，比如GET /articles（读取所有文章），这里明显应该是复数。
            * 为了统一起见，建议都使用复数 URL，比如GET /articles/2要好于GET /article/2。

      2. 避免多级 URL：
            * 常见的情况是，资源需要多级分类，因此很容易写出多级的 URL，比如获取某个作者的某一类文章。
            `GET /authors/12/categories/2`
            * 这种 URL 不利于扩展，语义也不明确，往往要想一会，才能明白含义。
            * 更好的做法是，除了第一级，其他级别都用查询字符串表达。
            `GET /authors/12?categories=2`
            * 下面是另一个例子，查询已发布的文章。你可能会设计成下面的 URL。
            `GET /articles/published`
            * 查询字符串的写法明显更好。
            `GET /articles?published=true`
</code></pre><h3 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h3><pre><code>1. 状态码的概念：
     * 客户端的每一次请求，服务器都必须给出回应。回应包括 HTTP 状态码和数据两部分。

2. 状态码的类别：
     * 1xx：相关信息
     * 2xx：操作成功
     * 3xx：重定向
     * 4xx：客户端错误
     * 5xx：服务器错误
</code></pre><h3 id="服务器回应"><a href="#服务器回应" class="headerlink" title="服务器回应"></a>服务器回应</h3><pre><code>1. 不要返回纯本文
     * PI 返回的数据格式，不应该是纯文本，而应该是一个 JSON 对象，这样才能返回标准的结构化数据。
     * 所以，服务器回应的 HTTP 头的Content-Type属性要设为application/json。
     * 客户端请求时，也要明确告诉服务器，可以接受 JSON 格式，即请求的 HTTP 头的ACCEPT属性也要设成application/json。
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GET /orders/2 HTTP/1.1 </span><br><span class="line">Accept: application/json</span><br></pre></td></tr></table></figure>
<pre><code>2. 发生错误时，不要返回 200 状态码
   1. 错误做法
      * 有一种不恰当的做法是，即使发生错误，也返回200状态码，把错误信息放在数据体里面
      * 如此一来解析数据体以后，才能得知操作失败。
   2. 正确做法
      * 状态码反映发生的错误
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">错误做法：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Content-Type: application/json</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;status&quot;: &quot;failure&quot;,</span><br><span class="line">  &quot;data&quot;: &#123;</span><br><span class="line">    &quot;error&quot;: &quot;Expected at least two items in list.&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">正确做法：</span><br><span class="line"></span><br><span class="line">HTTP/1.1 400 Bad Request</span><br><span class="line">Content-Type: application/json</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;error&quot;: &quot;Invalid payoad.&quot;,</span><br><span class="line">  &quot;detail&quot;: &#123;</span><br><span class="line">     &quot;surname&quot;: &quot;This field is required.&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre><code>3. 提供链接
     1. API 的使用者未必知道，URL 是怎么设计的。一个解决方法就是，在回应中，给出相关链接，便于下一步操作。这样的话，用户只要记住一个 URL，就可以发现其他的 URL。这种方法叫做 HATEOAS。

     * 举例来说，GitHub 的 API 都在 api.github.com 这个域名。访问它，就可以得到其他 URL。
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  &quot;feeds_url&quot;: &quot;https://api.github.com/feeds&quot;,</span><br><span class="line">  &quot;followers_url&quot;: &quot;https://api.github.com/user/followers&quot;,</span><br><span class="line">  &quot;following_url&quot;: &quot;https://api.github.com/user/following&#123;/target&#125;&quot;,</span><br><span class="line">  &quot;gists_url&quot;: &quot;https://api.github.com/gists&#123;/gist_id&#125;&quot;,</span><br><span class="line">  &quot;hub_url&quot;: &quot;https://api.github.com/hub&quot;,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre><code>2. 上面的回应中，挑一个 URL 访问，又可以得到别的 URL。对于用户来说，不需要记住 URL 设计，只要从 api.github.com 一步步查找就可以了。

* HATEOAS 的格式没有统一规定，上面例子中，GitHub 将它们与其他属性放在一起。更好的做法应该是，将相关链接与其他属性分开。
</code></pre><pre><code>HTTP/1.1 200 OK
Content-Type: application/json

{
  &quot;status&quot;: &quot;In progress&quot;,
   &quot;links&quot;: {[
    { &quot;rel&quot;:&quot;cancel&quot;, &quot;method&quot;: &quot;delete&quot;, &quot;href&quot;:&quot;/api/status/12345&quot; } ,
    { &quot;rel&quot;:&quot;edit&quot;, &quot;method&quot;: &quot;put&quot;, &quot;href&quot;:&quot;/api/status/12345&quot; }
  ]}
}

</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/570911275/570911275.github.io/2019/08/02/javaSSM之SpringMVC之Restful小结/" data-id="cjzal4mqu002k18tnxird3fmh" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/javaSSM-基础/">javaSSM_基础</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-javaSSM之Spring之AOP小结小结" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/08/01/javaSSM之Spring之AOP小结小结/" class="article-date">
  <time datetime="2019-08-01T01:40:11.000Z" itemprop="datePublished">2019-08-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/08/01/javaSSM之Spring之AOP小结小结/">javaSSM之Spring之AOP小结小结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Spring之AOP小结"><a href="#Spring之AOP小结" class="headerlink" title="Spring之AOP小结"></a>Spring之AOP小结</h2><h3 id="一、AOP概念"><a href="#一、AOP概念" class="headerlink" title="一、AOP概念"></a>一、AOP概念</h3><pre><code>1. 面向切面编程，指扩展功能不修改源代码，将功能代码从业务逻辑代码中分离出来。
     * 主要功能：日志记录、性能统计、安全控制、事务处理、异常处理等等
     * 主要意图：将日志记录、性能统计、安全控制、事务管理、异常处理等代码从业务逻辑代码中划分出来，通过对这些行为的分离，我们希望可以将它们独立到非指导业务逻辑的方法中，进而改变这些行为的时候不影响业务逻辑的代码。
</code></pre><h3 id="二、AOP特点"><a href="#二、AOP特点" class="headerlink" title="二、AOP特点"></a>二、AOP特点</h3><pre><code>1. 采用横向抽取机制，取代了传统纵向继承体系重复性代码
</code></pre><h3 id="三、AOP底层实现"><a href="#三、AOP底层实现" class="headerlink" title="三、AOP底层实现"></a>三、AOP底层实现</h3><pre><code>1. AOP底层使用动态代理实现。包括两种方式：
      * 使用JDK动态代理实现
      * 使用cglib来实现

2. JDK动态代理实现
      * 只能对实现了接口的类生成代理，而不是针对类，该目标类型实现的接口都将被代理。原理是通过在运行期间创建一个接口的实现类来完成对目标对象的代理。
      * 步骤：
          1. 定义一个实现接口InvocationHandler的类
          2. 通过构造函数，注入被代理类
          3. 实现invoke（Object proxy,Method method,Object[] args）方法
          4. 在主函数中获得被代理类的类加载器
          5. 使用Proxy.newProxyInstance()产生一个代理对象
          6. 通过代理对象调用各种方法

3. cglib动态代理实现
       * 针对类实现代理，对是否实现接口无要求。原理是对知道的类生成一个子类，覆盖其中的方法，因为是继承，所以被代理的类或方法最好不要声明被final类型。
       * 步骤：
           1. 如果目标对象实现了接口，默认情况下会采用JDK的动态代理实现AOP，也可以强制使用cglib实现AOP
           2. 如果目标对象没有实现接口，必须采用cglib库，Spring会自动在JDK动态代理和cglib之间转换

4. 静态代理和动态代理的区别：
       * 静态代理：自己编写创建代理类，然后再进行编译，在程序运行前，代理类的.class文件就已经存在了
       * 动态代理：在实现阶段不用关心代理水，而在运行阶段(通过反射机制)才指定代理哪一个对象
</code></pre><h3 id="四、AOP操作术语"><a href="#四、AOP操作术语" class="headerlink" title="四、AOP操作术语"></a>四、AOP操作术语</h3><pre><code>1. 术语总结：
 * Joinpoint(连接点)：类里面可以被增强的方法，这些方法被称为连接点
 * Pointcut(切入点)：所谓切入点是指我们要对哪些Jpinpoint进行拦截的定义
 * Advice(通知/增强): 所谓通知(增强)是指拦截到Joinpoint之后所要做的事情就是通知，通知分为前置通知、后置通知、异常通知、最终通知、环绕通知(切面要完成的功能)
 * Aspect(切面): 是切入点和通知(引介)的结合
 * Introduction(引介): 引介是一种特殊的通知在不修改类代码的前提下, Introduction可以在运行期为类动态地添加一些方法或Field
 * Target(目标对象): 代理的目标对象(要增强的类) 
 * Weaving(织入): 是把增强应用到目标的过程，把advice 应用到 target的过程
 * Proxy(代理): 一个类被AOP织入增强后，就产生一个结果代理类  

2. 常用术语：
 * 切入点(Pointcut)：在类里边可以有很多方法被增强，比如实际操作中，只是增强了个别方法，则定义实际被增强的某个方法为切入点。
 * 通知/增强(Advice) ：增强的逻辑，称为增强，比如扩展日志功能，这个日志功能称为增强
       * 前置通知：在方法之前执行
       * 后置通知：在方法之后执行
       * 异常通知：方法出现异常执行
       * 最终通知：在后置之后执行
       * 环绕通知：在方法之前和之后执行​​​​​​​
 * 切面：把增强应用到具体方法上面的过程称为切面。​​​​​​​
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/570911275/570911275.github.io/2019/08/01/javaSSM之Spring之AOP小结小结/" data-id="cjzal4mqw002n18tnnrnm5hg4" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/javaSSM-基础/">javaSSM_基础</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-javaSSM之Spring快速入门之下小结" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/26/javaSSM之Spring快速入门之下小结/" class="article-date">
  <time datetime="2019-07-26T12:16:51.000Z" itemprop="datePublished">2019-07-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/26/javaSSM之Spring快速入门之下小结/">javaSSM之Spring快速入门之中小结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h2><h3 id="第五章————高级装配"><a href="#第五章————高级装配" class="headerlink" title="第五章————高级装配"></a>第五章————高级装配</h3><pre><code>1. Spring中的单例Bean
    1. 无论我们是否去主动获取bean对象，Spring上下文一加载就会创建bean对象
    2. 无论获取多少次，拿到的都是同一个对象
    3. 无论我们是否去主动获取或注入bean对象，Spring上下文一加载就会创建bean对象
    4. 无论注入多少次，拿到的都是同一个对象

2. bean的作用域
    1. 单例(sinleton)：
        * 在整个应用程序中，只创建bean的一个实例
    2. 原形(prototype)：
        * 每次注入或通过Spring上下文获取的时候，都会创建一个新的bean实例
    3. 会话(session)：
        * 在web应用中，为每个会话创建一个bean实例
    4. 请求(request)：
        * 在web应用中，为每个请求创建一个bean实例
    5. 单例与原形的区别：
          1. 单例：
              * scope=&quot;singleton&quot;
              * 1.无论我们是否去主动获取或注入bean对象，Spring上下文一加载就会创建bean对象
              * 2.无论注入多少次，拿到的都是同一个对象
          2. 原形：
              * scope=&quot;prototype&quot;
              * 1.Spring上下文加载的时候不会创建bean对象
              * 2.每次注入，都会拿到不同的bean对象

3. 自动装配中定义bean的作用域
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/570911275/570911275.github.io/2019/07/26/javaSSM之Spring快速入门之下小结/" data-id="cjzal4mqz002p18tn3h14uzty" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/javaSSM-基础/">javaSSM_基础</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-javaSSM之Spring快速入门之中小结" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/26/javaSSM之Spring快速入门之中小结/" class="article-date">
  <time datetime="2019-07-26T06:03:21.000Z" itemprop="datePublished">2019-07-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/26/javaSSM之Spring快速入门之中小结/">javaSSM之Spring快速入门之中小结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h2><h3 id="第三章————Java装配"><a href="#第三章————Java装配" class="headerlink" title="第三章————Java装配"></a>第三章————Java装配</h3><pre><code>1. 当我们想将第三方库中的组件装配到应用程序中，则没有办法在类上添加@Compenent和@Autowired等注解

2. 解决方案：显示配置
      * java中进行显示的配置(本章)
      * xml中进行显示的配置(第四章)

3. JavaConfig
     * 不同于自动装配的地方：
         * 无需在实现类标注注解：@Component
         * 无需在AppConfig出标注注解@ComponentScan

     * @Configuration
         * 同自动装配一样，同样需要给AppConfig文件标注此注解；
         * 表示其为配置文件（为JavaConfig的关键）

     * @Bean
         * 说明spring程序启动时会读取到Configuration注解
         * 而Configuration注解会将当前的类当成基础配置类
         * 并且会寻找有没有被标注为Bean的方法，如果有则此方法会在程序启动时自动调用
         * 由Bean标注的方法为单例的
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">AppConfig：</span><br><span class="line"></span><br><span class="line">@Configuration</span><br><span class="line">public class AppConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    //说明spring程序启动时会读取到Configuration注解</span><br><span class="line">    //而Configuration注解会将当前的类当成基础配置类</span><br><span class="line">    //并且会寻找有没有被标注为Bean的方法，如果有则此方法会在程序启动时自动调用</span><br><span class="line">    public UserDao userDaoNormal()&#123;</span><br><span class="line">        System.out.println(&quot;创建UserDao对象&quot;);</span><br><span class="line">        return new UserDaoNormal();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre><code>4. 依赖注入
     * 构造函数
        * 在类中定义构造函数(无参)与有参
        * 有参构造函数将UserDao和UserService关联起来
        * 自动装配时，需要在类名上标注注解@Component;在变量上标注注解@Autowired

     * Bean方法中使用参数
        * 由于实际情况中，在调用new被Bean标记的对象的方法时无新的对象产生
        * 而是之前便存在的。所以可采取不使用new方法

     * setter
        * 通过使用setter方法，进行依赖注入
     * 任意方法
        * 同setter一样，只是改一个方法名
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">1. 自动装配的情况下：</span><br><span class="line">@Service</span><br><span class="line">public class UserServiceNormal implements UserService &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private UserDao userDao;</span><br><span class="line">    public void add() &#123;</span><br><span class="line">        userDao.add();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2.1 带有构造函数的UserServiceNormal类：</span><br><span class="line">public class UserServiceNormal implements UserService &#123;</span><br><span class="line"></span><br><span class="line">    private UserDao userDao;</span><br><span class="line"></span><br><span class="line">    //构造函数注入</span><br><span class="line">    //无参构造函数</span><br><span class="line">    public UserServiceNormal() &#123;</span><br><span class="line">        super();</span><br><span class="line">    &#125;</span><br><span class="line">    //有参构造函数</span><br><span class="line">    //将UserDao和UserService关联起来</span><br><span class="line">    public UserServiceNormal(UserDao userDao) &#123;</span><br><span class="line">        this.userDao = userDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void add() &#123;</span><br><span class="line">        userDao.add();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">2.2 构造函数的情况下：</span><br><span class="line">@Configuration</span><br><span class="line">public class AppConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public UserDao userDaoNormal()&#123;</span><br><span class="line">        System.out.println(&quot;创建UserDao对象&quot;);</span><br><span class="line">        return new UserDaoNormal();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public UserService userServiceNormal()&#123;</span><br><span class="line">        System.out.println(&quot;创建UserService对象&quot;);</span><br><span class="line">        UserDao userDao = userDaoNormal();</span><br><span class="line">        return new UserServiceNormal(userDao);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">3. Bean方法中使用参数</span><br><span class="line">    @Bean</span><br><span class="line">    public UserService userServiceNormal(UserDao userDao)&#123;</span><br><span class="line">        System.out.println(&quot;创建UserService对象&quot;);</span><br><span class="line">        return new UserServiceNormal(userDao);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">4.1 set方法</span><br><span class="line">    public void setUserDao(UserDao userDao) &#123;</span><br><span class="line">        this.userDao = userDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">4.2 setter方法依赖注入</span><br><span class="line">    @Bean</span><br><span class="line">    public UserService userServiceNormal(UserDao userDao)&#123;</span><br><span class="line">        System.out.println(&quot;创建UserService对象&quot;);</span><br><span class="line">        UserServiceNormal userService = new UserServiceNormal();</span><br><span class="line">        userService.setUserDao(userDao);</span><br><span class="line">        return userService;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<pre><code>5. 装配过程的歧义性
     1. 当接口下的多个实现类被标注了Bean注解时将发生歧义性

     2. 同自动装配中使用的方法差不多
           * 首选Bean(@Primary)
              * 调用被标注了注解为@Primary的方法
              * 同样只能有一个@Primary

           * 使用限定符
              * 使用限定符，为每一个Bean标注Qualifier
              * 在使用时，参数位置处的Qualifier需要标注在括号内；而不是类外。

           * 使用限定符和bean id
              * 使用Bean id 同限定符的作用一样
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">1. 首选Bean：</span><br><span class="line">    @Bean</span><br><span class="line">    @Primary</span><br><span class="line">    public UserDao userDaoCache()&#123;...&#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public UserService userServiceNormal(UserDao userDao)&#123;...&#125;</span><br><span class="line"></span><br><span class="line">2. 使用限定符</span><br><span class="line">    @Bean</span><br><span class="line">    @Qualifier(&quot;cache&quot;)</span><br><span class="line">    public UserDao userDaoCache()&#123;...&#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    @Qualifier(&quot;normal&quot;)</span><br><span class="line">    public UserDao userDaoNormal()&#123;...&#125;</span><br><span class="line"></span><br><span class="line">调用方：</span><br><span class="line">    @Bean</span><br><span class="line">    public UserService userServiceNormal(@Qualifier(&quot;normal&quot;)UserDao userDao)&#123;...&#125;</span><br><span class="line">    @Bean</span><br><span class="line">    public UserService userServiceNormal(@Qualifier(&quot;normal&quot;)UserDao userDao)&#123;</span><br><span class="line">        System.out.println(&quot;创建UserService对象&quot;);</span><br><span class="line">        UserServiceNormal userService = new UserServiceNormal();</span><br><span class="line">        userService.prepare(userDao);</span><br><span class="line">        return userService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">3. 使用限定符和Bean id</span><br><span class="line">    @Bean(&quot;cache&quot;)</span><br><span class="line">    public UserDao userDaoCache()&#123;...&#125; </span><br><span class="line"></span><br><span class="line">    @Bean(&quot;normal&quot;)</span><br><span class="line">    public UserDao userDaoNormal()&#123;...&#125;</span><br><span class="line"></span><br><span class="line">调用方：</span><br><span class="line">    @Bean</span><br><span class="line">    public UserService userServiceNormal(@Qualifier(&quot;normal&quot;)UserDao userDao)&#123;...&#125;</span><br></pre></td></tr></table></figure>
<h3 id="第四章————XML装配"><a href="#第四章————XML装配" class="headerlink" title="第四章————XML装配"></a>第四章————XML装配</h3><pre><code>1. 创建Bean对象
    1. 配置applicationContext.xml文件
        * 添加&lt;bean class=&quot;com.qfedu.demo.soundsystem.CompactDisc&quot;/&gt;语句
        * 此语句中的class为bean对象所在的类

    2. 配置文件中存在多个相同Bean对象时，编译器将无法识别是使用哪一个Bean对象
        * 此时需要为Bean对象赋予id
        * &lt;bean  id=&quot;compactDisc1&quot; class=&quot;com.qfedu.demo.soundsystem.CompactDisc&quot;/&gt;
        * &lt;bean  id=&quot;compactDisc2&quot; class=&quot;com.qfedu.demo.soundsystem.CompactDisc&quot;/&gt;

    3. id和name属性
        1. id属性为唯一的，不可重复
        2. name的作用是和id一样的
            * 当有多个name时，可通过空格、分号、逗号进行分割
            * name=&quot;compactDisc1 compacDisc12&quot;
        3. name中Bean对象可以有多个别名，id中Bean只能有一个别名
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">    &lt;bean id=&quot;compactDisc1&quot; class=&quot;com.qfedu.demo.soundsystem.CompactDisc&quot;/&gt;</span><br><span class="line">    &lt;bean id=&quot;compactDisc2&quot; class=&quot;com.qfedu.demo.soundsystem.CompactDisc&quot;/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean name=&quot;compactDisc1 compactDisc12&quot; class=&quot;com.qfedu.demo.soundsystem.CompactDisc&quot;/&gt;</span><br><span class="line">    &lt;bean name=&quot;compactDisc2&quot; class=&quot;com.qfedu.demo.soundsystem.CompactDisc&quot;/&gt;</span><br><span class="line">```             </span><br><span class="line"></span><br><span class="line">           4. 通过构造函数依赖注入</span><br><span class="line">               1. &lt;constructor-arg&gt;元素</span><br><span class="line">                   * 将其他对象作为参数传入此对象中</span><br><span class="line">               2. c-名称空间</span><br><span class="line">                   * 使用C名称空间，声明构造函数的参数；作为了Bean元素的一个属性</span><br><span class="line">                   * c:cd-ref</span><br><span class="line">                        * c: ——&gt;c名称空间的前缀</span><br><span class="line">                        * cd ——&gt;构造函数的参数名称</span><br><span class="line">                        * -ref——&gt;表示我们注入的是另一个Bean对象的引用</span><br></pre></td></tr></table></figure>
<ol>
<li><p><constructor-arg></constructor-arg></p>
 <bean id="CDPlayer1" class="com.qfedu.demo.soundsystem.CDPlayer"><br>     <constructor-arg ref="compactDisc1"><br> </constructor-arg></bean>
</li>
<li><p>c名称空间<br> <bean id="cdPlayer2" class="com.qfedu.demo.soundsystem.CDPlayer" c:cd-ref="compactDisc2"></bean></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">5. 简单类型的注入</span><br><span class="line">     1. 通过&lt;constructor-arg&gt;</span><br><span class="line">          * 默认情况下按照顺序逐个赋值传入对象</span><br><span class="line">     2. c-名称空间</span><br><span class="line">          * c:变量名=“值”</span><br></pre></td></tr></table></figure>
</li>
<li><p><constructor-arg></constructor-arg></p>
 <bean id="compactDisc1" class="com.qfedu.demo.soundsystem.CompactDisc"><br>     <constructor-arg index="0" value="I DO"><br>     <constructor-arg index="1" value="陈奕迅"><br> </constructor-arg></constructor-arg></bean><br> <bean id="compactDisc1" class="com.qfedu.demo.soundsystem.CompactDisc"><br>     <constructor-arg name="title" value="I DO"><br>     <constructor-arg name="artist" value="陈奕迅"><br> </constructor-arg></constructor-arg></bean>
</li>
<li><p>c-名称空间<br> <bean id="compactDisc2" class="com.qfedu.demo.soundsystem.CompactDisc" c:title="周杰伦的床边故事" c:artist="周杰伦"><br> <bean id="compactDisc3" class="com.qfedu.demo.soundsystem.CompactDisc" c:_0="周杰伦的床边故事" c:_1="周杰伦"></bean></bean></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">6. 注入list与数组类型</span><br><span class="line">     1. 简单数据类型的List</span><br><span class="line">            * 使用value</span><br><span class="line">     2. 对象类型的List </span><br><span class="line">            * 先使用Bean创建对象</span><br><span class="line">            * 再使用ref</span><br><span class="line">     3. 数组：只需将list标签改为array即可</span><br></pre></td></tr></table></figure>
</li>
<li><p>简单数据类型</p>
 <bean id="compactDisc1" class="com.qfedu.demo.soundsystem.CompactDisc"><br>     <constructor-arg name="title" value="I DO"><br>     <constructor-arg name="artist" value="陈奕迅"><br>     <constructor-arg name="tracks"><br>         <list><br>             <value>I DO 1</value><br>             <value>I DO 2</value><br>             <value>I DO 3</value><br>         </list><br>     </constructor-arg><br> </constructor-arg></constructor-arg></bean>
</li>
<li><p>对象类型<br>2.1 创建对象<br> <bean id="music1" class="com.qfedu.demo.soundsystem.Music"></bean></p>
<pre><code>&lt;constructor-arg value=&quot;I Do 1&quot;/&gt;
&lt;constructor-arg value=&quot;270&quot;/&gt;
</code></pre><p> <br> <bean id="music2" class="com.qfedu.demo.soundsystem.Music"></bean></p>
<pre><code>&lt;constructor-arg value=&quot;I Do 2&quot;/&gt;
&lt;constructor-arg value=&quot;90&quot;/&gt;
</code></pre><p> <br>2.2 使用ref<br> <bean id="compactDisc1" class="com.qfedu.demo.soundsystem.CompactDisc"></bean></p>
<pre><code>&lt;constructor-arg  name=&quot;title&quot; value=&quot;I DO&quot;/&gt;
&lt;constructor-arg  name=&quot;artist&quot; value=&quot;陈奕迅&quot;/&gt;
&lt;constructor-arg  name=&quot;tracks&quot;&gt;
    &lt;list&gt;
        &lt;ref bean=&quot;music1&quot;/&gt;
        &lt;ref bean=&quot;music2&quot;/&gt;
    &lt;/list&gt;
&lt;/constructor-arg&gt;
</code></pre><p> </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">7. 注入set与数组类型</span><br><span class="line">    1. 用法：同list一样；只需将list标签改为set即可</span><br><span class="line"> </span><br><span class="line">    </span><br><span class="line">    2. 与list的区别：set中不可出现重复的内容；重复的内容将不会再处理 </span><br><span class="line">    </span><br><span class="line">    3. 底层使用的是ListHashSet：使得顺序可以得到保证</span><br><span class="line"></span><br><span class="line">8. 注入map类型</span><br><span class="line">    1. 用法：同list一样；只需改动标签</span><br><span class="line">    </span><br><span class="line">    2. 与list的区别：</span><br><span class="line">         1. 遍历的时候，是遍历key；随后根据key来得到key和value</span><br><span class="line">         2. 在配置文件中的标签要使用&lt;entry &gt;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>遍历：<br>        for (String key : tracks.keySet()) {<br>            System.out.println(“key: “+key);<br>            Music music = tracks.get(key);<br>            System.out.println(“音乐：”+music.getTitle()+”时长：”+music.getDuration());<br>        }</p>
<p>配置文件：<br>    <bean id="compactDisc1" class="com.qfedu.demo.soundsystem.CompactDisc"><br>        <constructor-arg name="title" value="I DO"><br>        <constructor-arg name="artist" value="陈奕迅"><br>        <constructor-arg name="tracks"><br>            <map><br>                <entry key="m1" value-ref="music1"><br>                <entry key="m2" value-ref="music2"><br>                <entry key="m3" value-ref="music3"><br>            </entry></entry></entry></map><br>        </constructor-arg><br>    </constructor-arg></constructor-arg></bean><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">9. 属性注入：</span><br><span class="line">   * 即使用set方法进行依赖注入</span><br><span class="line">    1. 在配置文件中进行Bean对象的依赖注入</span><br><span class="line">         1. 使用property标签</span><br><span class="line">         2. 用name表示属性名</span><br><span class="line">         3. 简单数据用value;引用使用ref</span><br><span class="line">         4. 在配置文件中进行Bean对象的依赖注入后</span><br><span class="line">         *  只要标有注解ContextConfiguration即可自动加载出Bean</span><br></pre></td></tr></table></figure></p>
<p>两个Bean对象的依赖注入：</p>
<pre><code>&lt;bean id=&quot;music1&quot; class=&quot;com.qfedu.demo.soundsystem.Music&quot;&gt;
    &lt;property name=&quot;title&quot; value=&quot;告白气球&quot;/&gt;
    &lt;property name=&quot;duration&quot; value=&quot;215&quot;/&gt;
&lt;/bean&gt;

&lt;bean id=&quot;music2&quot; class=&quot;com.qfedu.demo.soundsystem.Music&quot;&gt;
    &lt;property name=&quot;title&quot; value=&quot;爱情废材&quot;/&gt;
    &lt;property name=&quot;duration&quot; value=&quot;305&quot;/&gt;
&lt;/bean&gt;
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">10. 属性中注入列表和数组：</span><br></pre></td></tr></table></figure>
<pre><code>&lt;bean id=&quot;CompactDisc1&quot; class=&quot;com.qfedu.demo.soundsystem.CompactDisc&quot;&gt;
    &lt;property name=&quot;title&quot; value=&quot;周杰伦的床边故事&quot;/&gt;
    &lt;property name=&quot;artist&quot; value=&quot;周杰伦&quot;/&gt;
    &lt;property name=&quot;tracks&quot;&gt;
        &lt;array&gt;
            &lt;ref bean=&quot;music1&quot;/&gt;
            &lt;ref bean=&quot;music2&quot;/&gt;
        &lt;/array&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">11. 属性中注入对象和引用：</span><br><span class="line">      * 需要配置set方法</span><br><span class="line">      * 随后在配置文件中使用set方法进行依赖注入</span><br></pre></td></tr></table></figure>
<pre><code>public void setCd(CompactDisc cd) {
    this.cd = cd;
    System.out.println(&quot;--在&quot;+this.toString()+&quot;中注入cd&quot;);
}
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">12. p名称空间：</span><br><span class="line">     1. 首先在开头的网站中引入p名称空间</span><br><span class="line">          * xmlns:p=&quot;http://www.springframework.org/schema/p&quot;</span><br><span class="line">     </span><br><span class="line">     2. p名称空间的使用</span><br><span class="line">          * 使用P：属性名=&quot;值&quot;的形式</span><br><span class="line">          * 缺点：无法代替数组、集合等形式</span><br></pre></td></tr></table></figure>
<p>p名称空间的使用</p>
<ol>
<li>简单类型 <bean id="music2" class="com.qfedu.demo.soundsystem.Music" p:title="爱情废柴" p:duration="305"></bean></li>
<li><p>对象的引用<br> &lt;bean id=”CDPlayer1” class=”com.qfedu.demo.soundsystem.CDPlayer”</p>
<pre><code>p:cd-ref=&quot;CompactDisc1&quot;/&gt;
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">13. util名称空间：</span><br><span class="line">      1. 可以处理p无法处理的数组与集合等形式</span><br><span class="line">     </span><br><span class="line">      2. 与c和p的不同：</span><br><span class="line">           * c和p的使用位置是位于元素属性位置</span><br><span class="line">           * util的使用位置是位于元素前缀位置</span><br><span class="line">          </span><br><span class="line">      3. util名称空间的使用：</span><br><span class="line">           1. 在元素前缀加上&lt;util:list&gt;&lt;/util:list&gt;标签。则在网址处将自动添加3个网址</span><br><span class="line">           2. list：可表示list与数组</span><br><span class="line">              map:表示map</span><br><span class="line">              set:表示set</span><br></pre></td></tr></table></figure>
<p> &lt;util:list id=”trackList”&gt;</p>
<pre><code>&lt;ref bean=&quot;music1&quot;/&gt;
&lt;ref bean=&quot;music2&quot;/&gt;
</code></pre><p> &lt;/util:list&gt;<br> &lt;bean id=”CompactDisc1” class=”com.qfedu.demo.soundsystem.CompactDisc”</p>
<pre><code>p:title=&quot;周杰伦的床边故事&quot;
p:artist=&quot;周杰伦&quot;
p:tracks-ref=&quot;trackList&quot;&gt;
</code></pre><p> <br><code>`</code></p>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/570911275/570911275.github.io/2019/07/26/javaSSM之Spring快速入门之中小结/" data-id="cjzal4mt4003y18tnevop4zmq" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/javaSSM-基础/">javaSSM_基础</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-javaSSM之Spring快速入门之上小结" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/26/javaSSM之Spring快速入门之上小结/" class="article-date">
  <time datetime="2019-07-26T01:57:41.000Z" itemprop="datePublished">2019-07-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/26/javaSSM之Spring快速入门之上小结/">javaSSM之Spring快速入门之上小结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h2><h3 id="第一章————入门"><a href="#第一章————入门" class="headerlink" title="第一章————入门"></a>第一章————入门</h3><pre><code>1. 概念：
   * Spring是一个非常活跃的开源框架
   * 由Rod Johnson开发
   * 帮助分离项目组件之间的依赖关系
   * 它的主要目的是简化企业开发

2. 核心概念：
   1. IOC
       * Inversion of Control
       * 控制反转
       * 对象创建以及对象之间的依赖关系的维护交给Spring
   2. DI
       * Dependency Injection
       * 依赖注入
       * 对象和对象之间的依赖关系的创建
   3. AOP
       * Aspect Oriented Programming
       * 面向切面编程

3. log4j日志
       * 导入依赖
       * *导入配置文件
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">配置文件：</span><br><span class="line"></span><br><span class="line">log4j.rootCategory=INFO, stdout</span><br><span class="line"></span><br><span class="line">log4j.appender.stdout=org.apache.log4j.ConsoleAppender</span><br><span class="line">log4j.appender.stdout.layout=org.apache.log4j.PatternLayout</span><br><span class="line">log4j.appender.stdout.layout.ConversionPattern=%d&#123;ABSOLUTE&#125; %5p %t %c&#123;2&#125;:%L - %m%n</span><br><span class="line"></span><br><span class="line">log4j.category.org.springframework.beans.factory=DEBUG</span><br><span class="line"></span><br><span class="line">导入依赖</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;log4j&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;log4j&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.2.17&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<pre><code>4. 入门程序的应用
     1. 注解方式的使用
          1. @Component
              * 此注解的作用为通知spring容器，
              * 我们应用程序的对象——此例子中为MessageService
              * 未来将通过Spring容器进行创建；无需人工new创建
          2. @ComponentScan
              * 基于注解的方式来初始化Spring容器
              * 主键扫描注解
              * 即扫描一切有注解Component的类
          3. @Autowired
              * 表示调用MessagePrinter类时，将会自动调用此方法
              * 即自动关联起MessagePrinter和MessageService的关系
     2. xml文件配置方式的使用
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--</span><br><span class="line">   bean元素：描述当前的对象需要由spring容器管理</span><br><span class="line">   id属性：标识对象，未来在应用程序中可以根据id获取对象</span><br><span class="line">   class：被管理对象的类全名</span><br><span class="line"> --&gt;</span><br><span class="line">&lt;bean id=&quot;service&quot; class=&quot;hello.MessageService&quot;&gt;&lt;/bean&gt;</span><br><span class="line">&lt;bean id=&quot;printer&quot; class=&quot;hello.MessagePrinter&quot;&gt;</span><br><span class="line">    &lt;!--name属性的值：与MessagePrinter中的service属性对应</span><br><span class="line">        ref：表示name属性指向的对象；在此例中，此对象为id=service的bean对象--&gt;</span><br><span class="line">    &lt;property name=&quot;service&quot; ref=&quot;service&quot;&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>
<h3 id="第二章————自动装配"><a href="#第二章————自动装配" class="headerlink" title="第二章————自动装配"></a>第二章————自动装配</h3><pre><code>1. bean对象的装配：
    1. 依赖注入的概念：
       * 通过Spring来管理对象和对象之间的依赖关系
    2. java中的对象称为bean对象
       * 把在java中创建bean对象和为这个对象注入依赖的过程称为装配bean或bean的装配

2. 装配bean的三种方式
     * 隐式的bean发现机制和自动装配
     * 在java中进行显示的配置
     * 在xml中进行显示的配置

3. 自动装配中的注解：
    1. 组件扫描：
         * @Component：表示这个类需要在应用程序中被创建
         * @ComponentScan：自动发现应用程序中创建的类
    2. 自动装配：
         * @Autowired：自动满足bean之间的依赖
    3. 定义配置类：
         * @Configuration：表示当前类是一个配置类
         * 作用：
             * 将ComponentScan注解与main主函数进行解耦
             * 使得在不存在main主函数时，可以在其他环境(web、安卓、iOS)下进行组件扫描

4. Junit4单元测试
     1. 引入依赖
           1. Maven：Junit、Spring-test
           2. @RunWith(SpringJUnit4ClassRunner.class)
              * 此注解为自动生成Spring的上下文环境
     2. 加载配置类
           1. @ContextConfiguration(classes=Appconfig.class)
              * 读取配置文件
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@RunWith(SpringJUnit4ClassRunner.class)</span><br><span class="line">////此注解为自动生成Spring的上下文环境</span><br><span class="line">@ContextConfiguration(classes=Appconfig.class)</span><br><span class="line">////读取配置文件</span><br><span class="line">public class AppTest &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private CDPlayer player;</span><br><span class="line">    @Test</span><br><span class="line">    public void testPlay()&#123;</span><br><span class="line">        player.play();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre><code>5. AutoWriter的应用场景
     1. 构造函数（*）
          * 自动将构造函数中的参数装配到当前类的bean对象中
          * *多个依赖的情况
          * 效率最高
     2. 用在成员变量上
          * 最便捷
     3. 用在setter方法上
     4. 用在任意方法上
     5. required属性
       *  应用场景：
          * @Autowired(required = false)[默认为true]
          * 表示注入的对象是可选的
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">1. 构造方法</span><br><span class="line">    @Autowired</span><br><span class="line">    public CDPlayer(CompactDisc cd, Power power) &#123;</span><br><span class="line">        this.cd = cd;</span><br><span class="line">        this.power = power;</span><br><span class="line">        System.out.println(&quot;CDPlayer的多参数构造函数&quot;);</span><br><span class="line"></span><br><span class="line">2. 成员变量</span><br><span class="line">    //@Autowired</span><br><span class="line">    private CompactDisc cd;</span><br><span class="line">    //@Autowired</span><br><span class="line">    private Power power;</span><br><span class="line"></span><br><span class="line">3. setter方法</span><br><span class="line">    @Autowired</span><br><span class="line">    public void setCd(CompactDisc cd) &#123;</span><br><span class="line">        this.cd = cd;</span><br><span class="line">        System.out.println(&quot;CD&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    @Autowired</span><br><span class="line">    public void setPower(Power power) &#123;</span><br><span class="line">        this.power = power;</span><br><span class="line">        System.out.println(&quot;POWER&quot;);</span><br><span class="line"></span><br><span class="line">4. 任意方法</span><br><span class="line">    @Autowired</span><br><span class="line">    public void prepare(CompactDisc cd ,Power power)&#123;</span><br><span class="line">        this.cd = cd;</span><br><span class="line">        this.power = power;</span><br><span class="line">        System.out.println(&quot;prepare&quot;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<pre><code>6. 使用接口
    1. 应用场景：
         * @Autowired(required = false)
         * 表示注入的对象是可选的
    2. 自动装配的歧义性
         * 当接口下有多个实现类且都使用了@Component注解
         * 所以当他们被扫描的时候能在Spring应用上下文里面的bean
         * 这时进行自动装配，将会发生歧义性
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class UserServiceFestival implements UserService &#123;...&#125;</span><br><span class="line"></span><br><span class="line">@Component</span><br><span class="line">public class UserServiceNormal implements UserService &#123;...&#125;</span><br></pre></td></tr></table></figure>
<pre><code>3. 自动装配的歧义性的解决方案
     1. 设置首选Bean(primary)
         * 在声明类的时候使用@Primary
         * 只能定义一个@Primary
         * 缺点：如果我们不止一个primary那么编译器将报错。则首选就没有办法解决歧义性
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">@Primary</span><br><span class="line">public class UserServiceNormal implements UserService &#123;...&#125;</span><br></pre></td></tr></table></figure>
<pre><code>2. 使用限定符(Qualifier)
    * 在声明的时候和装配的时候分别使用@Qualifier
    * 通过在实现类标识注解Qualifier，可使得调用接口时，让Spring确认是需要是需要传输该接口下的哪一个Bean对象
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">实现类：</span><br><span class="line">@Component</span><br><span class="line">@Qualifier(&quot;festival&quot;)</span><br><span class="line">public class UserServiceFestival implements UserService &#123;...&#125;</span><br><span class="line"></span><br><span class="line">@Component</span><br><span class="line">@Qualifier(&quot;normal&quot;)</span><br><span class="line">public class UserServiceNormal implements UserService &#123;...&#125;</span><br><span class="line"></span><br><span class="line">调用接口：</span><br><span class="line">@RunWith(SpringJUnit4ClassRunner.class)</span><br><span class="line">@ContextConfiguration(classes = AppConfig.class)</span><br><span class="line">public class UserServiceTest &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    @Qualifier(&quot;festival&quot;)</span><br><span class="line">    private UserService userService;</span><br><span class="line">    @Test</span><br><span class="line">    public void testAdd()&#123;</span><br><span class="line">        userService.add();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre><code>3. 使用类ID
     * 在声明的的时候指定bean的id（默认的id是首写字母小写的类名）
     * 在装配的时候使用@Qualifier
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">无默认时：</span><br><span class="line"></span><br><span class="line">实现类：</span><br><span class="line">@Component(&quot;festival&quot;)</span><br><span class="line">public class UserServiceFestival implements UserService &#123;...&#125;</span><br><span class="line">调用接口：</span><br><span class="line">public class UserServiceTest &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    @Qualifier(&quot;festival&quot;)</span><br><span class="line">    private UserService userService;</span><br><span class="line">    @Test</span><br><span class="line">    public void testAdd()&#123;</span><br><span class="line">        userService.add();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">默认时：</span><br><span class="line"></span><br><span class="line">实现类：</span><br><span class="line">@Component</span><br><span class="line">public class UserServiceFestival implements UserService &#123;...&#125;</span><br><span class="line">调用接口：</span><br><span class="line">public class UserServiceTest &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    @Qualifier(&quot;userServiceFestival&quot;)</span><br><span class="line">    private UserService userService;</span><br><span class="line">    @Test</span><br><span class="line">    public void testAdd()&#123;</span><br><span class="line">        userService.add();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre><code>4. 使用Java标准的解决方案(Resource)
     * 此方法并非Spring中的标准
     * 使用此方法可替代下边两个注解
         * @Autowired
         * @Qualifier
     * 用法同类ID
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/*    @Autowired</span><br><span class="line"> @Qualifier(&quot;festival&quot;)*/</span><br><span class="line"> @Resource(name=&quot;userServiceFestival&quot;)</span><br><span class="line"> private UserService userService;</span><br></pre></td></tr></table></figure>
<pre><code>7. 处理分层结构
    1. web程序的基本架构：
        浏览器——&gt;web层(controller)——&gt;业务层(service)——&gt;数据访问层(dao)——Data
           * 其中业务层(service)、数据访问层(dao)皆细分为接口与实现类
    2. 新的注解(Repository、service、controller)
        * Repository——dao层
        * service——service层
        * controller——web层
        * 这三个注解可替换掉@Component，更加明确的标注了此类是什么层次的类


8. 设置组件扫描的基础包
     1. 默认情况下@ComponentScan只可扫描其所在的包以及其子包下的类

     2. 解决方案：
         1. @ComponentScan(&quot;包名&quot;)
            * @ComponentScan(&quot;com.qfedu.demo&quot;)
              * 指定扫描的包名
         2. @ComponentScan(basePackages = {&quot;包名&quot;,&quot;包名&quot;,&quot;包名&quot;}) 
            * @ComponentScan(basePackages = {&quot;com.qfedu.demo.web&quot;,&quot;com.qfedu.demo.service&quot;,&quot;com.qfedu.demo.dao&quot;}) 
              * 可指定多个扫描的包名
         3. @ComponentScan(basePackagesClasses = {类名,类名,类名})
            * @ComponentScan(basePackagesClasses = {UserController.class,UserService.class,UserDao.class})
              * 可指定多个扫描的类名

     3. 通过xml启用组件扫描
         1. 配置applicationContext.xml文件(此文件的作用相当于注解@Configuration)
              * @Configuration的作用：表示该文件为配置文件

         2. 使用标签&lt;context:component-scan&gt;
              * &lt;context:component-scan base-package=&quot;com.qfedu.demo&quot;/&gt;
              * 此标签的作用相当于注解@ComponentScan(&quot;com.qfedu.demo&quot;)
              * 规划了扫描范围

         3. 使用时注解同样要发生变化
              * @ContextConfiguration(&quot;classpath:applicationContext.xml&quot;)
              * 代替了@ContextConfiguration(classes = AppConfig.class)
              * 使得其配置文件从Appconfig.class变化为applicationContext。xml配置文件

9. 小结
   1. 定义配置：
      * @Configuration
      * ComponentScan

   2. 定义组件
      * @Component
      * @Autowired
      * @Autowired(required = false)

   3. 自动装配歧义性
      * @Primary
      * @Qualifier
      * @Resource

   4. 分层架构中定义组件
      * Controller
      * Service

   5. Spring测试环境
      * RunWith
      * ContextConfiguration

   6. 使用xml启用组件扫描
      * &lt;context:component-scan base-package=&quot;...&quot;&gt;
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/570911275/570911275.github.io/2019/07/26/javaSSM之Spring快速入门之上小结/" data-id="cjzal4mt2003w18tngntwtu7m" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/javaSSM-基础/">javaSSM_基础</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-javaSSM之MyBatis高级知识之下小结" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/25/javaSSM之MyBatis高级知识之下小结/" class="article-date">
  <time datetime="2019-07-25T10:52:11.000Z" itemprop="datePublished">2019-07-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/25/javaSSM之MyBatis高级知识之下小结/">javaSSM之MyBatis高级知识之下小结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="MyBatis"><a href="#MyBatis" class="headerlink" title="MyBatis"></a>MyBatis</h2><pre><code>1. 基础知识（重点，内容多）
    对原生态jdbc程序（单独使用jdbc开发）问题总结
    mybatis框架原理（掌握）
    mybatis入门程序
         用户的增删改查
    mybatis开发两种方法：
         原始dao开发方法（程序需要编写dao接口和dao实现类）（掌握）
         mybaits的mapper接口（相当于dao接口）代理开发方法（掌握）
    mybatis配置文件SqlMapConfig.xml
    mybatis核心：
         mybatis输入映射（掌握）
         mybatis输出映射（掌握）
    mybatis的动态SQL（掌握）

 2. 高级知识
    订单商品数据模型分析
    高级结果集映射（一对一，一对多，多对多）
    mybatis延迟加载
    mybatis查询缓冲（一级缓冲、二级缓冲）
    mybaits和spring进行整合（掌握）
    mybatis逆向工程
</code></pre><h3 id="一、高级知识"><a href="#一、高级知识" class="headerlink" title="一、高级知识"></a>一、高级知识</h3><h4 id="1-mybatis查询缓存（一级缓存、二级缓存）————mybatis整合ehcache："><a href="#1-mybatis查询缓存（一级缓存、二级缓存）————mybatis整合ehcache：" class="headerlink" title="1. mybatis查询缓存（一级缓存、二级缓存）————mybatis整合ehcache："></a>1. mybatis查询缓存（一级缓存、二级缓存）————mybatis整合ehcache：</h4><pre><code>1. ehcache:
    * ehcache是一个分布式缓存框架

2. 分布缓存：
    * 我们系统为了提高系统并发，性能、一般对系统进行分布式部署（集群部署方式）
    * 不使用分布缓存，缓存的数据在各各服务单独存储，不方便系统 开发。所以要使用分布式缓存对缓存数据进行集中管理。
    * 对缓存数据进行集中管理（redis集群）使用分布式缓存框架
       * 如：redis、memcached、ehcache。。。
    * mybatis无法实现分布式缓存，因此需要和其它分布式缓存框架进行整合。

3. 整合方法：
    1. 引入缓存的依赖包
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.ehcache&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;ehcache&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;3.8.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.mybatis.caches&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;mybatis-ehcache&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.1.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<pre><code>2. 引入缓存配置文件
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;ehcache xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">         xsi:noNamespaceSchemaLocation=&quot;http://ehcache.org/ehcache.xsd&quot;&gt;</span><br><span class="line">    &lt;diskStore path=&quot;D:\ehcache&quot;/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 默认缓存配置 --&gt;</span><br><span class="line">    &lt;defaultCache</span><br><span class="line">            maxElementsInMemory=&quot;10000&quot;</span><br><span class="line">            eternal=&quot;false&quot;</span><br><span class="line">            timeToIdleSeconds=&quot;120&quot;</span><br><span class="line">            timeToLiveSeconds=&quot;120&quot;</span><br><span class="line">            overflowToDisk=&quot;true&quot;</span><br><span class="line">    /&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;/ehcache&gt;</span><br></pre></td></tr></table></figure>
<pre><code>3. 引入xsd的url
   * 打开settings-&gt;languages&amp;frameworks-&gt;schemas and dtds ,添加地址 http://ehcache.org/ehcache.xsd

4. 开启ehcache缓存
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">修改mapper.xml文件，在cache中指定EhcacheCache。</span><br><span class="line">&lt;cache type=&quot;org.mybatis.caches.ehcache.EhcacheCache&quot;/&gt;</span><br><span class="line"></span><br><span class="line">根据需求调整缓存参数：</span><br><span class="line">&lt;cache type=&quot;org.mybatis.caches.ehcache.EhcacheCache&quot; &gt; </span><br><span class="line">        &lt;property name=&quot;timeToIdleSeconds&quot; value=&quot;3600&quot;/&gt;</span><br><span class="line">        &lt;property name=&quot;timeToLiveSeconds&quot; value=&quot;3600&quot;/&gt;</span><br><span class="line">        &lt;!-- 同ehcache参数maxElementsInMemory --&gt;</span><br><span class="line">		&lt;property name=&quot;maxEntriesLocalHeap&quot; value=&quot;1000&quot;/&gt;</span><br><span class="line">		&lt;!-- 同ehcache参数maxElementsOnDisk --&gt;</span><br><span class="line">        &lt;property name=&quot;maxEntriesLocalDisk&quot; value=&quot;10000000&quot;/&gt;</span><br><span class="line">        &lt;property name=&quot;memoryStoreEvictionPolicy&quot; value=&quot;LRU&quot;/&gt;</span><br><span class="line">    &lt;/cache&gt;</span><br></pre></td></tr></table></figure>
<h4 id="2-mybaits和spring进行整合（掌握）"><a href="#2-mybaits和spring进行整合（掌握）" class="headerlink" title="2. mybaits和spring进行整合（掌握）"></a>2. mybaits和spring进行整合（掌握）</h4><pre><code>1. 整合思路：
    1. 需要spring通过单例方式管理SqlSessionFactory
    2. spring和mybatis整合生成代理对象，使用SqlSessionFactory创建SqlSession。（Spring和mybatis整合自动完成）
    3. 持久层的mapper都需要由spring进行管理

2. 整合环境
    1. 导入jar包
        * mybatis
        * spring
        * mybatis_spring整合包
        * 此处为了方便，直接导入mybatis、spring、springMVC的整合

3. sqlSessionFactory
     1. 在applicationContext.xml配置sqlSessionFactory和数据源
     2. sqlSessionFactory在mybatis和spring的整合包下
</code></pre><pre><code>&lt;!-- 加载db.properties文件 --&gt;
&lt;context:property-placeholder location=&quot;classpath:db.properties&quot;/&gt;

   &lt;!-- 配置数据库连接池 --&gt;
   &lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt;
       &lt;property name=&quot;driverClassName&quot; value=&quot;${jdbc.driver}&quot;&gt;&lt;/property&gt;
       &lt;property name=&quot;url&quot; value=&quot;${jdbc.url}&quot;&gt;&lt;/property&gt;
       &lt;property name=&quot;username&quot; value=&quot;${jdbc.username}&quot;&gt;&lt;/property&gt;
       &lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot;&gt;&lt;/property&gt;
   &lt;/bean&gt;

   &lt;!--sqlSessionFactory--&gt;
   &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;
       &lt;!--加载mybatis的配置文件--&gt;
       &lt;property name=&quot;configLocation&quot; value=&quot;SqlMapConfig.xml&quot;/&gt;
       &lt;!--数据源--&gt;
       &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;
   &lt;/bean&gt;
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/570911275/570911275.github.io/2019/07/25/javaSSM之MyBatis高级知识之下小结/" data-id="cjzal4mqr002i18tnrz7zo7g6" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/javaSSM-基础/">javaSSM_基础</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/2/">下一页 &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/javaEE-基础/">javaEE_基础</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/javaSSM-基础/">javaSSM_基础</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java-基础/">java_基础</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/javaEE-基础/" style="font-size: 20px;">javaEE_基础</a> <a href="/tags/javaSSM-基础/" style="font-size: 10px;">javaSSM_基础</a> <a href="/tags/java-基础/" style="font-size: 15px;">java_基础</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">八月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">七月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">六月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">五月 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/08/16/SQL总结/">(no title)</a>
          </li>
        
          <li>
            <a href="/2019/08/12/新文档123/">(no title)</a>
          </li>
        
          <li>
            <a href="/2019/08/03/新文档8080/">javaSSM之SpringMVC快速入门之中小结</a>
          </li>
        
          <li>
            <a href="/2019/08/03/javaSSM之SpringMVC快速入门之上小结/">javaSSM之SpringMVC快速入门之上小结</a>
          </li>
        
          <li>
            <a href="/2019/08/02/javaSSM之SpringMVC之Restful小结/">javaSSM之SpringMVC之Restful小结</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>